# A0121533W
###### /java/tars/commons/events/ui/TaskAddedEvent.java
``` java
 */
public class TaskAddedEvent extends BaseEvent {

    public final int targetIndex;
    public final ReadOnlyTask task;

    public TaskAddedEvent(int targetIndex, ReadOnlyTask task) {
        this.targetIndex = targetIndex;
        this.task = task;
    }

    @Override
    public String toString() {
        return this.getClass().getSimpleName();
    }

}
```
###### /java/tars/commons/util/DateTimeUtil.java
``` java
     */
    public static boolean isWithinWeek(LocalDateTime endDateTime) {
        if (endDateTime == null) {
            return false;
        } else {
            LocalDateTime today =
                    LocalDateTime.now().withHour(0).withMinute(0).withSecond(0);
            LocalDateTime startThisWeek =
                    today.with(TemporalAdjusters.previous(DayOfWeek.SUNDAY));
            LocalDateTime endThisWeek =
                    today.with(TemporalAdjusters.next(DayOfWeek.MONDAY));
            return endDateTime.isAfter(startThisWeek)
                    && endDateTime.isBefore(endThisWeek);
        }
    }

    /**
     * Checks if given endDateTime is before the end of today
     * 
```
###### /java/tars/commons/util/DateTimeUtil.java
``` java
     */
    public static boolean isOverDue(LocalDateTime endDateTime) {
        if (endDateTime == null) {
            return false;
        } else {
            LocalDateTime now = LocalDateTime.now();
            return endDateTime.isBefore(now);
        }
    }

    /**
     * Checks whether the dateTimeQuery falls within the range of the dateTimeSource
     * 
```
###### /java/tars/commons/util/StringUtil.java
``` java
     */
    public static String indexString(String s)
            throws InvalidRangeException, IllegalValueException {
        if (s.isEmpty()) {
            return s;
        }
        if (isSingleNumber(s)) {
            return formatSingleNumber(s);
        } else if (isListOfIndexes(s)) {
            return formatListOfIndexes(s);
        } else if (isRangeOfIndexes(s)) {
            return formateRangeOfIndexes(s);
        } else {
            throw new IllegalValueException(
                    UNEXPECTED_ERROR_IN_GETING_INDEX_FROM_STRING);
        }
    }

    private static boolean isSingleNumber(String s) {
        return (s.indexOf(STRING_WHITESPACE) == INVALID_POSITION
                && !s.contains(RANGE_SEPARATOR));
    }

    private static String formatSingleNumber(String s)
            throws IllegalValueException {
        if (!isUnsignedInteger(s)) {
            throw new IllegalValueException(INVALID_INDEX_ENTERED);
        }
        return s;
    }

    private static boolean isListOfIndexes(String s) {
        return (s.indexOf(STRING_WHITESPACE) != INVALID_POSITION
                && !s.contains(RANGE_SEPARATOR));
    }

    /**
     * Formats a list of indexes to
     * 
```
###### /java/tars/commons/util/StringUtil.java
``` java
     */
    private static String formatListOfIndexes(String s)
            throws IllegalValueException {
        String indexString = EMPTY_STRING;
        String[] indexArray = s.split(STRING_WHITESPACE);
        for (int i = START_INDEX; i < indexArray.length; i++) {
            String index = formatSingleNumber(indexArray[i]);
            indexString += index + STRING_WHITESPACE;
        }
        return indexString.trim();
    }

    private static boolean isRangeOfIndexes(String s) {
        return s.contains(RANGE_SEPARATOR);
    }

    /**
     * Formats a range of indexes to a list of indexes separated by white space
     * 
```
###### /java/tars/commons/util/StringUtil.java
``` java
     */
    private static String formateRangeOfIndexes(String s)
            throws IllegalValueException, InvalidRangeException {
        String rangeToReturn = EMPTY_STRING;

        int toIndex = s.indexOf(RANGE_SEPARATOR);
        String start = s.substring(START_INDEX, toIndex);
        String end = s.substring(toIndex + RANGE_SEPARATOR.length());

        start = formatSingleNumber(start);
        end = formatSingleNumber(end);

        int startInt = Integer.parseInt(start);
        int endInt = Integer.parseInt(end);

        if (startInt > endInt) {
            throw new InvalidRangeException();
        }

        for (int i = startInt; i <= endInt; i++) {
            rangeToReturn += String.valueOf(i) + STRING_WHITESPACE;
        }

        return rangeToReturn.trim();
    }

}
```
###### /java/tars/logic/commands/DeleteCommand.java
``` java
 */
public class DeleteCommand extends UndoableCommand {

    public static final String COMMAND_WORD = "del";

    public static final String MESSAGE_USAGE = COMMAND_WORD
            + ": Deletes the task based on its index in the task list.\n"
            + "Parameters: <INDEX> [INDEX ...]\n" + "Example: "
            + COMMAND_WORD + " 1\n" + COMMAND_WORD + " 1..3";

    public static final String MESSAGE_DELETE_TASK_SUCCESS =
            "Deleted Task:\n%1$s";
    public static final String MESSAGE_UNDO = "Added Task:\n%1$s";
    public static final String MESSAGE_REDO = "Deleted Task:\n%1$s";

    private static final String MESSAGE_MISSING_TARGET_TASK =
            "The target task cannot be missing";

    private final String arguments;
    private ArrayList<ReadOnlyTask> deletedTasks =
            new ArrayList<ReadOnlyTask>();

    public DeleteCommand(String args) {
        this.arguments = args;
    }

    @Override
    public CommandResult execute() {
        ArrayList<ReadOnlyTask> tasksToDelete = null;
        try {
            tasksToDelete = getTasksFromIndexes(
                    this.arguments.split(StringUtil.STRING_WHITESPACE));
        } catch (InvalidTaskDisplayedException itde) {
            return new CommandResult(itde.getMessage());
        }
        for (ReadOnlyTask t : tasksToDelete) {
            try {
                model.deleteTask(t);
            } catch (TaskNotFoundException tnfe) {
                assert false : MESSAGE_MISSING_TARGET_TASK;
            }
            deletedTasks.add(t);
        }
        model.getUndoableCmdHist().push(this);
        String formattedTaskList = new Formatter().formatTaskList(deletedTasks);
        return new CommandResult(
                String.format(MESSAGE_DELETE_TASK_SUCCESS, formattedTaskList));
    }

    /**
     * Gets Tasks to delete
     * 
     * @param indexes
     * @return
     * @throws InvalidTaskDisplayedException
     */
    private ArrayList<ReadOnlyTask> getTasksFromIndexes(String[] indexes)
            throws InvalidTaskDisplayedException {
        UnmodifiableObservableList<ReadOnlyTask> lastShownList =
                model.getFilteredTaskList();
        ArrayList<ReadOnlyTask> tasksList = new ArrayList<ReadOnlyTask>();

        for (int i = StringUtil.START_INDEX; i < indexes.length; i++) {
            int targetIndex = Integer.parseInt(indexes[i]);
            if (lastShownList.size() < targetIndex) {
                indicateAttemptToExecuteIncorrectCommand();
                throw new InvalidTaskDisplayedException(
                        Messages.MESSAGE_INVALID_TASK_DISPLAYED_INDEX);
            }
            ReadOnlyTask task =
                    lastShownList.get(targetIndex - StringUtil.LAST_INDEX);
            tasksList.add(task);
        }
        return tasksList;
    }

```
###### /java/tars/logic/commands/DoCommand.java
``` java
 */
public class DoCommand extends Command {

    public static final String COMMAND_WORD = "do";

    public static final String MESSAGE_USAGE = COMMAND_WORD
            + ": Marks the task based on its index in the task list as done.\n"
            + "Parameters: <INDEX> [INDEX ...]\n" + "Example: "
            + COMMAND_WORD + " 3 5 7\n" + "OR " + COMMAND_WORD + " 1..3";

    private String toDo;

    private MarkTaskUtil tracker;

    /**
     * Convenience constructor using raw values.
     * 
     * @throws InvalidRangeException
     */
    public DoCommand(String toDo) {
        this.toDo = toDo;
        this.tracker = new MarkTaskUtil();
    }

    @Override
    public CommandResult execute() {
        assert model != null;

        try {
            handleMarkDone();
        } catch (InvalidTaskDisplayedException e) {
            return new CommandResult(e.getMessage());
        } catch (DuplicateTaskException dte) {
            return new CommandResult(dte.getMessage());
        }
        return new CommandResult(tracker.getResultFromTracker());
    }

    private void handleMarkDone()
            throws InvalidTaskDisplayedException, DuplicateTaskException {
        Status done = new Status(true);
        ArrayList<ReadOnlyTask> markDoneTasks = tracker.getTasksFromIndexes(
                model, this.toDo.split(StringUtil.STRING_WHITESPACE), done);
        model.mark(markDoneTasks, done);
    }

}
```
###### /java/tars/logic/commands/EditCommand.java
``` java
 */
public class EditCommand extends UndoableCommand {

    public static final String COMMAND_WORD = "edit";

    public static final String MESSAGE_USAGE = COMMAND_WORD
            + ": Edits any component of a particular task.\n"
            + "Parameters: <INDEX> [/n TASK_NAME] [/dt DATETIME] [/p PRIORITY] "
            + "[/ta TAG_TO_ADD ...] [/tr TAG_TO_REMOVE ...]\n" + "Example: " + COMMAND_WORD
            + " 1 /n Lunch with John /dt 10/09/2016 1200 to 10/09/2016 1300 /p l /ta lunch /tr dinner";

    public static final String MESSAGE_EDIT_TASK_SUCCESS = "Edited task: %1$s";

    public static final String MESSAGE_UNDO = "Edited to %1$s to %1$s";
    public static final String MESSAGE_REDO = "Edited to %1$s to %1$s";
    
    private static final int DATETIME_INDEX_OF_ENDDATE = 1;
    private static final int DATETIME_INDEX_OF_STARTDATE = 0;

    public final int targetIndex;
    private ReadOnlyTask toBeReplacedTask;
    private Task editedTask;
    private ArgumentTokenizer argsTokenizer;

    private static final Prefix NAME_PREFIX = new Prefix("/n");
    private static final Prefix DATETIME_PREFIX = new Prefix("/dt");
    private static final Prefix PRIORITY_PREFIX = new Prefix("/p");
    private static final Prefix ADD_TAG_PREFIX = new Prefix("/ta");
    private static final Prefix REMOVE_TAG_PREFIX = new Prefix("/tr");

    /**
     * Convenience constructor using raw values.
     */
    public EditCommand(int targetIndex, ArgumentTokenizer argsTokenizer) {
        this.targetIndex = targetIndex;
        this.argsTokenizer = argsTokenizer;
    }

    @Override
    public CommandResult execute() {
        assert model != null;
        
        UnmodifiableObservableList<ReadOnlyTask> lastShownList =
                model.getFilteredTaskList();

        if (lastShownList.size() < targetIndex) {
            indicateAttemptToExecuteIncorrectCommand();
            return new CommandResult(
                    Messages.MESSAGE_INVALID_TASK_DISPLAYED_INDEX);
        }

        toBeReplacedTask = lastShownList.get(targetIndex - 1);
        editedTask = new Task(toBeReplacedTask);

        try {
            updateTask();
            model.replaceTask(toBeReplacedTask, editedTask);
            model.getUndoableCmdHist().push(this);
            return new CommandResult(
                    String.format(MESSAGE_EDIT_TASK_SUCCESS, editedTask));
        } catch (DateTimeException dte) {
            return new CommandResult(Messages.MESSAGE_INVALID_DATE);
        } catch (IllegalValueException | TagNotFoundException e) {
            return new CommandResult(e.getMessage());
        }
    }
    
    /**
     * Update task if there is a change
     * 
```
###### /java/tars/logic/commands/MarkTaskUtil.java
``` java
 */
public class MarkTaskUtil {

    private ArrayList<Integer> markDoneTasks;
    private ArrayList<Integer> markUndoneTasks;
    private ArrayList<Integer> alreadyDoneTasks;
    private ArrayList<Integer> alreadyUndoneTasks;

    public static final String SUCCESS_DONE =
            "Task: %1$s marked done successfully.\n";
    public static final String SUCCESS_UNDONE =
            "Task: %1$s marked undone successfully.\n";
    public static final String ALREADY_DONE =
            "Task: %1$s already marked done.\n";
    public static final String ALREADY_UNDONE =
            "Task: %1$s already marked undone.\n";

    /**
     * Constructor
     */
    public MarkTaskUtil() {
        this.markDoneTasks = new ArrayList<Integer>();
        this.markUndoneTasks = new ArrayList<Integer>();
        this.alreadyDoneTasks = new ArrayList<Integer>();
        this.alreadyUndoneTasks = new ArrayList<Integer>();
    }

    /**
     * Adds target index of task to relevant "To Mark List" based on status
     * 
     * @param targetIndex
     * @param status Done or Undone
     */
    public void addToMark(int targetIndex, Status status) {
        if (status.status) {
            addToMarkDoneTask(targetIndex);
        } else {
            addToMarkUndoneTask(targetIndex);
        }

    }

    /**
     * Adds target index of task to relevant "Already Marked List" based on status
     * 
     * @param targetIndex
     * @param status Done or Undone
     */
    public void addAlreadyMarked(int targetIndex, Status status) {
        if (status.status) {
            addToAlreadyDoneTasks(targetIndex);
        } else {
            addToAlreadyUndoneTasks(targetIndex);
        }
    }

    /**
     * Return string for each tasks index in the specific ArrayLists
     * 
     * @return
     */
    public String getResult() {
        String markDoneTasksString = getIndexesString(markDoneTasks);
        String markUndoneTasksString = getIndexesString(markUndoneTasks);
        String alreadyDoneTasksString = getIndexesString(alreadyDoneTasks);
        String alreadyUndoneTasksString = getIndexesString(alreadyUndoneTasks);

        String result =
                formatResults(markDoneTasksString, markUndoneTasksString,
                        alreadyDoneTasksString, alreadyUndoneTasksString);

        return result;
    }

    private String formatResults(String markDoneTasksString,
            String markUndoneTasksString, String alreadyDoneTasksString,
            String alreadyUndoneTasksString) {

        String markDoneResult =
                getResultFromString(markDoneTasksString, SUCCESS_DONE);
        String markUndoneResult =
                getResultFromString(markUndoneTasksString, SUCCESS_UNDONE);
        String alreadyDoneResult =
                getResultFromString(alreadyDoneTasksString, ALREADY_DONE);
        String aldreadyUndoneResult =
                getResultFromString(alreadyUndoneTasksString, ALREADY_UNDONE);

        return markDoneResult + markUndoneResult + alreadyDoneResult
                + aldreadyUndoneResult;
    }

    /**
     * 
     */
    private String getResultFromString(String tasksString, String format) {
        String result = "";
        if (!tasksString.isEmpty()) {
            result = String.format(format, tasksString);
        }
        return result;
    }

    /**
     * Gets String of indexes separated by comma
     */
    private String getIndexesString(ArrayList<Integer> list) {
        String toReturn = StringUtil.EMPTY_STRING;
        if (list.size() != 0) {
            for (int i = 0; i < list.size() - 1; i++) {
                toReturn += Integer.toString(list.get(i)) + StringUtil.STRING_COMMA;
            }
            // Add last index
            toReturn += Integer.toString(list.get(list.size() - 1));
        }
        return toReturn;
    }

    private void addToMarkDoneTask(int index) {
        this.markDoneTasks.add(index);
    }

    private void addToMarkUndoneTask(int index) {
        this.markUndoneTasks.add(index);
    }

    private void addToAlreadyDoneTasks(int index) {
        this.alreadyDoneTasks.add(index);
    }

    private void addToAlreadyUndoneTasks(int index) {
        this.alreadyUndoneTasks.add(index);
    }

    /**
     * Returns feedback message of mark command to user
     * 
     * @return
     */
    public String getResultFromTracker() {
        String commandResult = getResult();
        return commandResult;
    }

    /**
     * Gets Tasks to mark from indexes
     * 
     * @param model
     * @param indexes
     * @return
     * @throws InvalidTaskDisplayedException
     */
    public ArrayList<ReadOnlyTask> getTasksFromIndexes(Model model,
            String[] indexes, Status status)
            throws InvalidTaskDisplayedException {
        UnmodifiableObservableList<ReadOnlyTask> lastShownList =
                model.getFilteredTaskList();
        ArrayList<ReadOnlyTask> tasksList = new ArrayList<ReadOnlyTask>();

        for (int i = 0; i < indexes.length; i++) {
            int targetIndex = Integer.valueOf(indexes[i]);
            if (lastShownList.size() < targetIndex) {
                throw new InvalidTaskDisplayedException(
                        Messages.MESSAGE_INVALID_TASK_DISPLAYED_INDEX);
            }

            ReadOnlyTask task = lastShownList.get(targetIndex - 1);
            if (!task.getStatus().equals(status)) {
                tasksList.add(task);
                addToMark(targetIndex, status);
            } else {
                addAlreadyMarked(targetIndex, status);
            }
        }
        return tasksList;
    }

}
```
###### /java/tars/logic/commands/UdCommand.java
``` java
 */
public class UdCommand extends Command {

    public static final String COMMAND_WORD = "ud";

    public static final String MESSAGE_USAGE = COMMAND_WORD
            + ": Marks the task based on its index in the task list as undone.\n"
            + "Parameters: <INDEX> [INDEX ...]\n" + "Example: "
            + COMMAND_WORD + " 3 5 7" + "OR " + COMMAND_WORD + " 1..3\n";

    private String toUndo;

    private MarkTaskUtil tracker;

    /**
     * Convenience constructor using raw values.
     * 
     * @throws InvalidRangeException
     */
    public UdCommand(String toUndo) {
        this.toUndo = toUndo;
        this.tracker = new MarkTaskUtil();
    }

    @Override
    public CommandResult execute() {
        assert model != null;

        try {
            handleMarkUndone();
        } catch (InvalidTaskDisplayedException e) {
            return new CommandResult(e.getMessage());
        } catch (DuplicateTaskException dte) {
            return new CommandResult(dte.getMessage());
        }
        return new CommandResult(tracker.getResultFromTracker());
    }

    private void handleMarkUndone()
            throws InvalidTaskDisplayedException, DuplicateTaskException {
        Status undone = new Status(false);
        ArrayList<ReadOnlyTask> markUndoneTasks = tracker.getTasksFromIndexes(
                model, this.toUndo.split(StringUtil.STRING_WHITESPACE), undone);
        model.mark(markUndoneTasks, undone);
    }

}
```
###### /java/tars/logic/parser/EditCommandParser.java
``` java
 *
 */
public class EditCommandParser extends CommandParser {

    private static final int START_INDEX = 0;
    private static final int EMPTY_SIZE = 0;

    /**
     * Parses arguments in the context of the edit task command.
     * 
     * @param args full command args string
     * @return the prepared command
     */
    @Override
    public Command prepareCommand(String args) {
        args = args.trim();
        int targetIndex = START_INDEX;
        if (args.indexOf(StringUtil.STRING_WHITESPACE) != StringUtil.INVALID_POSITION) {
            targetIndex = args.indexOf(StringUtil.STRING_WHITESPACE);
        }

        String index;
        try {
            index = StringUtil.indexString((args.substring(StringUtil.START_INDEX, targetIndex)));
        } catch (Exception e) {
            return new IncorrectCommand(String.format(
                    MESSAGE_INVALID_COMMAND_FORMAT, EditCommand.MESSAGE_USAGE));
        }

        if (index.isEmpty()) {
            return new IncorrectCommand(String.format(
                    MESSAGE_INVALID_COMMAND_FORMAT, EditCommand.MESSAGE_USAGE));
        }

        ArgumentTokenizer argsTokenizer = new ArgumentTokenizer(namePrefix,
                priorityPrefix, dateTimePrefix, addTagPrefix, removeTagPrefix);
        argsTokenizer.tokenize(args);

        if (argsTokenizer.numPrefixFound() == EMPTY_SIZE) {
            return new IncorrectCommand(String.format(
                    MESSAGE_INVALID_COMMAND_FORMAT, EditCommand.MESSAGE_USAGE));
        }

        return new EditCommand(Integer.parseInt(index), argsTokenizer);
    }

}
```
###### /java/tars/model/ModelManager.java
``` java
  @Override
  public synchronized void mark(ArrayList<ReadOnlyTask> toMarkList, Status status)
      throws DuplicateTaskException {
    tars.mark(toMarkList, status);
    indicateTarsChanged();

  }

  /**
   * Returns a string of tasks and rsv tasks whose datetime conflicts with a specified datetime
   * 
```
###### /java/tars/model/Tars.java
``` java
     * @throws DuplicateTaskException if replacement task is the same as the task to replace
     */
    public void replaceTask(ReadOnlyTask toReplace, Task replacement)
            throws DuplicateTaskException {
        if (toReplace.isSameStateAs(replacement)) {
            throw new DuplicateTaskException();
        }

        ObservableList<Task> list = this.tasks.getInternalList();
        for (int i = 0; i < list.size(); i++) {
            if (list.get(i).isSameStateAs(toReplace)) {
                syncTagsWithMasterList(replacement);
                list.set(i, replacement);
                break;
            }
        }
    }

    public void setTags(Collection<Tag> tags) {
        this.tags.getInternalList().setAll(tags);
    }

    public void resetData(Collection<? extends ReadOnlyTask> newTasks, Collection<RsvTask> newRsvTasks, Collection<Tag> newTags) {
        setTasks(newTasks.stream().map(Task::new).collect(Collectors.toList()));
        setRsvTasks(newRsvTasks.stream().collect(Collectors.toList()));
        setTags(newTags);
    }

    public void resetData(ReadOnlyTars newData) {
        resetData(newData.getTaskList(), newData.getRsvTaskList(), newData.getTagList());
    }

    //// task-level operations

    /**
     * Adds a task to tars. Also checks the new task's tags and updates {@link #tags} with any new
     * tags found, and updates the Tag objects in the task to point to those in {@link #tags}.
     *
     * @throws UniqueTaskList.DuplicateTaskException if an equivalent task already exists.
     */
    public void addTask(Task p) throws DuplicateTaskException {
        syncTagsWithMasterList(p);
        tasks.add(p);
    }

    /**
     * Adds a reserved task to tars.
     *
```
###### /java/tars/model/Tars.java
``` java
     * @throws DuplicateTaskException
     */
    public void mark(ArrayList<ReadOnlyTask> toMarkList, Status status) throws DuplicateTaskException {
        for (ReadOnlyTask t : toMarkList) {
            if (!t.getStatus().equals(status)) {
                // prevent marking tasks which are already marked
                Task toMark = new Task(t);
                toMark.setStatus(status);
                replaceTask(t, toMark);
            }
        }
    }

    /**
     * Ensures that every tag in this task: - exists in the master list
     * {@link #tags} - points to a Tag object in the master list
     */
    private void syncTagsWithMasterList(Task task) {
        final UniqueTagList taskTags = task.getTags();
        tags.mergeFrom(taskTags);

        // Create map with values = tag object references in the master list
        final Map<Tag, Tag> masterTagObjects = new HashMap<>();
        for (Tag tag : tags) {
            masterTagObjects.put(tag, tag);
        }

        // Rebuild the list of task tags using references from the master list
        final Set<Tag> commonTagReferences = new HashSet<>();
        for (Tag tag : taskTags) {
            commonTagReferences.add(masterTagObjects.get(tag));
        }
        task.setTags(new UniqueTagList(commonTagReferences));
    }

    public boolean removeTask(ReadOnlyTask key) throws UniqueTaskList.TaskNotFoundException {
        if (tasks.remove(key)) {
            return true;
        } else {
            throw new UniqueTaskList.TaskNotFoundException();
        }
    }

    public boolean removeRsvTask(RsvTask key) throws RsvTaskNotFoundException {
        if (rsvTasks.remove(key)) {
            return true;
        } else {
            throw new RsvTaskNotFoundException();
        }
    }

    /** 
     * Sorts internal list by priority from low to high
     * 
```
###### /java/tars/ui/formatter/Formatter.java
``` java
     */
    public static String formatDateTimeList(ArrayList<DateTime> dateTimeList) {
        String formatted = "";
        int count = 1;
        for (DateTime dt : dateTimeList) {
            formatted +=
                    "[" + count + "] " + DateFormatter.formatDate(dt) + "\n\n";
            count++;
        }
        return formatted;
    }

    /**
     * Formats a given tasks list to display on This Week Panel
     * 
```
###### /java/tars/ui/formatter/Formatter.java
``` java
     */
    public static String formatThisWeekPanelTasksList(
            List<ReadOnlyTask> overduedTasks) {
        String formatted = "";
        int count = 1;
        for (ReadOnlyTask t : overduedTasks) {
            String taskName = t.getName().toString();
            if (!formatted.contains(taskName)) {
                formatted += "[" + count + "] " + t.getName().toString() + "\n";
            }
            count++;
        }
        return formatted.trim();
    }
}
```
###### /java/tars/ui/Header.java
``` java
 */
public class Header extends UiPart {
    private static final String HEADER_STYLE_SHEET = "header";
    private static final String FXML = "Header.fxml";

    private AnchorPane placeHolder;
    private AnchorPane mainPane;

    @FXML
    private HBox header;

    public static Header load(Stage primaryStage, AnchorPane placeHolder) {
        Header infoHeader = UiPartLoader.loadUiPart(primaryStage, placeHolder,
                new Header());
        infoHeader.configure();
        return infoHeader;
    }

    public void configure() {
        header.getStyleClass().add(HEADER_STYLE_SHEET);
        FxViewUtil.applyAnchorBoundaryParameters(header, 0.0, 0.0, 0.0, 0.0);
        FxViewUtil.applyAnchorBoundaryParameters(mainPane, 0.0, 0.0, 0.0, 0.0);
        placeHolder.getChildren().add(mainPane);
        registerAsAnEventHandler(this);
    }

    @Override
    public void setNode(Node node) {
        mainPane = (AnchorPane) node;
    }

    @Override
    public void setPlaceholder(AnchorPane placeholder) {
        this.placeHolder = placeholder;
    }

    @Override
    public String getFxmlPath() {
        return FXML;
    }

}
```
###### /java/tars/ui/HelpPanel.java
``` java
 */
public class HelpPanel extends UiPart {
    private static final String FXML = "HelpPanel.fxml";
    private static final String USERGUIDE_URL = "/html/UserGuide.md.html";

    private VBox panel;
    private AnchorPane placeHolderPane;
    private WebView browser;

    public static HelpPanel load(Stage primaryStage,
            AnchorPane helpPanelPlaceHolder) {
        HelpPanel helpPanel = UiPartLoader.loadUiPart(primaryStage,
                helpPanelPlaceHolder, new HelpPanel());
        helpPanel.configure();
        return helpPanel;
    }

    @Override
    public void setNode(Node node) {
        panel = (VBox) node;
    }

    @Override
    public String getFxmlPath() {
        return FXML;
    }

    @Override
    public void setPlaceholder(AnchorPane pane) {
        this.placeHolderPane = pane;
    }

    private void addToPlaceholder() {
        placeHolderPane.getChildren().add(panel);
    }

    private void configure() {
        browser = new WebView();
        browser.getEngine().load(configureURL(UserGuide.DEFAULT));
        FxViewUtil.applyAnchorBoundaryParameters(browser, 0.0, 0.0, 0.0, 0.0);
        panel.getChildren().add(browser);
        addToPlaceholder();
    }

    /**
```
###### /java/tars/ui/MainWindowEventsHandler.java
``` java
 */
public class MainWindowEventsHandler {

    private double xOffset = 0;
    private double yOffset = 0;
    private final Logger logger = LogsCenter.getLogger(MainWindow.class);

    private VBox rootLayout;
    private TabPane tabPane;
    protected Stage primaryStage;

    public MainWindowEventsHandler(Stage primaryStage, VBox rootLayout,
            TabPane tabPane) {
        this.rootLayout = rootLayout;
        this.primaryStage = primaryStage;
        this.tabPane = tabPane;
        EventsCenter.getInstance().registerHandler(this);
    }

    public void addMouseEventHandler() {
        rootLayout.setOnMousePressed(new EventHandler<MouseEvent>() {
            @Override
            public void handle(MouseEvent event) {
                xOffset = event.getSceneX();
                yOffset = event.getSceneY();
            }
        });
        rootLayout.setOnMouseDragged(new EventHandler<MouseEvent>() {
            @Override
            public void handle(MouseEvent event) {
                primaryStage.setX(event.getScreenX() - xOffset);
                primaryStage.setY(event.getScreenY() - yOffset);
            }
        });
    }

    public void addTabPaneHandler() {
        rootLayout.setOnKeyPressed(new EventHandler<KeyEvent>() {
            @Override
            public void handle(KeyEvent event) {
                if (event.getCode() == KeyCode.RIGHT) {
                    cycleTabPaneRight();
                    event.consume();
                } else if (event.getCode() == KeyCode.LEFT) {
                    cycleTabPaneLeft();
                    event.consume();
                }
            }
        });
    }

    @Subscribe
    private void KeyCombinationPressedEventHandler(
            KeyCombinationPressedEvent event) {
        logger.info(LogsCenter.getEventHandlingLogMessage(event,
                event.getKeyCombination().getDisplayText()));
        if (event
                .getKeyCombination() == KeyCombinations.KEY_COMB_CTRL_RIGHT_ARROW) {
            cycleTabPaneRight();
        } else if (event
                .getKeyCombination() == KeyCombinations.KEY_COMB_CTRL_LEFT_ARROW) {
            cycleTabPaneLeft();
        }
    }

    @Subscribe
    private void CommandBoxTextFieldValueChangedEventHandler(
            CommandBoxTextFieldValueChangedEvent event) {
        logger.info(LogsCenter.getEventHandlingLogMessage(event,
                event.getTextFieldValue() + " command detected."));
        if (event.getTextFieldValue().equals(RsvCommand.COMMAND_WORD) || event
                .getTextFieldValue().equals(ConfirmCommand.COMMAND_WORD)) {
            tabPane.getSelectionModel()
                    .select(MainWindow.RSV_TASK_LIST_PANEL_TAB_PANE_INDEX);
        }
    }

    private void cycleTabPaneRight() {
        if (tabPane.getSelectionModel()
                .isSelected((MainWindow.HELP_PANEL_TAB_PANE_INDEX))) {
            tabPane.getSelectionModel().selectFirst();
        } else {
            tabPane.getSelectionModel().selectNext();
        }
    }

    private void cycleTabPaneLeft() {
        if (tabPane.getSelectionModel()
                .isSelected((MainWindow.OVERVIEW_PANEL_TAB_PANE_INDEX))) {
            tabPane.getSelectionModel().selectLast();
        } else {
            tabPane.getSelectionModel().selectPrevious();
        }
    }

    /**
```
###### /java/tars/ui/RsvTaskCard.java
``` java
 */
public class RsvTaskCard extends UiPart {

    private static final String FXML = "RsvTaskListCard.fxml";
    private static final String DATETIMELIST_ID = "dateTimeList";

    private TextArea dateTimeListArea;
    private AnchorPane dateTimeListPane;

    private StringProperty dateTimeListdisplayed = new SimpleStringProperty("");

    @FXML
    private HBox cardPane;
    @FXML
    private Label name;
    @FXML
    private Label id;

    private RsvTask rsvTask;
    private int displayedIndex;

    public RsvTaskCard() {

    }

    public static RsvTaskCard load(RsvTask rsvTask, int displayedIndex) {
        RsvTaskCard card = new RsvTaskCard();
        card.cardPane = new HBox();
        card.dateTimeListPane = new AnchorPane();

        card.rsvTask = rsvTask;
        card.displayedIndex = displayedIndex;
        return UiPartLoader.loadUiPart(card);
    }

    @FXML
    public void initialize() {
        name.setText(rsvTask.getName().taskName);
        id.setText(displayedIndex + ". ");
        setDateTimeList();
        configure();
    }

    public void configure() {
        dateTimeListArea = new TextArea();
        dateTimeListArea.setEditable(false);
        dateTimeListArea.setId(DATETIMELIST_ID);

        dateTimeListArea.getStyleClass().removeAll();
        dateTimeListArea.setWrapText(true);
        dateTimeListArea.setPrefSize(200, 75);
        dateTimeListArea.textProperty().bind(dateTimeListdisplayed);
        dateTimeListArea.autosize();

        dateTimeListPane.getChildren().add(dateTimeListArea);
        cardPane.getChildren().add(dateTimeListPane);
    }

    private void setDateTimeList() {
        ArrayList<DateTime> dateTimeList = rsvTask.getDateTimeList();
        Collections.sort(dateTimeList);
        String toSet = Formatter.formatDateTimeList(dateTimeList);
        dateTimeListdisplayed.setValue(toSet);
    }

    public HBox getLayout() {
        return cardPane;
    }

    @Override
    public void setNode(Node node) {
        cardPane = (HBox) node;
        dateTimeListPane = (AnchorPane) node;
    }

    @Override
    public String getFxmlPath() {
        return FXML;
    }
}
```
###### /java/tars/ui/RsvTaskListPanel.java
``` java
 */
public class RsvTaskListPanel extends UiPart {
    private static final String FXML = "RsvTaskListPanel.fxml";
    private VBox panel;
    private AnchorPane placeHolderPane;
    private static final int START_INDEX = 1;

    @FXML
    private ListView<RsvTask> rsvTaskListView;

    public RsvTaskListPanel() {
        super();
    }

    @Override
    public void setNode(Node node) {
        panel = (VBox) node;
    }

    @Override
    public String getFxmlPath() {
        return FXML;
    }

    @Override
    public void setPlaceholder(AnchorPane pane) {
        this.placeHolderPane = pane;
    }

    public static RsvTaskListPanel load(Stage primaryStage,
            AnchorPane rsvTaskListPlaceholder,
            ObservableList<RsvTask> rsvTaskList) {
        RsvTaskListPanel rsvTaskListPanel = UiPartLoader.loadUiPart(
                primaryStage, rsvTaskListPlaceholder, new RsvTaskListPanel());
        rsvTaskListPanel.configure(rsvTaskList);
        return rsvTaskListPanel;
    }

    private void configure(ObservableList<RsvTask> rsvTaskList) {
        setConnections(rsvTaskList);
        addToPlaceholder();
    }

    private void setConnections(ObservableList<RsvTask> rsvTaskList) {
        rsvTaskListView.setItems(rsvTaskList);
        rsvTaskListView.setCellFactory(listView -> new RsvTaskListViewCell());
    }

    private void addToPlaceholder() {
        SplitPane.setResizableWithParent(placeHolderPane, false);
        placeHolderPane.getChildren().add(panel);
    }

    public void scrollTo(int index) {
        Platform.runLater(() -> {
            rsvTaskListView.scrollTo(index);
        });
    }

    class RsvTaskListViewCell extends ListCell<RsvTask> {

        public RsvTaskListViewCell() {}

        @Override
        protected void updateItem(RsvTask task, boolean empty) {
            super.updateItem(task, empty);

            if (empty || task == null) {
                setGraphic(null);
                setText(null);
            } else {
                setGraphic(RsvTaskCard.load(task, getIndex() + START_INDEX)
                        .getLayout());
            }
        }
    }

}
```
###### /java/tars/ui/TaskCard.java
``` java
 *
 */
public class TaskCard extends UiPart {

    private static final String FXML = "TaskListCard.fxml";
    private static final String PRIORITY_HIGH = "high";
    private static final String PRIORITY_MEDIUM = "medium";
    private static final String PRIORITY_LOW = "low";
    private static final String STATUS_UNDONE = "Undone";
    private static final Object STATUS_DONE = "Done";

    @FXML
    private HBox cardPane;
    @FXML
    private Label name;
    @FXML
    private Label id;
    @FXML
    private Label date;
    @FXML
    private Label statusTick;
    @FXML
    private Label tags;
    @FXML
    private Circle priorityCircle;

    private ReadOnlyTask task;
    private int displayedIndex;

    public TaskCard() {

    }

    public static TaskCard load(ReadOnlyTask task, int displayedIndex) {
        TaskCard card = new TaskCard();
        card.task = task;
        card.displayedIndex = displayedIndex;
        card.registerAsAnEventHandler(card);
        return UiPartLoader.loadUiPart(card);
    }

    @FXML
    public void initialize() {
        setName();
        setIndex();
        setDate();
        setPriority();
        setTickColorByStatus();
        setTags();
        setTextFillByStatus();
    }

    private void setName() {
        name.setText(task.getName().taskName);
    }

    private void setIndex() {
        id.setText(displayedIndex + ". ");
    }

    private void setDate() {
        date.setText(DateFormatter.formatDate(task.getDateTime()));
    }

    /**
     * Sets tick priority color based on the status of a task
     */
    private void setTickColorByStatus() {
        if (task.getStatus().toString().equals(STATUS_UNDONE)) {
            statusTick.setStyle("-fx-text-fill: transparent");
        } else {
            statusTick.setStyle(UiColor.STATUS_DONE_TICK_COLOR);
        }
    }

    /**
     * Sets text to different color based on the status of a task
     */
    private void setTextFillByStatus() {
        String taskStatus = task.getStatus().toString();
        String color = StringUtil.EMPTY_STRING;
        if (taskStatus.equals(STATUS_UNDONE)) {
            color = UiColor.STATUS_UNDONE_TEXT_FILL;
        } else if (taskStatus.equals(STATUS_DONE)) {
            color = UiColor.STATUS_DONE_TEXT_FILL;
        } else {
            // default case
            color = UiColor.STATUS_UNDONE_TEXT_FILL;
        }
        id.setStyle(color);
        name.setStyle(color);
        date.setStyle(color);
        tags.setStyle(color);
    }

    @Subscribe
    private void handleTarsChangeEvent(TarsChangedEvent event) {
        setTextFillByStatus();
        setTickColorByStatus();
    }

    /**
     * Sets colors to priority label based on task's priority
     * 
```
###### /java/tars/ui/TaskCard.java
``` java
     */
    private void setPriority() {
        switch (task.priorityString()) {
            case PRIORITY_HIGH:
                priorityCircle.setFill(UiColor.Priority.HIGH.getCircleColor());
                break;
            case PRIORITY_MEDIUM:
                priorityCircle
                        .setFill(UiColor.Priority.MEDIUM.getCircleColor());
                break;
            case PRIORITY_LOW:
                priorityCircle.setFill(UiColor.Priority.LOW.getCircleColor());
                break;
            default:
                priorityCircle
                        .setFill(UiColor.Priority.DEFAULT.getCircleColor());
                break;
        }
    }

    private void setTags() {
        tags.setText(task.tagsString());
    }

    public HBox getLayout() {
        return cardPane;
    }

    @Override
    public void setNode(Node node) {
        cardPane = (HBox) node;
    }

    @Override
    public String getFxmlPath() {
        return FXML;
    }

}
```
###### /java/tars/ui/TaskListPanel.java
``` java
 */
public class TaskListPanel extends UiPart {
    private static final Logger logger = LogsCenter.getLogger(UiManager.class);
    private static final String FXML = "TaskListPanel.fxml";
    private AnchorPane placeHolderPane;

    @FXML
    private ListView<ReadOnlyTask> taskListView;
    @FXML
    private VBox panel;

    @Override
    public void setNode(Node node) {
        panel = (VBox) node;
    }

    @Override
    public String getFxmlPath() {
        return FXML;
    }

    @Override
    public void setPlaceholder(AnchorPane pane) {
        this.placeHolderPane = pane;
    }

    public static TaskListPanel load(Stage primaryStage,
            AnchorPane taskListPlaceholder,
            ObservableList<ReadOnlyTask> taskList) {
        TaskListPanel taskListPanel = UiPartLoader.loadUiPart(primaryStage,
                taskListPlaceholder, new TaskListPanel());
        taskListPanel.configure(taskList);
        return taskListPanel;
    }

    private void configure(ObservableList<ReadOnlyTask> taskList) {
        setConnections(taskList);
        addToPlaceholder();
    }

    private void setConnections(ObservableList<ReadOnlyTask> taskList) {
        taskListView.setItems(taskList);
        taskListView.setCellFactory(listView -> new TaskListViewCell());
    }

    private void addToPlaceholder() {
        SplitPane.setResizableWithParent(placeHolderPane, false);
        placeHolderPane.getChildren().add(panel);
    }

    public void scrollTo(int index) {
        Platform.runLater(() -> {
            taskListView.scrollTo(index);
        });
    }

    class TaskListViewCell extends ListCell<ReadOnlyTask> {
        private ReadOnlyTask newlyAddedTask;

        public TaskListViewCell() {
            registerAsAnEventHandler(this);
        }

        @Override
        protected void updateItem(ReadOnlyTask task, boolean empty) {
            super.updateItem(task, empty);

            if (empty || task == null) {
                setGraphic(null);
                setText(null);
            } else {
                TaskCard card = TaskCard.load(task, getIndex() + 1);
                HBox layout = card.getLayout();
                if (this.newlyAddedTask != null
                        && this.newlyAddedTask.isSameStateAs(task)) {
                    layout.setStyle("-fx-border-color: #607D8B");
                } else {
                    layout.setStyle("-fx-border-color: #9E9E9E");
                }
                setGraphic(layout);
            }
        }

        @Subscribe
        private void handleTaskAddedEvent(TaskAddedEvent event) {
            logger.info(LogsCenter.getEventHandlingLogMessage(event,
                    "Updating layout for " + event.task.toString()));
            this.newlyAddedTask = event.task;
        }
    }

}
```
###### /java/tars/ui/ThisWeekPanel.java
``` java
 */
public class ThisWeekPanel extends UiPart {
    private static final String TasksListEllipsis = "\n...\n";
    private static final Logger logger =
            LogsCenter.getLogger(ThisWeekPanel.class);
    private static final String FXML = "ThisWeekPanel.fxml";
    private static final String THISWEEK_PANEL_STYLE_SHEET = "thisWeek-panel";
    private static final String STATUS_UNDONE = "Undone";
    private static final DateFormat df = new SimpleDateFormat("E d, MMM");

    private static List<ReadOnlyTask> list;
    private static List<ReadOnlyTask> upcomingTasks =
            new ArrayList<ReadOnlyTask>();
    private static List<ReadOnlyTask> overduedTasks =
            new ArrayList<ReadOnlyTask>();

    private VBox panel;
    private AnchorPane placeHolderPane;

    @FXML
    private Label date;
    @FXML
    private Label numUpcoming;
    @FXML
    private Label numOverdue;
    @FXML
    private Label overduedTasksList;
    @FXML
    private Label upcomingTasksList;

    public static ThisWeekPanel load(Stage primaryStage,
            AnchorPane thisWeekPanelPlaceHolder, List<ReadOnlyTask> taskList) {
        ThisWeekPanel thisWeekPanel = UiPartLoader.loadUiPart(primaryStage,
                thisWeekPanelPlaceHolder, new ThisWeekPanel());
        list = taskList;
        thisWeekPanel.configure();
        return thisWeekPanel;
    }

    @Override
    public void setNode(Node node) {
        panel = (VBox) node;
    }

    @Override
    public String getFxmlPath() {
        return FXML;
    }

    @Override
    public void setPlaceholder(AnchorPane pane) {
        this.placeHolderPane = pane;
    }

    private void addToPlaceholder() {
        SplitPane.setResizableWithParent(placeHolderPane, false);
        placeHolderPane.getChildren().add(panel);
    }

    private void configure() {
        panel.getStyleClass().add(THISWEEK_PANEL_STYLE_SHEET);
        setDate();
        handleUpcomingTasks();
        handleOverdueTasks();
        addToPlaceholder();
        registerAsAnEventHandler(this);
    }

    private void setDate() {
        Date today = new Date();
        date.setText(df.format(today));
    }
    
    private void handleUpcomingTasks() {
        int count = 0;
        for (ReadOnlyTask t : list) {
            if (DateTimeUtil.isWithinWeek(t.getDateTime().getEndDate())
                    && t.getStatus().toString().equals(STATUS_UNDONE)) {
                count++;
                upcomingTasks.add(t);
            }
        }
        numUpcoming.setText(String.valueOf(count));
        if (count == 0) {
            upcomingTasksList.setText(StringUtil.EMPTY_STRING);
        } else {
            setThisWeekPanelTaskList(count, upcomingTasks, upcomingTasksList);
        }
    }

    private void handleOverdueTasks() {
        int count = 0;
        for (ReadOnlyTask t : list) {
            if (DateTimeUtil.isOverDue(t.getDateTime().getEndDate())
                    && t.getStatus().toString().equals(STATUS_UNDONE)) {
                count++;
                overduedTasks.add(t);
            }
        }
        numOverdue.setText(String.valueOf(count));
        if (count == 0) {
            overduedTasksList.setText(StringUtil.EMPTY_STRING);
        } else {
            setThisWeekPanelTaskList(count, overduedTasks, overduedTasksList);
        }
    }
    
    /**
     * Set text for tasksLists to display top three tasks
     * 
     */
    private void setThisWeekPanelTaskList(int count, List<ReadOnlyTask> tasksList, Label taskListLabel) {
            List<ReadOnlyTask> topFiveTasks = tasksList.subList(
                    StringUtil.START_INDEX, Math.min(tasksList.size(), 3));
            String list = Formatter
                    .formatThisWeekPanelTasksList(topFiveTasks);
            if (tasksList.size() > 3) {
                list = list + TasksListEllipsis;
            }
            taskListLabel.setText(list);
    }
    
    /**
     * Updates panel with latest data
     */
    private void updateThisWeekPanel() {
        upcomingTasks.clear();
        handleUpcomingTasks();
        overduedTasks.clear();
        handleOverdueTasks();
    }

    @Subscribe
    private void handleTarsChangedEvent(TarsChangedEvent event) {
        logger.info(LogsCenter.getEventHandlingLogMessage(event,
                "Update this week panel"));
        updateThisWeekPanel();
    }
    
    @Subscribe
    private void handleTarsStorageChangeDirectoryEvent(
            TarsStorageDirectoryChangedEvent event) {
        logger.info(LogsCenter.getEventHandlingLogMessage(event,
                "Update this week panel"));
        updateThisWeekPanel();
    }
}
```
###### /java/tars/ui/UiColor.java
``` java
 *
 */
public class UiColor {

    public static final String STATUS_UNDONE_TEXT_FILL =
            "-fx-text-fill: #212121";
    public static final String STATUS_DONE_TEXT_FILL = "-fx-text-fill: #BDBDBD";
    public static final String STATUS_DONE_TICK_COLOR = "-fx-text-fill: white";;

    public enum Priority {
        HIGH(Color.RED), MEDIUM(Color.ORANGE), LOW(Color.GREEN), DEFAULT(
                Color.DARKGREY);
        private Color circleColor;

        Priority(Color circleColor) {
            this.circleColor = circleColor;
        }

        Color getCircleColor() {
            return circleColor;
        }
    }
}
```
