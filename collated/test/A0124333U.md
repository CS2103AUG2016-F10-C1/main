# A0124333U
###### \java\guitests\CommandBoxTest.java
``` java
    @Test
    public void commandBox_cycleThroughCommandTextHist() {
        commandBox.runCommand("User Input Command");
        commandBox.runCommand("User Input Command 2");
        commandBox.runCommand("User Input Command 3");
        commandBox.enterCommand("Temp User Input Command");

        commandBox.pressUpKey();
        assertEquals(commandBox.getCommandInput(), "User Input Command 3");
        commandBox.pressUpKey();
        assertEquals(commandBox.getCommandInput(), "User Input Command 2");
        commandBox.pressUpKey();
        assertEquals(commandBox.getCommandInput(), "User Input Command");
        commandBox.pressUpKey();
        assertEquals(commandBox.getCommandInput(), "User Input Command");
        commandBox.pressDownKey();
        assertEquals(commandBox.getCommandInput(), "User Input Command 2");
        commandBox.pressDownKey();
        assertEquals(commandBox.getCommandInput(), "User Input Command 3");
        commandBox.pressDownKey();
        assertEquals(commandBox.getCommandInput(), "Temp User Input Command");

    }
    
    @Test
    public void commandBox_cycleThroughTabPane() {
        commandBox.pressCtrlRightArrowKeys();
        assertTrue(commandBox.getRsvTaskListPanelHandle().isTabSelected());
        commandBox.pressCtrlRightArrowKeys();
        assertTrue(commandBox.getHelpPanelHandle().isTabSelected());
        commandBox.pressCtrlRightArrowKeys();
        assertTrue(commandBox.getOverviewPanelHandle().isTabSelected());
        commandBox.pressCtrlLeftArrowKeys();
        assertTrue(commandBox.getHelpPanelHandle().isTabSelected());
        commandBox.pressCtrlLeftArrowKeys();
        assertTrue(commandBox.getRsvTaskListPanelHandle().isTabSelected());      
    }
    
    @Test
    public void commandBox_textFieldValueChangesEvents_success() {
        commandBox.enterCommand("rsv");
        assertTrue(commandBox.getRsvTaskListPanelHandle().isTabSelected());
        commandBox.pressCtrlLeftArrowKeys();
        commandBox.enterCommand("confirm");
    }
    
    @Test
    public void commandBox_undoShortcut() {
        commandBox.pressCtrlZArrowKeys();
        assertEquals(resultDisplay.getText(), UndoCommand.MESSAGE_EMPTY_UNDO_CMD_HIST);
    }

    @Test
    public void commandBox_redoShortcut() {
        commandBox.pressCtrlYArrowKeys();
        assertEquals(resultDisplay.getText(), RedoCommand.MESSAGE_EMPTY_REDO_CMD_HIST);
    }

}
```
###### \java\guitests\ConfirmCommandTest.java
``` java
/**
 * GUI test for confirm command
 */
public class ConfirmCommandTest extends TarsGuiTest {

    @Test
    public void confirm() {
        TestTask[] currentTaskList = td.getTypicalTasks();
        TestRsvTask[] currentRsvTaskList = td.getTypicalRsvTasks();
        TestRsvTask rsvTaskToConfirm = td.rsvTaskA;
        TestTask confirmedTask = td.cfmTaskA;
        commandBox.runCommand("confirm 1 2 /p h");
        TestTask[] expectedTaskList =
                TestUtil.addTasksToList(currentTaskList, confirmedTask);
        TestRsvTask[] expectedRsvTaskList = TestUtil
                .delRsvTaskFromList(currentRsvTaskList, rsvTaskToConfirm);

        // confirm the new card contains the right data
        TaskCardHandle addedCard =
                taskListPanel.navigateToTask(confirmedTask.getName().taskName);
        assertMatching(confirmedTask, addedCard);

        // confirm that the rsv task list does not contain the confirmed task,
        // and that the task list contains the confirmed task
        assertTrue(taskListPanel.isListMatching(expectedTaskList));
        assertTrue(rsvTaskListPanel.isListMatching(expectedRsvTaskList));

    }

}
```
###### \java\guitests\EditCommandTest.java
``` java
/**
 * GUI test for edit command
 */
public class EditCommandTest extends TarsGuiTest {

    @Test
    public void edit() throws IllegalValueException {
        // Initialize Tars list
        TestTask[] currentList = td.getTypicalTasks();

        // Edit one task
        Name nameToEdit = new Name("Edited Task A");
        Priority priorityToEdit = new Priority("l");
        commandBox.runCommand("edit 1 /n Edited Task A /p l");
        int indexToEdit = 1;

        // confirm the list now contains the edited task
        TestTask[] expectedList = TestUtil.editTask(currentList,
                indexToEdit - 1, nameToEdit, priorityToEdit);
        assertTrue(taskListPanel.isListMatching(expectedList));

        // invalid command
        commandBox.runCommand("edit 1 Johnny");
        assertResultMessage(String.format(MESSAGE_INVALID_COMMAND_FORMAT,
                EditCommand.MESSAGE_USAGE));

        // invalid index
        commandBox.runCommand(
                "edit " + (currentList.length + 1) + " /n invalidIndex");
        assertResultMessage("The task index provided is invalid");
    }

}
```
###### \java\guitests\FindCommandTest.java
``` java
/**
 * GUI test for find command
 */
public class FindCommandTest extends TarsGuiTest {

    @Test
    public void find_quickSearch_nonEmptyList() {
        assertFindResultForQuickSearch("find Meeting"); // no results
        assertFindResultForQuickSearch("find Task B", td.taskB); // single result
        assertFindResultForQuickSearch("find Task", td.taskA, td.taskB,
                td.taskC, td.taskD, td.taskE, td.taskF, td.taskG); // multiple results

        // find after deleting one result
        commandBox.runCommand("del 1");
        assertFindResultForQuickSearch("find A");
    }

    @Test
    public void find_filterSearch_nonEmptyList() {
        assertFindResultForFilterSearch("find /n Task B", td.taskB); // single result

        // find after deleting one result
        commandBox.runCommand("del 1");
        assertFindResultForFilterSearch("find /n Task B"); // no results
    }

    @Test
    public void find_quickSearch_emptyList() {
        commandBox.runCommand("clear");
        assertFindResultForQuickSearch("find No Such Task"); // no results
    }

    @Test
    public void find_invalidCommand_fail() {
        commandBox.runCommand("findmeeting");
        assertResultMessage(Messages.MESSAGE_UNKNOWN_COMMAND);
    }

    private void assertFindResultForQuickSearch(String command,
            TestTask... expectedHits) {
        commandBox.runCommand(command);
        assertListSize(expectedHits.length);

        String[] keywordsArray = command.split("\\s+");
        ArrayList<String> keywordsList =
                new ArrayList<String>(Arrays.asList(keywordsArray));
        keywordsList.remove(0);

        assertResultMessage(expectedHits.length + " tasks listed!\n"
                + "Quick Search Keywords: " + keywordsList.toString());
        assertTrue(taskListPanel.isListMatching(expectedHits));
    }

    private void assertFindResultForFilterSearch(String command,
            TestTask... expectedHits) {
        commandBox.runCommand(command);
        assertListSize(expectedHits.length);

        String keywordString = "[Task Name: Task B] ";

        assertResultMessage(expectedHits.length + " tasks listed!\n"
                + "Filter Search Keywords: " + keywordString);
        assertTrue(taskListPanel.isListMatching(expectedHits));
    }
}
```
###### \java\guitests\guihandles\ThisWeekPanelHandle.java
``` java
/**
 * GUI test for this week panel
 */
public class ThisWeekPanelHandle extends GuiHandle {

    private static final String TAB_PANEL_ROOT_FIELD_ID = "#tabPane";

    public ThisWeekPanelHandle(GuiRobot guiRobot, Stage primaryStage) {
        super(guiRobot, primaryStage, TestApp.APP_TITLE);
    }

    public boolean isTabSelected() {
        return ((TabPane) getNode(TAB_PANEL_ROOT_FIELD_ID)).getSelectionModel()
                .isSelected(MainWindow.OVERVIEW_PANEL_TAB_PANE_INDEX);
    }

}
```
###### \java\guitests\HelpPanelTest.java
``` java
/**
 * GUI test for help command
 */
public class HelpPanelTest extends TarsGuiTest {

    @Test
    public void openHelpPanel() {
        assertHelpPanelSelected(commandBox.runHelpCommand());
    }

    private void assertHelpPanelSelected(HelpPanelHandle helpPanelHandle) {
        assertTrue(helpPanelHandle.isTabSelected());
    }
}
```
###### \java\guitests\RsvCommandTest.java
``` java
/**
 * GUI test for rsv command
 */
public class RsvCommandTest extends TarsGuiTest {

    @Test
    public void rsv() {
        // reserve one task
        TestRsvTask[] currentList = td.getTypicalRsvTasks();
        TestRsvTask taskToRsv = td.rsvTaskC;
        assertRsvSuccess(taskToRsv, currentList);
        currentList = TestUtil.addRsvTasksToList(currentList, taskToRsv);

        // reserve another task
        taskToRsv = td.rsvTaskD;
        assertRsvSuccess(taskToRsv, currentList);
        currentList = TestUtil.addRsvTasksToList(currentList, taskToRsv);

        // add duplicate task
        commandBox.runCommand(td.rsvTaskD.getRsvCommand());
        assertResultMessage(Messages.MESSAGE_DUPLICATE_TASK);
        assertTrue(rsvTaskListPanel.isListMatching(currentList));

        // delete a reserved task
        TestRsvTask rsvTaskToDel = td.rsvTaskC;
        commandBox.runCommand("rsv /del 3");
        TestRsvTask[] expectedList = TestUtil.delRsvTaskFromList(currentList, rsvTaskToDel);
        assertTrue(rsvTaskListPanel.isListMatching(expectedList));
        currentList = TestUtil.delRsvTaskFromList(currentList, taskToRsv);

        // add to empty list
        commandBox.runCommand("clear");
        assertRsvSuccess(td.rsvTaskA);

        // invalid command

        commandBox.runCommand("reserves Meeting");
        assertResultMessage(Messages.MESSAGE_UNKNOWN_COMMAND);

    }

    private void assertRsvSuccess(TestRsvTask taskToRsv, TestRsvTask... currentList) {
        commandBox.runCommand(taskToRsv.getRsvCommand());

        // confirm the new card contains the right data
        RsvTaskCardHandle addedCard = rsvTaskListPanel.navigateToRsvTask(taskToRsv.getName().taskName);
        assertMatching(taskToRsv, addedCard);

        // confirm the list now contains all previous tasks plus the new task
        TestRsvTask[] expectedList = TestUtil.addRsvTasksToList(currentList, taskToRsv);
        assertTrue(rsvTaskListPanel.isListMatching(expectedList));
    }

}
```
###### \java\tars\commons\util\DateTimeUtilTest.java
``` java
    @Test
    public void isDateTimeWithinRange_emptyDateTimeSource() throws Exception {
        DateTime dateTimeSource =
                new DateTime(StringUtil.EMPTY_STRING, StringUtil.EMPTY_STRING);
        DateTime dateTimeQuery =
                new DateTime("17/01/2016 1200", "18/01/2016 1200");
        assertFalse(DateTimeUtil.isDateTimeWithinRange(dateTimeSource,
                dateTimeQuery));
    }

    @Test
    public void isDateTimeWithinRange_dateTimeOutOfRange() throws Exception {
        DateTime dateTimeSource =
                new DateTime("15/01/2016 1200", "16/01/2016 1200");
        DateTime dateTimeSource2 =
                new DateTime("19/01/2016 1200", "20/01/2016 1200");
        DateTime dateTimeQuery =
                new DateTime("17/01/2016 1200", "18/01/2016 1200");

        assertFalse(DateTimeUtil.isDateTimeWithinRange(dateTimeSource,
                dateTimeQuery));
        assertFalse(DateTimeUtil.isDateTimeWithinRange(dateTimeSource2,
                dateTimeQuery));
    }

    @Test
    public void isDateTimeWithinRange_dateTimeWithinRange() throws Exception {
        DateTime dateTimeSource =
                new DateTime("14/01/2016 1200", "16/01/2016 1200");
        DateTime dateTimeQueryFullyInRange =
                new DateTime("14/01/2016 2000", "15/01/2016 1200");
        DateTime dateTimeQueryPartiallyInRange =
                new DateTime("13/01/2016 1000", "15/01/2016 1200");

        assertTrue(DateTimeUtil.isDateTimeWithinRange(dateTimeSource,
                dateTimeQueryFullyInRange));
        assertTrue(DateTimeUtil.isDateTimeWithinRange(dateTimeSource,
                dateTimeQueryPartiallyInRange));
    }

    @Test
    public void isDateTimeWithinRange_dateTimeWithoutStartDate()
            throws Exception {
        DateTime dateTimeSource =
                new DateTime("15/01/2016 1200", "17/01/2016 1100");
        DateTime dateTimeSourceWithoutStartDate =
                new DateTime("", "16/01/2016 1200");
        DateTime dateTimeQuery =
                new DateTime("14/01/2016 2000", "17/01/2016 1200");
        DateTime dateTimeQueryWithoutStartDate =
                new DateTime("", "16/01/2016 1200");
        DateTime dateTimeQueryWithoutStartDate2 =
                new DateTime("", "18/01/2016 1200");

        assertTrue(DateTimeUtil.isDateTimeWithinRange(dateTimeSource,
                dateTimeQuery));
        assertFalse(DateTimeUtil.isDateTimeWithinRange(dateTimeSource,
                dateTimeQueryWithoutStartDate2));
        assertTrue(DateTimeUtil.isDateTimeWithinRange(
                dateTimeSourceWithoutStartDate, dateTimeQuery));
        assertTrue(DateTimeUtil.isDateTimeWithinRange(
                dateTimeSourceWithoutStartDate, dateTimeQueryWithoutStartDate));
        assertFalse(DateTimeUtil.isDateTimeWithinRange(
                dateTimeSourceWithoutStartDate,
                dateTimeQueryWithoutStartDate2));
    }

    @Test
    public void isDateTimeConflicting_dateTimeConflicts() throws Exception {
        DateTime dateTimeSource =
                new DateTime("14/01/2016 1200", "16/01/2016 1200");
        DateTime conflictingDateTimeQuery =
                new DateTime("14/01/2016 2000", "15/01/2016 1200");
        DateTime conflictingDateTimeQuery2 =
                new DateTime("13/01/2016 1000", "15/01/2016 1200");

        assertTrue(DateTimeUtil.isDateTimeConflicting(dateTimeSource,
                conflictingDateTimeQuery));
        assertTrue(DateTimeUtil.isDateTimeConflicting(dateTimeSource,
                conflictingDateTimeQuery2));
    }

    @Test
    public void isDateTimeConflicting_dateTimeNotConflicting()
            throws Exception {
        DateTime dateTimeSource =
                new DateTime("14/01/2016 1200", "16/01/2016 1200");
        DateTime dateTimeQueryOutOfRange =
                new DateTime("18/01/2016 2000", "19/01/2016 1200");
        DateTime dateTimeAdjacent =
                new DateTime("13/01/2016 1000", "14/01/2016 1200");

        assertFalse(DateTimeUtil.isDateTimeConflicting(dateTimeSource,
                dateTimeQueryOutOfRange));
        assertFalse(DateTimeUtil.isDateTimeConflicting(dateTimeSource,
                dateTimeAdjacent));
    }

    @Test
    public void getListOfFreeTimeSlotsInDate_success()
            throws DateTimeException, IllegalDateException {
        ArrayList<DateTime> listOfFilledTimeSlots = new ArrayList<DateTime>();
        DateTime dateToCheck =
                new DateTime("29/10/2016 0000", "29/10/2016 2359");
        ArrayList<DateTime> currentList = new ArrayList<DateTime>();
        ArrayList<DateTime> expectedList = new ArrayList<DateTime>();

        // Initialize listOfFilledTimeSlots
        listOfFilledTimeSlots
                .add(new DateTime("27/10/2016 1200", "29/10/2016 0830"));
        listOfFilledTimeSlots
                .add(new DateTime("29/10/2016 0500", "29/10/2016 0630"));
        listOfFilledTimeSlots
                .add(new DateTime("29/10/2016 0730", "29/10/2016 0900"));
        listOfFilledTimeSlots.add(new DateTime("", "29/10/2016 1300"));
        listOfFilledTimeSlots
                .add(new DateTime("29/10/2016 1400", "29/10/2016 1500"));
        listOfFilledTimeSlots
                .add(new DateTime("29/10/2016 2330", "30/10/2016 0100"));

        // Initialize expectedList
        expectedList.add(new DateTime("29/10/2016 0900", "29/10/2016 1400"));
        expectedList.add(new DateTime("29/10/2016 1500", "29/10/2016 2330"));

        currentList = DateTimeUtil.getListOfFreeTimeSlotsInDate(dateToCheck,
                listOfFilledTimeSlots);

        assertEquals(expectedList, currentList);
    }

    @Test
    public void getDurationInMinutesBetweenTwoLocalDateTime_success() {
        LocalDateTime ldt1 = LocalDateTime.of(2016, 10, 29, 9, 36);
        LocalDateTime ldt2 = LocalDateTime.of(2016, 10, 29, 14, 28);

        assertEquals(
                DateTimeUtil.getDurationBetweenTwoLocalDateTime(ldt1, ldt2),
                "4 hr 52 min");
    }

}
```
###### \java\tars\logic\CdLogicCommandTest.java
``` java
/**
 * Logic command test for cd
 */
public class CdLogicCommandTest extends LogicCommandTest {
    @Test
    public void execute_cd_incorrectArgsFormatErrorMessageShown()
            throws Exception {
        assertCommandBehavior("cd ", CdCommand.MESSAGE_INVALID_FILEPATH);
    }

    @Test
    public void execute_cd_invalidFileTypeErrorMessageShown() throws Exception {
        assertCommandBehavior("cd invalidFileType",
                CdCommand.MESSAGE_INVALID_FILEPATH);
    }

    @Test
    public void execute_cd_new_file_success() throws Exception {
        String tempTestTarsFilePath =
                saveFolder.getRoot().getPath() + "TempTestTars.xml";
        assertCommandBehavior("cd " + tempTestTarsFilePath, String.format(
                CdCommand.MESSAGE_SUCCESS_NEW_FILE, tempTestTarsFilePath));
    }

    @Test
    public void execute_cd_existing_file_failureToReadExistingFile()
            throws Exception {
        String existingFilePath =
                saveFolder.getRoot().getPath() + "TempTars.xml";
        File existingFile = new File(existingFilePath);
        FileUtil.createIfMissing(existingFile);
        assertCommandBehavior("cd " + existingFilePath,
                CdCommand.MESSAGE_FAILURE_READ_FILE);
    }

    @Test
    public void execute_cd_existing_file_success() throws Exception {
        String existingFilePath =
                saveFolder.getRoot().getPath() + "TempTars.xml";
        TarsStorage testStorage = new XmlTarsStorage(existingFilePath);
        testStorage.saveTars(Tars.getEmptyTars());
        assertCommandBehavior("cd " + existingFilePath, String.format(
                CdCommand.MESSAGE_SUCCESS_EXISTING_FILE, existingFilePath));
    }
}
```
###### \java\tars\logic\ConfirmLogicCommandTest.java
``` java
/**
 * Logic command test for confirm
 */
public class ConfirmLogicCommandTest extends LogicCommandTest {
    @Test
    public void execute_confirm_invalidArgsFormatErrorMessageShown()
            throws Exception {

        String expectedMessage = String.format(MESSAGE_INVALID_COMMAND_FORMAT,
                ConfirmCommand.MESSAGE_USAGE);
        assertCommandBehavior("confirm ", expectedMessage);
        assertCommandBehavior("confirm /p h 1 2", expectedMessage);
        assertCommandBehavior("confirm 1 1 -dt invalidFlag", expectedMessage);
        assertCommandBehavior("confirm 1 1 3", expectedMessage);
    }

    @Test
    public void execute_confirm_invalidRsvTaskIndex_ErrorMessageShown()
            throws Exception {
        assertCommandBehavior("confirm 2 3",
                MESSAGE_INVALID_RSV_TASK_DISPLAYED_INDEX);
    }

    @Test
    public void execute_confirm_invalidRsvTaskDateTimeIndex_ErrorMessageShown()
            throws Exception {
        TypicalTestDataHelper helper = new TypicalTestDataHelper();
        Tars expectedTars = new Tars();
        RsvTask rsvTask =
                helper.generateReservedTaskWithOneDateTimeOnly("Test Task");
        expectedTars.addRsvTask(rsvTask);
        model.addRsvTask(rsvTask);

        assertCommandBehavior("confirm 1 3",
                Messages.MESSAGE_INVALID_DATETIME_DISPLAYED_INDEX, expectedTars,
                expectedTars.getTaskList());
    }

    @Test
    public void execute_confirm_success() throws Exception {
        TypicalTestDataHelper helper = new TypicalTestDataHelper();

        // Create added task
        Task addedTask = helper.generateTaskWithName("Test Task");

        // Create end state taskList with one confirmed task
        List<Task> taskList = new ArrayList<Task>();
        taskList.add(addedTask);

        // Create Empty end state rsvTaskList
        List<RsvTask> rsvTaskList = new ArrayList<RsvTask>();

        RsvTask rsvTask =
                helper.generateReservedTaskWithOneDateTimeOnly("Test Task");

        Tars expectedTars = new Tars();
        expectedTars.addTask(addedTask);

        // Set Tars start state to 1 reserved task, and 0 tasks.
        model.resetData(new Tars());
        model.addRsvTask(rsvTask);

        String expectedMessage = String
                .format(ConfirmCommand.MESSAGE_CONFIRM_SUCCESS, addedTask);
        assertCommandBehaviorWithRsvTaskList("confirm 1 1 /p h /t tag",
                expectedMessage, expectedTars, taskList, rsvTaskList);

    }

```
###### \java\tars\logic\EditLogicCommandTest.java
``` java
/**
 * Logic command test for edit
 */
public class EditLogicCommandTest extends LogicCommandTest {

    @Test
    public void execute_edit_invalidArgsFormatErrorMessageShown()
            throws Exception {
        String expectedMessage = String.format(MESSAGE_INVALID_COMMAND_FORMAT,
                EditCommand.MESSAGE_USAGE);

        assertInvalidInputBehaviorForEditCommand("edit ", expectedMessage);
        assertInvalidInputBehaviorForEditCommand(
                "edit 1 -invalidFlag invalidArg", expectedMessage);
    }

    @Test
    public void execute_edit_indexNotFoundErrorMessageShown() throws Exception {
        assertIndexNotFoundBehaviorForCommand("edit");
    }

    @Test
    public void execute_edit_invalidTaskData() throws Exception {
        assertInvalidInputBehaviorForEditCommand("edit 1 /n []\\[;]",
                Name.MESSAGE_NAME_CONSTRAINTS);
        assertInvalidInputBehaviorForEditCommand(
                "edit 1 /dt @@@notAValidDate@@@", MESSAGE_INVALID_DATE);
        assertInvalidInputBehaviorForEditCommand("edit 1 /p medium",
                Priority.MESSAGE_PRIORITY_CONSTRAINTS);
        assertInvalidInputBehaviorForEditCommand(
                "edit 1 /n validName /dt invalidDate", MESSAGE_INVALID_DATE);
        assertInvalidInputBehaviorForEditCommand("edit 1 /tr $#$",
                Tag.MESSAGE_TAG_CONSTRAINTS);
    }

    @Test
    public void execute_edit_editedCorrectTask() throws Exception {
        // setup expectations
        TypicalTestDataHelper helper = new TypicalTestDataHelper();
        Task taskToAdd = helper.meetAdam();
        model.addTask(taskToAdd);
        Tars expectedTars = prepareExpectedTars();

        String inputCommand = "edit 1 /n Meet Betty Green /dt 20/09/2016 1800 "
                + "to 21/09/2016 1800 /p h /tr tag2 /ta tag3";

        // execute command and verify result
        assertCommandBehavior(inputCommand,
                String.format(EditCommand.MESSAGE_EDIT_TASK_SUCCESS,
                        expectedTars.getTaskList().get(0)),
                expectedTars, expectedTars.getTaskList());
    }

    @Test
    public void execute_edit_editedDuplicateTask() throws Exception {
        // setup expectations
        TypicalTestDataHelper helper = new TypicalTestDataHelper();
        Task taskToAdd = helper.meetAdam();
        model.addTask(taskToAdd);
        Tars expectedTars = new Tars();
        expectedTars.addTask(taskToAdd);

        String inputCommand = "edit 1 /n Meet Adam Brown";

        // execute command and verify result
        assertCommandBehavior(inputCommand,
                new DuplicateTaskException().getMessage().toString(),
                expectedTars, expectedTars.getTaskList());
    }

    private void assertInvalidInputBehaviorForEditCommand(String inputCommand,
            String expectedMessage) throws Exception {
        TypicalTestDataHelper helper = new TypicalTestDataHelper();
        List<Task> taskList = helper.generateTaskList(2);

        // set Tars state to 2 tasks
        model.resetData(new Tars());
        for (Task p : taskList) {
            model.addTask(p);
        }

        assertCommandBehavior(inputCommand, expectedMessage, model.getTars(),
                taskList);
    }

```
###### \java\tars\logic\FindLogicCommandTest.java
``` java
/**
 * Logic command test for find
 */
public class FindLogicCommandTest extends LogicCommandTest {

    @Test
    public void execute_find_invalidArgsFormat() throws Exception {
        String expectedMessage = String.format(MESSAGE_INVALID_COMMAND_FORMAT,
                FindCommand.MESSAGE_USAGE);
        assertCommandBehavior("find ", expectedMessage);
    }

    @Test
    public void execute_find_quickSearchOnlyMatchesFullWordsInNames()
            throws Exception {
        TypicalTestDataHelper helper = new TypicalTestDataHelper();
        Task pTarget1 = helper.generateTaskWithName("bla bla KEY bla");
        Task pTarget2 = helper.generateTaskWithName("bla KEY bla bceofeia");
        Task p1 = helper.generateTaskWithName("KE Y");
        Task p2 = helper.generateTaskWithName("KEYKEYKEY sduauo");

        List<Task> fourTasks =
                helper.generateTaskList(p1, pTarget1, p2, pTarget2);
        Tars expectedTars = helper.generateTars(fourTasks);
        List<Task> expectedList = helper.generateTaskList(pTarget1, pTarget2);
        helper.addToModel(model, fourTasks);

        String searchKeywords = "\nQuick Search Keywords: [KEY]";

        assertCommandBehavior("find KEY",
                Command.getMessageForTaskListShownSummary(expectedList.size())
                        + searchKeywords,
                expectedTars, expectedList);
    }

    @Test
    public void execute_find_quickSearchIsNotCaseSensitive() throws Exception {
        TypicalTestDataHelper helper = new TypicalTestDataHelper();
        Task p1 = helper.generateTaskWithName("bla bla KEY bla");
        Task p2 = helper.generateTaskWithName("bla KEY bla bceofeia");
        Task p3 = helper.generateTaskWithName("key key");
        Task p4 = helper.generateTaskWithName("KEy sduauo");

        List<Task> fourTasks = helper.generateTaskList(p3, p1, p4, p2);
        Tars expectedTars = helper.generateTars(fourTasks);
        List<Task> expectedList = fourTasks;
        helper.addToModel(model, fourTasks);

        String searchKeywords = "\nQuick Search Keywords: [KEY]";

        assertCommandBehavior("find KEY",
                Command.getMessageForTaskListShownSummary(expectedList.size())
                        + searchKeywords,
                expectedTars, expectedList);
    }

    @Test
    public void execute_find_quickSearchMatchesIfAllKeywordPresent()
            throws Exception {
        TypicalTestDataHelper helper = new TypicalTestDataHelper();
        Task p1 = helper.generateTaskWithName("bla bla KEY bla");
        Task p2 = helper.generateTaskWithName("bla rAnDoM bla bceofeia");
        Task p3 = helper.generateTaskWithName("sduauo");
        Task pTarget1 = helper.generateTaskWithName("key key rAnDoM");

        List<Task> fourTasks = helper.generateTaskList(p1, p2, p3, pTarget1);
        Tars expectedTars = helper.generateTars(fourTasks);
        List<Task> expectedList = helper.generateTaskList(pTarget1);
        helper.addToModel(model, fourTasks);

        String searchKeywords = "\nQuick Search Keywords: [key, rAnDoM]";

        assertCommandBehavior("find key rAnDoM",
                Command.getMessageForTaskListShownSummary(expectedList.size())
                        + searchKeywords,
                expectedTars, expectedList);
    }

    @Test
    public void execute_find_filterSearchMatchesIfAllKeywordPresent()
            throws Exception {
        TypicalTestDataHelper helper = new TypicalTestDataHelper();
        Task pTarget1 = helper.meetAdam();
        Task p1 = helper.generateTask(2);
        Task p2 = helper.generateTask(3);

        List<Task> threeTasks = helper.generateTaskList(pTarget1, p1, p2);
        Tars expectedTars = helper.generateTars(threeTasks);
        List<Task> expectedList = helper.generateTaskList(pTarget1);
        helper.addToModel(model, threeTasks);

        String searchKeywords = "\nFilter Search Keywords: [Task Name: adam] "
                + "[DateTime: 01/09/2016 1400 to 01/09/2016 1500] [Priority: medium] "
                + "[Status: Undone] [Tags: tag1]";

        assertCommandBehavior(
                "find /n adam /dt 01/09/2016 1400 to 01/09/2016 1500 /p medium /ud /t tag1",
                Command.getMessageForTaskListShownSummary(expectedList.size())
                        + searchKeywords,
                expectedTars, expectedList);
    }

    @Test
    public void execute_find_filterSearchWithoutDateTimeQuery()
            throws Exception {
        TypicalTestDataHelper helper = new TypicalTestDataHelper();
        Task pTarget1 = helper.meetAdam();
        Task p1 = helper.generateTask(2);
        Task p2 = helper.generateTask(3);

        List<Task> threeTasks = helper.generateTaskList(pTarget1, p1, p2);
        Tars expectedTars = helper.generateTars(threeTasks);
        List<Task> expectedList = helper.generateTaskList(pTarget1);
        helper.addToModel(model, threeTasks);

        String searchKeywords = "\nFilter Search Keywords: [Task Name: adam] "
                + "[Priority: medium] " + "[Status: Undone] [Tags: tag1]";

        assertCommandBehavior("find /n adam /p medium /ud /t tag1",
                Command.getMessageForTaskListShownSummary(expectedList.size())
                        + searchKeywords,
                expectedTars, expectedList);
    }

    @Test
    public void execute_find_filterSearchSingleDateTimeQuery()
            throws Exception {
        TypicalTestDataHelper helper = new TypicalTestDataHelper();
        Task pTarget1 = helper.meetAdam();
        Task p1 = helper.generateTask(2);
        Task p2 = helper.generateTask(3);

        List<Task> threeTasks = helper.generateTaskList(pTarget1, p1, p2);
        Tars expectedTars = helper.generateTars(threeTasks);
        List<Task> expectedList = helper.generateTaskList(pTarget1);
        helper.addToModel(model, threeTasks);

        String searchKeywords =
                "\nFilter Search Keywords: [DateTime: 01/09/2016 1400] ";

        assertCommandBehavior("find /dt 01/09/2016 1400",
                Command.getMessageForTaskListShownSummary(expectedList.size())
                        + searchKeywords,
                expectedTars, expectedList);
    }

    @Test
    public void execute_find_filterSearchTaskNotFound() throws Exception {
        TypicalTestDataHelper helper = new TypicalTestDataHelper();
        Task pTarget1 = helper.meetAdam();
        Task p1 = helper.generateTask(2);
        Task p2 = helper.generateTask(3);

        List<Task> threeTasks = helper.generateTaskList(pTarget1, p1, p2);
        Tars expectedTars = helper.generateTars(threeTasks);
        List<Task> expectedList = helper.generateTaskList();
        helper.addToModel(model, threeTasks);

        String searchKeywords =
                "\nFilter Search Keywords: [DateTime: 01/09/2010 1400] ";

        assertCommandBehavior("find /dt 01/09/2010 1400",
                Command.getMessageForTaskListShownSummary(expectedList.size())
                        + searchKeywords,
                expectedTars, expectedList);
    }

    @Test
    public void execute_find_filterSearchBothDoneAndUndoneSearched()
            throws Exception {

        assertCommandBehavior("find /do /ud",
                TaskQuery.MESSAGE_BOTH_STATUS_SEARCHED_ERROR);
    }

    @Test
    public void execute_find_filterSearchMultipleFlagsUsed() throws Exception {
        TypicalTestDataHelper helper = new TypicalTestDataHelper();
        Task pTarget1 = helper.meetAdam();
        Task p1 = helper.generateTask(2);
        Task p2 = helper.generateTask(3);

        List<Task> threeTasks = helper.generateTaskList(pTarget1, p1, p2);
        Tars expectedTars = helper.generateTars(threeTasks);
        List<Task> expectedList = helper.generateTaskList(pTarget1);
        helper.addToModel(model, threeTasks);

        String searchKeywords =
                "\nFilter Search Keywords: [Task Name: meet adam] "
                        + "[Priority: medium] "
                        + "[Status: Undone] [Tags: tag2 tag1]";

        assertCommandBehavior("find /n meet adam /p medium /ud /t tag1 /t tag2",
                Command.getMessageForTaskListShownSummary(expectedList.size())
                        + searchKeywords,
                expectedTars, expectedList);
    }
}
```
###### \java\tars\logic\FreeLogicCommandTest.java
``` java
/**
 * Logic command test for free
 */
public class FreeLogicCommandTest extends LogicCommandTest {
    @Test
    public void execute_free_incorrectArgsFormat_errorMessageShown()
            throws Exception {
        assertCommandBehavior("free ", String.format(
                MESSAGE_INVALID_COMMAND_FORMAT, FreeCommand.MESSAGE_USAGE));
        assertCommandBehavior("free invalidargs", String.format(
                MESSAGE_INVALID_COMMAND_FORMAT, FreeCommand.MESSAGE_USAGE));
        assertCommandBehavior("free 29/10/2016 to 30/10/2016",
                FreeCommand.MESSAGE_DATE_RANGE_DETECTED);
    }

    @Test
    public void execute_free_noFreeTimeSlotResult() throws Exception {
        TypicalTestDataHelper helper = new TypicalTestDataHelper();
        Tars expectedTars = helper.fillModelAndTarsForFreeCommand(model);

        Task task4 = helper.generateTaskWithNameAndDate("Task 4",
                new DateTime("10/10/2016 1500", "12/10/2016 1400"));
        List<Task> expectedShownTaskList = helper.generateTaskList(task4);

        assertCommandBehavior("free 11/10/2016",
                String.format(FreeCommand.MESSAGE_NO_FREE_TIMESLOTS,
                        "Tuesday, 11/10/2016"),
                expectedTars, expectedShownTaskList);

        // Case where the user types in a time should still be allowed to pass. Programme will
        // extract the date
        assertCommandBehavior("free 11/10/2016 0900",
                String.format(FreeCommand.MESSAGE_NO_FREE_TIMESLOTS,
                        "Tuesday, 11/10/2016"),
                expectedTars, expectedShownTaskList);
    }

    @Test
    public void execute_free_freeDayResult() throws Exception {
        TypicalTestDataHelper helper = new TypicalTestDataHelper();
        Tars expectedTars = helper.fillModelAndTarsForFreeCommand(model);

        // Create expected empty list
        List<Task> expectedShownTaskList = helper.generateTaskList();

        assertCommandBehavior("free 01/11/2016",
                String.format(FreeCommand.MESSAGE_FREE_DAY,
                        "Tuesday, 01/11/2016"),
                expectedTars, expectedShownTaskList);
    }

    @Test
    public void execute_free_freeTimeSlotsFound() throws Exception {
        TypicalTestDataHelper helper = new TypicalTestDataHelper();
        Tars expectedTars = helper.fillModelAndTarsForFreeCommand(model);


        // Fill up expected shown task list
        Task taskWithoutStartDate = helper.generateTaskWithNameAndDate(
                "Task without startdate", new DateTime("", "29/10/2016 1500"));
        Task task1 = helper.generateTaskWithNameAndDate("Task 1",
                new DateTime("28/10/2016 2200", "29/10/2016 0100"));
        Task task2 = helper.generateTaskWithNameAndDate("Task 2",
                new DateTime("29/10/2016 1430", "29/10/2016 1800"));
        List<Task> expectedShownTaskList =
                helper.generateTaskList(taskWithoutStartDate, task1, task2);

        StringBuilder sb = new StringBuilder();

        sb.append("Saturday, 29/10/2016").append(": \n")
                .append("1. 0100hrs to 1400hrs (13 hr 0 min)\n")
                .append("2. 1800hrs to 2359hrs (5 hr 59 min)");

        assertCommandBehavior("free 29/10/2016",
                String.format(FreeCommand.MESSAGE_SUCCESS, sb.toString()),
                expectedTars, expectedShownTaskList);
    }
}
```
###### \java\tars\logic\RsvLogicCommandTest.java
``` java
/**
 * Logic command test for rsv
 */
public class RsvLogicCommandTest extends LogicCommandTest {

    @Test
    public void execute_rsvInvalidArgsFormatErrorMessageShown()
            throws Exception {

        String expectedMessage = String.format(MESSAGE_INVALID_COMMAND_FORMAT,
                RsvCommand.MESSAGE_USAGE);
        assertCommandBehavior("rsv ", expectedMessage);
    }

    @Test
    public void execute_rsvAddInvalidArgsFormatErrorMessageShown()
            throws Exception {
        String expectedMessageForNullDate =
                String.format(MESSAGE_INVALID_COMMAND_FORMAT,
                        RsvCommand.MESSAGE_DATETIME_NOT_FOUND);
        String expectedMessage = String.format(MESSAGE_INVALID_COMMAND_FORMAT,
                RsvCommand.MESSAGE_USAGE);
        assertCommandBehavior("rsv Rsv Task Without Date",
                expectedMessageForNullDate);
        assertCommandBehavior("rsv Rsv Task with flags other than date -p h",
                expectedMessageForNullDate);
        assertCommandBehavior("rsv /dt tomorrow", expectedMessage);
        assertCommandBehavior("rsv Rsv Task with invalid Date /dt invalidDate",
                MESSAGE_INVALID_DATE);
    }

    @Test
    public void execute_rsvDelInvalidArgsFormatErrorMessageShown()
            throws Exception {
        String expectedMessage = String.format(MESSAGE_INVALID_COMMAND_FORMAT,
                RsvCommand.MESSAGE_USAGE_DEL);
        assertCommandBehavior("rsv invalidArgs /del 1", expectedMessage);
        assertCommandBehavior("rsv /del invalidValue", expectedMessage);
    }

    @Test
    public void execute_rsv_del_successful() throws Exception {
        TypicalTestDataHelper helper = new TypicalTestDataHelper();

        // Create a reserved task
        RsvTask rsvTask =
                helper.generateReservedTaskWithOneDateTimeOnly("Test Task");

        // Create empty taskList
        List<Task> taskList = new ArrayList<Task>();

        // Create empty end state rsvTaskList
        List<RsvTask> rsvTaskList = new ArrayList<RsvTask>();

        // Create empty end state Tars
        Tars expectedTars = new Tars();

        // Set Tars start state to 1 reserved task, and 0 tasks.
        model.resetData(new Tars());
        model.addRsvTask(rsvTask);

        String expectedMessage = String.format(RsvCommand.MESSAGE_SUCCESS_DEL,
                "1.\t" + rsvTask + "\n");
        assertCommandBehaviorWithRsvTaskList("rsv /del 1", expectedMessage,
                expectedTars, taskList, rsvTaskList);
    }

    @Test
    public void execute_rsv_conflictingTaskShowWarning() throws Exception {
        TypicalTestDataHelper helper = new TypicalTestDataHelper();
        RsvTask rsvTaskA =
                helper.generateReservedTaskWithNameAndDate("Rsv Task A",
                        new DateTime("14/10/2016 0900", "16/10/2016 0900"));
        RsvTask taskToRsv =
                helper.generateReservedTaskWithNameAndDate("Task To Rsv",
                        new DateTime("13/10/2016 1000", "15/10/2016 1000"));

        // Create empty taskList
        List<Task> taskList = new ArrayList<Task>();

        List<RsvTask> rsvTaskList = new ArrayList<RsvTask>();
        rsvTaskList.add(rsvTaskA);
        rsvTaskList.add(taskToRsv);

        Tars expectedTars = new Tars();
        String expectedMessage =
                String.format(RsvCommand.MESSAGE_SUCCESS, taskToRsv.toString())
                        + "\n" + MESSAGE_CONFLICTING_TASKS_WARNING
                        + "\nConflicts for "
                        + taskToRsv.getDateTimeList().get(0).toString() + ": "
                        + "\nRsvTask 1: " + rsvTaskA.toString();

        expectedTars.addRsvTask(rsvTaskA);
        expectedTars.addRsvTask(taskToRsv);

        model.resetData(new Tars());
        model.addRsvTask(rsvTaskA);

        assertCommandBehaviorWithRsvTaskList(
                "rsv Task To Rsv /dt 13/10/2016 1000 to 15/10/2016 1000",
                expectedMessage, expectedTars, taskList, rsvTaskList);

    }

```
###### \java\tars\logic\TypicalTestDataHelper.java
``` java
     */
    protected Task generateTaskWithNameAndDate(String name, DateTime dateTime) throws Exception {
        assert (dateTime != null && name != null);
        return new Task(new Name(name), dateTime, new Priority("h"), new Status(false),
                new UniqueTagList(new Tag("tag")));
    }

    /**
     * Generates a RsvTask object with given name and datetime(s)
     */
    protected RsvTask generateReservedTaskWithNameAndDate(String name, DateTime... dateTimes) throws Exception {
        ArrayList<DateTime> dateTimeList = new ArrayList<DateTime>();
        for (DateTime dt : dateTimes) {
            dateTimeList.add(dt);
        }
        return new RsvTask(new Name(name), dateTimeList);
    }

    /**
     * Generates a RsvTask object with given name and a dummy dateTime
     */
    protected RsvTask generateReservedTaskWithOneDateTimeOnly(String name) throws Exception {
        ArrayList<DateTime> dateTimeList = new ArrayList<DateTime>();
        dateTimeList.add(new DateTime("05/09/2016 1400", "06/09/2016 2200"));
        return new RsvTask(new Name(name), dateTimeList);
    }

    protected Tars fillModelAndTarsForFreeCommand(Model model) throws Exception {
        RsvTask rsvTask1 = generateReservedTaskWithNameAndDate("rsvTask1",
                new DateTime("29/10/2016 1400", "29/10/2016 1500"),
                new DateTime("30/10/2016 1400", "30/10/2016 1500"));
        RsvTask rsvTask2 = generateReservedTaskWithNameAndDate("rsvTask2",
                new DateTime("28/10/2016 0900", "28/10/2016 1400"));
        Task floatingTask = generateTaskWithNameAndDate("Floating Task", new DateTime("", ""));
        Task taskWithoutStartDate = generateTaskWithNameAndDate("Task without startdate",
                new DateTime("", "29/10/2016 1500"));
        Task task1 = generateTaskWithNameAndDate("Task 1", new DateTime("28/10/2016 2200", "29/10/2016 0100"));
        Task task2 = generateTaskWithNameAndDate("Task 2", new DateTime("29/10/2016 1430", "29/10/2016 1800"));
        Task task3 = generateTaskWithNameAndDate("Task 3", new DateTime("01/10/2016 1400", "01/10/2016 1500"));
        Task task4 = generateTaskWithNameAndDate("Task 4", new DateTime("10/10/2016 1500", "12/10/2016 1400"));
        
        Tars tars = new Tars();
        tars.addRsvTask(rsvTask1);
        tars.addRsvTask(rsvTask2);
        tars.addTask(floatingTask);
        tars.addTask(taskWithoutStartDate);
        tars.addTask(task1);
        tars.addTask(task2);
        tars.addTask(task3);
        tars.addTask(task4);

        model.addRsvTask(rsvTask1);
        model.addRsvTask(rsvTask2);
        model.addTask(floatingTask);
        model.addTask(taskWithoutStartDate);
        model.addTask(task1);
        model.addTask(task2);
        model.addTask(task3);
        model.addTask(task4);

        return tars;
    }
}
```
###### \java\tars\testutil\RsvTaskBuilder.java
``` java
/**
 * A utility class to help with building reserve task objects.
 */
public class RsvTaskBuilder {

    private TestRsvTask rsvTask;

    public RsvTaskBuilder() {
        this.rsvTask = new TestRsvTask();
    }

    public RsvTaskBuilder withName(String name) throws IllegalValueException {
        this.rsvTask.setName(new Name(name));
        return this;
    }

    public RsvTaskBuilder withDateTime(String dateTime1, String dateTime2)
            throws IllegalValueException {
        this.rsvTask.setDateTimeList(new DateTime(dateTime1, dateTime2));
        return this;
    }

    public TestRsvTask build() {
        return this.rsvTask;
    }

}
```
###### \java\tars\testutil\TestRsvTask.java
``` java
/**
 * A mutable reserve task object. For testing only
 */
public class TestRsvTask extends RsvTask { 
   
    public void setDateTimeList(DateTime...dateTimes) {
        for (DateTime dt : dateTimes) {
            dateTimeList.add(dt);
        }
    }
        
    public String getRsvCommand() {
        StringBuilder sb = new StringBuilder();
        sb.append("rsv " + this.getName().taskName + " ");
        for (DateTime dt : dateTimeList) {
            sb.append("/dt " + dt.toString() + " ");
        }
        
        return sb.toString();
    }
    
}
```
###### \java\tars\testutil\TestUtil.java
``` java
    /**
     * Edits the task with index 1 on the list of tasks.
     * 
     * @param tasks An array of tasks.
     * @param indexToEdit Index of the task to edit.
     * @param nameToEdit Name of the task to edit.
     * @param priorityToEdit Priority of the task to edit.
     * @return The modified array of tasks.
     */
    public static TestTask[] editTask(final TestTask[] tasks, int indexToEdit, Name nameToEdit,
            Priority priorityToEdit) {
        List<TestTask> listOfTasks = asList(tasks);
        listOfTasks.get(indexToEdit).setName(nameToEdit);
        listOfTasks.get(indexToEdit).setPriority(priorityToEdit);

        return listOfTasks.toArray(new TestTask[listOfTasks.size()]);
    }

```
