# A0124333U
###### \java\tars\commons\core\KeyCombinations.java
``` java
/**
 * Container for all key combinations used by program
 */
public class KeyCombinations {

    public static final KeyCombination KEY_COMB_CTRL_RIGHT_ARROW =
            new KeyCodeCombination(KeyCode.RIGHT, KeyCombination.CONTROL_DOWN);
    public static final KeyCombination KEY_COMB_CTRL_LEFT_ARROW =
            new KeyCodeCombination(KeyCode.LEFT, KeyCombination.CONTROL_DOWN);

    public static final KeyCombination KEY_COMB_CTRL_Z =
            new KeyCodeCombination(KeyCode.Z, KeyCombination.CONTROL_DOWN);
    public static final KeyCombination KEY_COMB_CTRL_Y =
            new KeyCodeCombination(KeyCode.Y, KeyCombination.CONTROL_DOWN);
    
}
```
###### \java\tars\commons\events\storage\TarsStorageDirectoryChangedEvent.java
``` java
/**
 * An event where the user changes the Tars Storage Directory/File Path
 */
public class TarsStorageDirectoryChangedEvent extends BaseEvent {
    private static String MESSAGE_FILE_PATH_CHANGED = "File Path changed to %s";

    private final String newFilePath;
    private final Config newConfig;

    public TarsStorageDirectoryChangedEvent(String newFilePath,
            Config newConfig) {
        this.newFilePath = newFilePath;
        this.newConfig = newConfig;
    }

    public String getNewFilePath() {
        return this.newFilePath;
    }

    public Config getNewConfig() {
        return this.newConfig;
    }

    @Override
    public String toString() {
        return String.format(MESSAGE_FILE_PATH_CHANGED, this.newFilePath);
    }

}
```
###### \java\tars\commons\events\ui\KeyCombinationPressedEvent.java
``` java
/**
 * Indicates that the user has pressed a key combination
 */
public class KeyCombinationPressedEvent extends BaseEvent {

    private KeyCombination keyComb;

    public KeyCombinationPressedEvent(KeyCombination keyComb) {
        this.keyComb = keyComb;
    }

    public KeyCombination getKeyCombination() {
        return keyComb;
    }

    @Override
    public String toString() {
        return this.getClass().getSimpleName();
    }

}
```
###### \java\tars\commons\util\DateTimeUtil.java
``` java
    /**
     * Checks whether the dateTimeQuery falls within the range of the dateTimeSource i.e.
     * dateTimeQuery startDateTime is equals to or before the dateTimeSource endDateTime &&
     * dateTimeQuery endDateTime is equals to or after the dateTimeSource startDateTime
     * 
     * @param dateTimeSource
     * @param dateTimeQuery
     */
    public static boolean isDateTimeWithinRange(DateTime dateTimeSource,
            DateTime dateTimeQuery) {

        // Return false if task is a floating task (i.e. no start or end
        // dateTime
        if (dateTimeSource.getEndDate() == null) {
            return false;
        }

        DateTime dateTime1 = fillDateTime(dateTimeSource);
        DateTime dateTime2 = fillDateTime(dateTimeQuery);

        return !dateTime1.getEndDate().isBefore(dateTime2.getStartDate())
                && !dateTime1.getStartDate().isAfter(dateTime2.getEndDate());
    }

    /**
     * Checks whether the dateTimeQuery conflicts with the dateTimeSource i.e. dateTimeQuery
     * endDateTime occurs after the dateTimeSource startDateTime && dateTimeQuery startDateTime
     * occurs before the dateTimeSource endDateTime
     */
    public static boolean isDateTimeConflicting(DateTime dateTimeSource,
            DateTime dateTimeQuery) {

        // Return false if task is a floating task (i.e. no start or end
        // dateTime
        if (dateTimeSource.getEndDate() == null) {
            return false;
        }

        DateTime dateTime1 = fillDateTime(dateTimeSource);
        DateTime dateTime2 = fillDateTime(dateTimeQuery);

        return dateTime1.getEndDate().isAfter(dateTime2.getStartDate())
                && dateTime1.getStartDate().isBefore(dateTime2.getEndDate());
    }

    private static DateTime fillDateTime(DateTime filledDateTime) {
        DateTime dateTimeToFill = new DateTime();

        dateTimeToFill.setEndDateTime(filledDateTime.getEndDate());

        if (filledDateTime.getStartDate() != null) {
            dateTimeToFill.setStartDateTime(filledDateTime.getStartDate());
        } else {
            dateTimeToFill.setStartDateTime(filledDateTime.getEndDate());
        }
        return dateTimeToFill;
    }


    /**
     * Returns an arraylist of free datetime slots in a specified date
     */
    public static ArrayList<DateTime> getListOfFreeTimeSlotsInDate(
            DateTime dateToCheck,
            ArrayList<DateTime> listOfFilledTimeSlotsInDate) {
        ArrayList<DateTime> listOfFreeTimeSlots = new ArrayList<DateTime>();
        LocalDateTime startDateTime = dateToCheck.getStartDate();
        LocalDateTime endDateTime;

        for (DateTime dt : listOfFilledTimeSlotsInDate) {
            if (dt.getStartDate() == null) {
                continue;
            } else {
                endDateTime = dt.getStartDate();
            }

            if (startDateTime.isBefore(endDateTime)) {
                listOfFreeTimeSlots
                        .add(new DateTime(startDateTime, endDateTime));
            }

            if (startDateTime.isBefore(dt.getEndDate())) {
                startDateTime = dt.getEndDate();
            }
        }

        if (startDateTime.isBefore(dateToCheck.getEndDate())) {
            listOfFreeTimeSlots
                    .add(new DateTime(startDateTime, dateToCheck.getEndDate()));
        }

        return listOfFreeTimeSlots;
    }


    public static String getDayAndDateString(DateTime dateTime) {
        StringBuilder sb = new StringBuilder();

        sb.append(dateTime.getEndDate().getDayOfWeek()
                .getDisplayName(TextStyle.FULL, Locale.ENGLISH))
                .append(StringUtil.STRING_COMMA).append(dateTime.getEndDate()
                        .format(stringFormatterWithoutTime));

        return sb.toString();
    }


    public static String getStringOfFreeDateTimeInDate(DateTime dateToCheck,
            ArrayList<DateTime> listOfFreeTimeSlotsInDate) {
        StringBuilder sb = new StringBuilder();

        sb.append(getDayAndDateString(dateToCheck))
                .append(StringUtil.STRING_COLON);

        int counter = 1;

        for (DateTime dt : listOfFreeTimeSlotsInDate) {
            sb.append(String.format(MESSAGE_FREE_TIME_SLOT, counter,
                    dt.getStartDate().format(stringFormatterWithoutDate),
                    dt.getEndDate().format(stringFormatterWithoutDate),
                    getDurationBetweenTwoLocalDateTime(dt.getStartDate(),
                            dt.getEndDate())));
            counter++;
        }

        return sb.toString();
    }

    public static String getDurationBetweenTwoLocalDateTime(
            LocalDateTime startDateTime, LocalDateTime endDateTime) {
        Duration duration = Duration.between(startDateTime, endDateTime);
        long hours = duration.toHours();
        long minutes = duration.toMinutes() % 60;

        return String.format(MESSAGE_DURATION, hours, minutes);
    }

```
###### \java\tars\logic\commands\CdCommand.java
``` java
/**
 * Changes the directory of the Tars storage file, tars.xml
 */
public class CdCommand extends Command {

    public static final String COMMAND_WORD = "cd";

    public static final String MESSAGE_USAGE =
            COMMAND_WORD + ": Changes the directory of the "
                    + "TARS storage file.\n" + "Parameters: <FILE_PATH.xml> \n"
                    + "Example: " + COMMAND_WORD + " data/tars.xml";

    public static final String MESSAGE_INVALID_FILEPATH =
            "Invalid file path. File paths should end with the file type .xml \n"
                    + "Example: " + COMMAND_WORD + " data/tars.xml";

    public static final String MESSAGE_SUCCESS_NEW_FILE =
            "Change Directory Success! New file created! Directory of TARS storage file"
                    + " changed to: '%1$s'.";

    public static final String MESSAGE_SUCCESS_EXISTING_FILE =
            "Change Directory Success! File read successfully! Directory of TARS storage "
                    + "file changed to : '%1$s'.";

    public static final String MESSAGE_FAILURE_WRITE_FILE =
            "Unable to write to location, please choose another directory";

    public static final String MESSAGE_FAILURE_READ_FILE =
            "Unable to read from location, please choose another directory";

    private final String newFilePath;
    private final static String xmlFileExt = "xml";;
    private Storage storageUpdater = new StorageManager();
    private Config newConfig = new Config();

    public CdCommand(String filepath) {
        this.newFilePath = filepath;
    }

    public final static String getXmlFileExt() {
        return xmlFileExt;
    }

    @Override
    public String toString() {
        return this.newFilePath;
    }

    @Override
    public CommandResult execute() {

        newConfig.setTarsFilePath(newFilePath);
        File file = new File(newFilePath);

        EventsCenter.getInstance().post(new ScrollToTopEvent());
        return FileUtil.isFileExists(file) ? readTarsFromNewFilePath()
                : saveTarsToNewFilePath();
    }

    private CommandResult saveTarsToNewFilePath() {
        try {
            // try to save TARS data into new file
            storageUpdater.saveTarsInNewFilePath(model.getTars(), newFilePath); 
            if (storageUpdater.isFileSavedSuccessfully(newFilePath)) {
                updateTarsSystemWithNewFilePath();
                return new CommandResult(
                        String.format(MESSAGE_SUCCESS_NEW_FILE, newFilePath));
            } else {
                return new CommandResult(MESSAGE_FAILURE_WRITE_FILE);
            }
        } catch (IOException ioe) {
            return new CommandResult(MESSAGE_FAILURE_WRITE_FILE);
        }

    }

    private CommandResult readTarsFromNewFilePath() {
        Optional<ReadOnlyTars> tarsOptional;
        ReadOnlyTars tarsDataToOverwrite;
        try {
            tarsOptional = storageUpdater.readTarsFromNewFilePath(newFilePath);

            tarsDataToOverwrite = tarsOptional.orElse(null);

            if (tarsDataToOverwrite != null) {
                model.overwriteDataFromNewFilePath(tarsDataToOverwrite);
                updateTarsSystemWithNewFilePath();
                return new CommandResult(String
                        .format(MESSAGE_SUCCESS_EXISTING_FILE, newFilePath));
            } else {
                return new CommandResult(MESSAGE_FAILURE_READ_FILE);
            }
        } catch (DataConversionException | IOException e) {
            return new CommandResult(MESSAGE_FAILURE_READ_FILE);
        }

    }

    private void updateTarsSystemWithNewFilePath() throws IOException {
        storageUpdater.updateTarsStorageDirectory(newFilePath, newConfig);
        ConfigUtil.updateConfig(newConfig);
    }

}
```
###### \java\tars\logic\commands\ConfirmCommand.java
``` java
/**
 * Confirms a specified datetime for a reserved task and add it into the task list
 */
public class ConfirmCommand extends UndoableCommand {

    public static final String COMMAND_WORD = "confirm";

    public static final String MESSAGE_USAGE =
            COMMAND_WORD + ": Confirms a datetime for a reserved task"
                    + " and adds it to the task list.\n"
                    + "Parameters: <RSV_TASK_INDEX> <DATETIME_INDEX> [/p PRIORITY] [/t TAG_NAME ...]\n"
                    + "Example: " + COMMAND_WORD + " 1 3 /p h /t tag";

    public static final String MESSAGE_CONFIRM_SUCCESS =
            "Task Confirmation Success! New task added: %1$s";
    private String conflictingTaskList = "";

    private final int taskIndex;
    private final int dateTimeIndex;
    private final String priority;
    private final Set<Tag> tagSet = new HashSet<>();

    private Task toConfirm;
    private RsvTask rsvTask;

    public ConfirmCommand(int taskIndex, int dateTimeIndex, String priority,
            Set<String> tags) throws IllegalValueException {
        this.taskIndex = taskIndex;
        this.dateTimeIndex = dateTimeIndex;
        this.priority = priority;

        for (String tagName : tags) {
            tagSet.add(new Tag(tagName));
        }
    }

    @Override
    public CommandResult execute() {
        assert model != null;
        UnmodifiableObservableList<RsvTask> lastShownList =
                model.getFilteredRsvTaskList();

        if (lastShownList.size() < taskIndex) {
            indicateAttemptToExecuteIncorrectCommand();
            return new CommandResult(
                    Messages.MESSAGE_INVALID_RSV_TASK_DISPLAYED_INDEX);
        }

        rsvTask = lastShownList
                .get(taskIndex - StringUtil.DISPLAYED_INDEX_OFFSET);

        if (rsvTask.getDateTimeList().size() < dateTimeIndex) {
            indicateAttemptToExecuteIncorrectCommand();
            return new CommandResult(
                    Messages.MESSAGE_INVALID_DATETIME_DISPLAYED_INDEX);
        }

        try {
            toConfirm = new Task(rsvTask.getName(), rsvTask.getDateTimeList()
                    .get((dateTimeIndex - StringUtil.DISPLAYED_INDEX_OFFSET)),
                    new Priority(priority), new Status(),
                    new UniqueTagList(tagSet));
        } catch (IllegalValueException ive) {
            return new CommandResult(String
                    .format(MESSAGE_INVALID_COMMAND_FORMAT, MESSAGE_USAGE));
        }

        try {
            model.deleteRsvTask(rsvTask);
        } catch (RsvTaskNotFoundException rtnfe) {
            return new CommandResult(Messages.MESSAGE_RSV_TASK_CANNOT_BE_FOUND);
        }

        try {
            conflictingTaskList +=
                    model.getTaskConflictingDateTimeWarningMessage(
                            toConfirm.getDateTime());
            model.addTask(toConfirm);
        } catch (DuplicateTaskException e) {
            return new CommandResult(Messages.MESSAGE_DUPLICATE_TASK);
        }

        model.getUndoableCmdHist().push(this);
        return new CommandResult(getSuccessMessageSummary());
    }

    private String getSuccessMessageSummary() {
        String summary =
                String.format(MESSAGE_CONFIRM_SUCCESS, toConfirm.toString());

        if (!conflictingTaskList.isEmpty()) {
            summary += StringUtil.STRING_NEWLINE
                    + Messages.MESSAGE_CONFLICTING_TASKS_WARNING
                    + conflictingTaskList;
        }

        return summary;
    }

```
###### \java\tars\logic\commands\FindCommand.java
``` java
/**
 * Finds and lists all tasks in address book whose name contains any of the argument keywords.
 * Keyword matching is case sensitive.
 */
public class FindCommand extends Command {

    public static final String COMMAND_WORD = "find";

    public static final String MESSAGE_USAGE = COMMAND_WORD
            + ": Finds all tasks containing a list of keywords (i.e. AND search)."
            + "keywords (case-insensitive) and displays them as a list with index numbers.\n"
            + "Parameters (Quick Search Mode): <KEYWORD> [KEYWORD ...]\n"
            + "Parameters (Filter Search Mode): [/n NAME_KEYWORD ...] [/dt DATETIME] [/p PRIORITY] [/do] [/ud] [/t TAG_KEYWORD ...]\n"
            + "Examples (Quick Serach Mode): " + COMMAND_WORD
            + " CS2103 projects" + "Examples (Filter Search Mode): "
            + COMMAND_WORD + " /n CS2103 projects /dt 10/09/2016 1000 to "
            + "20/09/2016 0100 /t school projects /do";

    private static String MESSAGE_QUICK_SEARCH_KEYWORDS =
            "\nQuick Search Keywords: %s";

    private TaskQuery taskQuery = null;
    private ArrayList<String> quickSearchKeywords = null;
    private String searchKeywords = "";

    public FindCommand(TaskQuery taskQuery) {
        this.taskQuery = taskQuery;
    }

    public FindCommand(ArrayList<String> quickSearchKeywords) {
        this.quickSearchKeywords = quickSearchKeywords;
    }

    @Override
    public CommandResult execute() {
        if (isFilterSearchModeUsed()) {
            model.updateFilteredTaskListUsingFlags(taskQuery);
            searchKeywords = StringUtil.STRING_NEWLINE + taskQuery.toString();
        }

        if (isQuickSearchModeUsed()) {
            model.updateFilteredTaskListUsingQuickSearch(quickSearchKeywords);
            searchKeywords = String.format(MESSAGE_QUICK_SEARCH_KEYWORDS,
                    quickSearchKeywords.toString());
        }
        EventsCenter.getInstance().post(new ScrollToTopEvent());
        return new CommandResult(getMessageForTaskListShownSummary(
                model.getFilteredTaskList().size()) + searchKeywords);
    }

    private Boolean isFilterSearchModeUsed() {
        return taskQuery != null;
    }

    private Boolean isQuickSearchModeUsed() {
        return quickSearchKeywords != null;
    }

}
```
###### \java\tars\logic\commands\FreeCommand.java
``` java
 * 
 *          Suggests free time slots on a specified date
 */
public class FreeCommand extends Command {

    public static final String COMMAND_WORD = "free";

    public static final String MESSAGE_USAGE =
            COMMAND_WORD + ": Suggests free timeslots in a specified day.\n"
                    + "Parameters: <DATETIME>\n" + "Example: free 29/10/2016";

    public static final String MESSAGE_DATE_RANGE_DETECTED =
            "Range of datetime detected. Please only input a single datetime";
    public static final String MESSAGE_SUCCESS = "Free timeslots on %1$s";
    public static final String MESSAGE_FREE_DAY =
            "You have no event tasks or reserved event tasks on %1$s";
    public static final String MESSAGE_NO_FREE_TIMESLOTS =
            "You have no free time slots on %1$s";

    private DateTime dateToCheck;

    public FreeCommand(DateTime dateToCheck) {
        this.dateToCheck = dateToCheck;

        // Ensure that dateToCheck covers the whole day
        this.dateToCheck.setStartDateTime(dateToCheck.getEndDate()
                .withHour(DateTimeUtil.DATETIME_FIRST_HOUR_OF_DAY)
                .withMinute(DateTimeUtil.DATETIME_FIRST_MINUTE_OF_DAY)
                .withSecond(DateTimeUtil.DATETIME_FIRST_SECOND_OF_DAY));

        this.dateToCheck.setEndDateTime(dateToCheck.getEndDate()
                .withHour(DateTimeUtil.DATETIME_LAST_HOUR_OF_DAY)
                .withMinute(DateTimeUtil.DATETIME_LAST_MINUTE_OF_DAY)
                .withSecond(DateTimeUtil.DATETIME_FIRST_SECOND_OF_DAY));
    }

    @Override
    public CommandResult execute() {
        ArrayList<DateTime> listOfFilledTimeSlots =
                model.getListOfFilledTimeSlotsInDate(dateToCheck);
        ArrayList<DateTime> listOfFreeTimeSlots =
                DateTimeUtil.getListOfFreeTimeSlotsInDate(dateToCheck,
                        listOfFilledTimeSlots);

        model.updateFilteredTaskListUsingDate(dateToCheck);

        if (listOfFilledTimeSlots.isEmpty()) {
            return new CommandResult(String.format(MESSAGE_FREE_DAY,
                    DateTimeUtil.getDayAndDateString(dateToCheck)));
        } else if (listOfFreeTimeSlots.isEmpty()) {
            return new CommandResult(String.format(MESSAGE_NO_FREE_TIMESLOTS,
                    DateTimeUtil.getDayAndDateString(dateToCheck)));
        } else {
            return new CommandResult(String.format(MESSAGE_SUCCESS,
                    DateTimeUtil.getStringOfFreeDateTimeInDate(dateToCheck,
                            listOfFreeTimeSlots)));
        }
    }

}
```
###### \java\tars\logic\commands\RsvCommand.java
``` java
/**
 * Adds a reserved task which has a list of reserved date times that can confirmed later on.
 */
public class RsvCommand extends UndoableCommand {

    public static final String COMMAND_WORD = "rsv";
    public static final String COMMAND_WORD_DEL = "rsv /del";

    public static final String MESSAGE_USAGE = COMMAND_WORD
            + ": Reserves one or more timeslot for a task.\n"
            + "Parameters: <TASK_NAME> </dt DATETIME> [/dt DATETIME ...]\n"
            + "Example: " + COMMAND_WORD
            + " Meet John Doe /dt 26/09/2016 0900 to 1030, 28/09/2016 1000 to 1130";

    public static final String MESSAGE_USAGE_DEL = COMMAND_WORD_DEL
            + ": Deletes a reserved task in the last reserved task listing \n"
            + "Parameters: INDEX (must be a positive integer)\n " + "Example: "
            + COMMAND_WORD_DEL + " 1\n" + "OR " + COMMAND_WORD_DEL + " 1..3";

    public static final String MESSAGE_DATETIME_NOT_FOUND =
            "At least one DateTime is required!\n" + MESSAGE_USAGE;

    public static final String MESSAGE_INVALID_RSV_TASK_DISPLAYED_INDEX =
            "The Reserved Task Index is invalid!";

    public static final String MESSAGE_SUCCESS = "New task reserved: %1$s";
    public static final String MESSAGE_SUCCESS_DEL =
            "Deleted reserved tasks:\n%1$s";
    public static final String MESSAGE_UNDO_DELETE = "Deleted %1$s";
    public static final String MESSAGE_UNDO_ADD = "Added:\n%1$s";
    public static final String MESSAGE_REDO_DELETE = "Deleted:%1$s";
    public static final String MESSAGE_REDO_ADD = "Added %1$s";

    private static final String MESSAGE_CONFLICT_FOR = "\nConflicts for ";

    private RsvTask toReserve = null;
    private String rangeIndexString = "";
    private String conflictingTaskList = "";

    private static final int INDEX_OF_ENDDATE = 1;
    private static final int INDEX_OF_STARTDATE = 0;

    private ArrayList<RsvTask> rsvTasksToDelete;

    /**
     * Convenience constructor using raw values.
     *
     * @throws IllegalValueException if any of the raw values are invalid
     * @throws DateTimeException if given dateTime string is invalid.
     */
    public RsvCommand(String name, Set<String[]> dateTimeStringSet)
            throws IllegalValueException {

        Set<DateTime> dateTimeSet = new HashSet<>();
        for (String[] dateTimeStringArray : dateTimeStringSet) {
            dateTimeSet
                    .add(new DateTime(dateTimeStringArray[INDEX_OF_STARTDATE],
                            dateTimeStringArray[INDEX_OF_ENDDATE]));
        }

        this.toReserve = new RsvTask(new Name(name),
                new ArrayList<DateTime>(dateTimeSet));
    }

    public RsvCommand(String rangeIndexString) {
        this.rangeIndexString = rangeIndexString;
    }

    @Override
    public CommandResult execute() {
        assert model != null;

        if (toReserve != null) {
            return addRsvTask();
        } else {
            return delRsvTask();
        }

    }

    private CommandResult addRsvTask() {
        try {
            for (DateTime dt : toReserve.getDateTimeList()) {
                if (!model.getTaskConflictingDateTimeWarningMessage(dt)
                        .isEmpty()) {
                    conflictingTaskList += MESSAGE_CONFLICT_FOR + dt.toString()
                            + StringUtil.STRING_COLON;
                    conflictingTaskList +=
                            model.getTaskConflictingDateTimeWarningMessage(dt);
                }
            }
            model.addRsvTask(toReserve);
            model.getUndoableCmdHist().push(this);
            return new CommandResult(getSuccessMessageSummary());
        } catch (DuplicateTaskException e) {
            return new CommandResult(Messages.MESSAGE_DUPLICATE_TASK);
        }
    }

    private CommandResult delRsvTask() {
        rsvTasksToDelete = new ArrayList<RsvTask>();

        try {
            rsvTasksToDelete = getRsvTasksFromIndexes(
                    this.rangeIndexString.split(StringUtil.STRING_WHITESPACE));
        } catch (InvalidTaskDisplayedException itde) {
            return new CommandResult(itde.getMessage());
        }

        for (RsvTask t : rsvTasksToDelete) {
            try {
                model.deleteRsvTask(t);
            } catch (RsvTaskNotFoundException rtnfe) {
                return new CommandResult(
                        Messages.MESSAGE_RSV_TASK_CANNOT_BE_FOUND);
            }
        }

        model.getUndoableCmdHist().push(this);
        String deletedRsvTasksList =
                new Formatter().formatRsvTaskList(rsvTasksToDelete);
        return new CommandResult(
                String.format(MESSAGE_SUCCESS_DEL, deletedRsvTasksList));
    }

    /**
     * Gets Tasks to delete
     * 
     * @param indexes
     * @throws InvalidTaskDisplayedException
     */
    private ArrayList<RsvTask> getRsvTasksFromIndexes(String[] indexes)
            throws InvalidTaskDisplayedException {
        UnmodifiableObservableList<RsvTask> lastShownList =
                model.getFilteredRsvTaskList();
        ArrayList<RsvTask> rsvTasksList = new ArrayList<RsvTask>();

        for (int i = StringUtil.START_INDEX; i < indexes.length; i++) {
            int targetIndex = Integer.parseInt(indexes[i]);
            if (lastShownList.size() < targetIndex) {
                indicateAttemptToExecuteIncorrectCommand();
                throw new InvalidTaskDisplayedException(
                        Messages.MESSAGE_INVALID_RSV_TASK_DISPLAYED_INDEX);
            }
            RsvTask rsvTask =
                    lastShownList.get(targetIndex - StringUtil.LAST_INDEX);
            rsvTasksList.add(rsvTask);
        }
        return rsvTasksList;
    }

    private String getSuccessMessageSummary() {
        String summary = String.format(MESSAGE_SUCCESS, toReserve.toString());

        if (!conflictingTaskList.isEmpty()) {
            summary += StringUtil.STRING_NEWLINE
                    + Messages.MESSAGE_CONFLICTING_TASKS_WARNING
                    + conflictingTaskList;
        }

        return summary;
    }

```
###### \java\tars\logic\parser\ConfirmCommandParser.java
``` java
/**
 * Confirm command parser
 */
public class ConfirmCommandParser extends CommandParser {

    private static final int EXPECTED_INDEX_STRING_ARRAY_LENGTH = 2;
    private static final int INDEX_OF_TASK = 0;
    private static final int INDEX_OF_DATETIME = 1;

    @Override
    public Command prepareCommand(String args) {
        // there is no arguments
        if (args.trim().isEmpty()) {
            return new IncorrectCommand(
                    String.format(MESSAGE_INVALID_COMMAND_FORMAT,
                            ConfirmCommand.MESSAGE_USAGE));
        }

        ArgumentTokenizer argsTokenizer =
                new ArgumentTokenizer(priorityPrefix, tagPrefix);
        argsTokenizer.tokenize(args);

        int taskIndex;
        int dateTimeIndex;

        try {
            String indexArgs = argsTokenizer.getPreamble().get();
            String[] indexStringArray = StringUtil.indexString(indexArgs)
                    .split(StringUtil.STRING_WHITESPACE);
            if (indexStringArray.length != EXPECTED_INDEX_STRING_ARRAY_LENGTH) {
                return new IncorrectCommand(
                        String.format(MESSAGE_INVALID_COMMAND_FORMAT,
                                ConfirmCommand.MESSAGE_USAGE));
            } else {
                taskIndex = Integer.parseInt(indexStringArray[INDEX_OF_TASK]);
                dateTimeIndex =
                        Integer.parseInt(indexStringArray[INDEX_OF_DATETIME]);
            }
        } catch (IllegalValueException | NoSuchElementException e) {
            return new IncorrectCommand(
                    String.format(MESSAGE_INVALID_COMMAND_FORMAT,
                            ConfirmCommand.MESSAGE_USAGE));
        } catch (InvalidRangeException ire) {
            return new IncorrectCommand(ire.getMessage());
        }

        try {
            return new ConfirmCommand(taskIndex, dateTimeIndex,
                    argsTokenizer.getValue(priorityPrefix)
                            .orElse(StringUtil.EMPTY_STRING),
                    argsTokenizer.getMultipleValues(tagPrefix)
                            .orElse(new HashSet<>()));
        } catch (IllegalValueException ive) {
            return new IncorrectCommand(
                    String.format(MESSAGE_INVALID_COMMAND_FORMAT,
                            ConfirmCommand.MESSAGE_USAGE));
        }
    }

}
```
###### \java\tars\logic\parser\FreeCommandParser.java
``` java
/**
 * Free command parser
 */
public class FreeCommandParser extends CommandParser {
    
    public static final int FIRST_DATETIME_INDEX = 0;
    public static final int SECOND_DATETIME_INDEX = 1;

    @Override
    public Command prepareCommand(String args) {
        args = args.trim();

        if (args.isEmpty()) {
            return new IncorrectCommand(String.format(
                    MESSAGE_INVALID_COMMAND_FORMAT, FreeCommand.MESSAGE_USAGE));
        }

        String[] dateTimeStringArray = {StringUtil.EMPTY_STRING};

        try {
            dateTimeStringArray = DateTimeUtil.parseStringToDateTime(args);
        } catch (DateTimeException dte) {
            return new IncorrectCommand(String.format(
                    MESSAGE_INVALID_COMMAND_FORMAT, FreeCommand.MESSAGE_USAGE));
        }

        if (!dateTimeStringArray[FIRST_DATETIME_INDEX].isEmpty()) {
            return new IncorrectCommand(
                    FreeCommand.MESSAGE_DATE_RANGE_DETECTED);
        } else {
            try {
                return new FreeCommand(new DateTime(dateTimeStringArray[FIRST_DATETIME_INDEX],
                        dateTimeStringArray[SECOND_DATETIME_INDEX]));
            } catch (DateTimeException dte) {
                return new IncorrectCommand(Messages.MESSAGE_INVALID_DATE);
            } catch (IllegalDateException ide) {
                return new IncorrectCommand(Messages.MESSAGE_INVALID_DATE);
            }
        }
    }

}
```
###### \java\tars\logic\parser\RsvCommandParser.java
``` java
/**
 * Reserve command parser
 */
public class RsvCommandParser extends CommandParser {

    @Override
    public Command prepareCommand(String args) {
        // there is no arguments
        if (args.trim().isEmpty()) {
            return new IncorrectCommand(String.format(
                    MESSAGE_INVALID_COMMAND_FORMAT, RsvCommand.MESSAGE_USAGE));
        }

        ArgumentTokenizer argsTokenizer =
                new ArgumentTokenizer(dateTimePrefix, deletePrefix);
        argsTokenizer.tokenize(args);

        if (argsTokenizer.getValue(deletePrefix).isPresent()) {
            return prepareRsvDel(argsTokenizer);
        } else {
            return prepareRsvAdd(argsTokenizer);
        }
    }

    // Parses arguments for adding a reserved task
    private Command prepareRsvAdd(ArgumentTokenizer argsTokenizer) {
        if (!argsTokenizer.getValue(dateTimePrefix).isPresent()) {
            return new IncorrectCommand(
                    String.format(MESSAGE_INVALID_COMMAND_FORMAT,
                            RsvCommand.MESSAGE_DATETIME_NOT_FOUND));
        }

        Set<String[]> dateTimeStringSet = new HashSet<>();

        try {
            for (String dateTimeString : argsTokenizer
                    .getMultipleValues(dateTimePrefix).get()) {
                dateTimeStringSet.add(
                        DateTimeUtil.parseStringToDateTime(dateTimeString));
            }

            return new RsvCommand(argsTokenizer.getPreamble().get(),
                    dateTimeStringSet);
        } catch (IllegalValueException ive) {
            return new IncorrectCommand(ive.getMessage());
        } catch (DateTimeException dte) {
            return new IncorrectCommand(Messages.MESSAGE_INVALID_DATE);
        } catch (NoSuchElementException nse) {
            return new IncorrectCommand(String.format(
                    MESSAGE_INVALID_COMMAND_FORMAT, RsvCommand.MESSAGE_USAGE));
        }
    }

    // Parses arguments for deleting one or more reserved tasks
    private Command prepareRsvDel(ArgumentTokenizer argsTokenizer) {
        try {
            if (argsTokenizer.getPreamble().isPresent()) {
                return new IncorrectCommand(
                        String.format(MESSAGE_INVALID_COMMAND_FORMAT,
                                RsvCommand.MESSAGE_USAGE_DEL));
            }

            String rangeIndex = StringUtil
                    .indexString(argsTokenizer.getValue(deletePrefix).get());
            return new RsvCommand(rangeIndex);
        } catch (InvalidRangeException | IllegalValueException ie) {
            return new IncorrectCommand(
                    String.format(MESSAGE_INVALID_COMMAND_FORMAT,
                            RsvCommand.MESSAGE_USAGE_DEL));
        }
    }

}
```
###### \java\tars\model\Model.java
``` java
    /**
     * Overwrites current data with data from a new file path.
     */
    public void overwriteDataFromNewFilePath(ReadOnlyTars newData);
    
```
###### \java\tars\model\Model.java
``` java
    /**
     * Deletes the reserved task.
     */
    void deleteRsvTask(RsvTask target) throws RsvTaskNotFoundException;

    /** Adds the given reserved task */
    void addRsvTask(RsvTask rsvTask) throws DuplicateTaskException;

    /** Checks for tasks with conflicting datetime and returns a string of all conflicting tasks */
    String getTaskConflictingDateTimeWarningMessage(DateTime dateTimeToCheck);

```
###### \java\tars\model\Model.java
``` java
    /**
     * Updates the filter of the filtered task list to filter by the given keywords of each given
     * task attribute
     */
    void updateFilteredTaskListUsingFlags(TaskQuery taskQuery);

    /**
     * Updates the filter of the filtered task list to filter by the given keywords of a string
     * consisting of all the attributes of each task
     */
    void updateFilteredTaskListUsingQuickSearch(
            ArrayList<String> lazySearchKeywords);

```
###### \java\tars\model\Model.java
``` java
    /**
     * Returns an ArrayList of DateTime in a specified date
     */
    public ArrayList<DateTime> getListOfFilledTimeSlotsInDate(
            DateTime dateToCheck);

```
###### \java\tars\model\ModelManager.java
``` java
    /**
     * Returns a string of tasks and rsv tasks whose datetime conflicts with a specified datetime
     */
    public String getTaskConflictingDateTimeWarningMessage(
            DateTime dateTimeToCheck) {
        StringBuilder conflictingTasksStringBuilder =
                new StringBuilder(StringUtil.EMPTY_STRING);
        int taskCount = 1;
        int rsvCount = 1;

        if (dateTimeToCheck.getEndDate() == null) {
            return StringUtil.EMPTY_STRING;
        }

        for (ReadOnlyTask t : tars.getTaskList()) {

            if (t.getStatus().status == Status.UNDONE && DateTimeUtil
                    .isDateTimeConflicting(t.getDateTime(), dateTimeToCheck)) {
                conflictingTasksStringBuilder.append(String
                        .format(CONFLICTING_TASK, taskCount, t.getAsText()));
                taskCount++;
            }
        }

        for (RsvTask rt : tars.getRsvTaskList()) {
            if (rt.getDateTimeList().stream()
                    .filter(dateTimeSource -> DateTimeUtil
                            .isDateTimeConflicting(dateTimeSource,
                                    dateTimeToCheck))
                    .count() > 0) {
                conflictingTasksStringBuilder.append(String
                        .format(CONFLICTING_RSV_TASK, rsvCount, rt.toString()));
                rsvCount++;

            }
        }

        return conflictingTasksStringBuilder.toString();
    }

    /**
     * Returns a sorted arraylist of filled datetime slots in a specified date Datetimes with no
     * startdate are not added into the list
     */
    public ArrayList<DateTime> getListOfFilledTimeSlotsInDate(
            DateTime dateToCheck) {
        ArrayList<DateTime> listOfDateTime = new ArrayList<DateTime>();

        for (ReadOnlyTask t : tars.getTaskList()) {
            if (t.getStatus().status == Status.UNDONE
                    && t.getDateTime().getStartDate() != null
                    && DateTimeUtil.isDateTimeWithinRange(t.getDateTime(),
                            dateToCheck)) {
                listOfDateTime.add(t.getDateTime());
            }
        }

        for (RsvTask rt : tars.getRsvTaskList()) {
            for (DateTime dt : rt.getDateTimeList()) {
                if (dt.getStartDate() != null && DateTimeUtil
                        .isDateTimeWithinRange(dt, dateToCheck)) {
                    listOfDateTime.add(dt);
                }
            }
        }

        Collections.sort(listOfDateTime);

        return listOfDateTime;
    }


```
###### \java\tars\model\ModelManager.java
``` java
    private class QuickSearchQualifier implements Qualifier {
        private static final String LABEL_TAGS = "Tags: ";
        private static final String LABEL_STATUS = "Status: ";
        private static final String LABEL_PRIORITY = "Priority: ";
        private static final String LABEL_DATETIME = "DateTime: ";
        private final ArrayList<String> quickSearchKeywords;

        QuickSearchQualifier(ArrayList<String> quickSearchKeywords) {
            this.quickSearchKeywords = quickSearchKeywords;
        }

        private String removeLabels(String taskAsString) {
            String editedString = taskAsString
                    .replace(StringUtil.STRING_SQUARE_BRACKET_OPEN,
                            StringUtil.EMPTY_STRING)
                    .replace(StringUtil.STRING_SQUARE_BRACKET_CLOSE,
                            StringUtil.STRING_WHITESPACE)
                    .replace(LABEL_DATETIME, StringUtil.EMPTY_STRING)
                    .replace(LABEL_PRIORITY, StringUtil.EMPTY_STRING)
                    .replace(LABEL_STATUS, StringUtil.EMPTY_STRING)
                    .replace(LABEL_TAGS, StringUtil.EMPTY_STRING);
            return editedString;
        }

        @Override
        public boolean run(ReadOnlyTask task) {
            String taskAsString = removeLabels(task.getAsText());
            return quickSearchKeywords.stream()
                    .filter(keyword -> StringUtil
                            .containsIgnoreCase(taskAsString, keyword))
                    .count() == quickSearchKeywords.size();
        }

    }

    private class FlagSearchQualifier implements Qualifier {
        private TaskQuery taskQuery;

        FlagSearchQualifier(TaskQuery taskQuery) {
            this.taskQuery = taskQuery;
        }

        @Override
        public boolean run(ReadOnlyTask task) {

            return isNameFound(task) && isDateTimeFound(task)
                    && isPriorityFound(task) && isStatusFound(task)
                    && isTagFound(task);
        }

        private Boolean isNameFound(ReadOnlyTask task) {
            if (taskQuery.getNameKeywordsAsList().get(StringUtil.START_INDEX)
                    .isEmpty()) {
                return true;
            } else {
                return taskQuery.getNameKeywordsAsList().stream()
                        .filter(keyword -> StringUtil.containsIgnoreCase(
                                task.getName().taskName, keyword))
                        .count() == taskQuery.getNameKeywordsAsList().size();
            }
        }

        private Boolean isDateTimeFound(ReadOnlyTask task) {
            if (taskQuery.getDateTimeQueryRange() == null) {
                return true;
            } else {
                return DateTimeUtil.isDateTimeWithinRange(task.getDateTime(),
                        taskQuery.getDateTimeQueryRange());
            }
        }

        private Boolean isPriorityFound(ReadOnlyTask task) {
            if (taskQuery.getPriorityKeywordsAsList()
                    .get(StringUtil.START_INDEX).isEmpty()) {
                return true;
            } else {
                return taskQuery.getPriorityKeywordsAsList().stream()
                        .filter(keyword -> StringUtil.containsIgnoreCase(
                                task.priorityString(), keyword))
                        .count() == taskQuery.getPriorityKeywordsAsList()
                                .size();
            }
        }

        private Boolean isStatusFound(ReadOnlyTask task) {
            if (taskQuery.getStatusQuery().isEmpty()) {
                return true;
            } else {
                return taskQuery.getStatusQuery() == task.getStatus()
                        .toString();
            }
        }

        private Boolean isTagFound(ReadOnlyTask task) {
            if (taskQuery.getTagKeywordsAsList().get(StringUtil.START_INDEX)
                    .isEmpty()) {
                return true;
            } else {
                String stringOfTags = task.tagsString()
                        .replace(StringUtil.STRING_COMMA.trim(),
                                StringUtil.EMPTY_STRING)
                        .replace(StringUtil.STRING_SQUARE_BRACKET_OPEN,
                                StringUtil.EMPTY_STRING)
                        .replace(StringUtil.STRING_SQUARE_BRACKET_CLOSE,
                                StringUtil.EMPTY_STRING);
                return taskQuery.getTagKeywordsAsList().stream()
                        .filter(keyword -> StringUtil
                                .containsIgnoreCase(stringOfTags, keyword))
                        .count() == taskQuery.getTagKeywordsAsList().size();
            }
        }

    }

```
###### \java\tars\model\Tars.java
``` java
    /**
     * Adds a reserved task to tars.
     * 
     * @throws UniqueTaskList.DuplicateTaskException if an equivalent reserved task already exists.
     */
    public void addRsvTask(RsvTask rt) throws DuplicateTaskException {
        rsvTasks.add(rt);
    }

```
###### \java\tars\model\task\rsv\RsvTask.java
``` java
/**
 * A task that has unconfirmed, reserved dates.
 */
public class RsvTask {

    protected Name name;
    protected ArrayList<DateTime> dateTimeList = new ArrayList<DateTime>();

    private static String RSV_TASK_STRING = "%1$s DateTime: %2$s";

    public RsvTask() {

    }

    public RsvTask(Name name, ArrayList<DateTime> dateTimeList) {
        assert !CollectionUtil.isAnyNull(name, dateTimeList);

        this.name = name;
        this.dateTimeList = dateTimeList;

    }

    /**
     * Copy constructor.
     */
    public RsvTask(RsvTask source) {
        this(source.getName(), source.getDateTimeList());
    }

    /*
     * Accessors
     */

    public Name getName() {
        return name;
    }

    public ArrayList<DateTime> getDateTimeList() {
        return dateTimeList;
    }

    /*
     * Mutators
     */
    public void setName(Name name) {
        this.name = name;
    }

    public void setDateTimeList(ArrayList<DateTime> dateTimeList) {
        this.dateTimeList = dateTimeList;
    }

    @Override
    public boolean equals(Object other) {
        return other == this // short circuit if same object
                || (other instanceof RsvTask // instanceof handles nulls
                        && this.isSameStateAs((RsvTask) other));
    }

    public boolean isSameStateAs(RsvTask other) {
        return other == this // short circuit if same object
                || (other != null // this is first to avoid NPE below
                        && other.getName().equals(this.getName())
                        && other.getDateTimeList()
                                .equals(this.getDateTimeList()));
    }

    @Override
    public int hashCode() {
        // use this method for custom fields hashing instead of implementing
        // your own
        return Objects.hash(name, dateTimeList);
    }

    @Override
    public String toString() {
        final StringBuilder builder = new StringBuilder();
        builder.append(String.format(RSV_TASK_STRING, getName(),
                getDateTimeList().toString()));

        return builder.toString();
    }

}
```
###### \java\tars\model\task\rsv\UniqueRsvTaskList.java
``` java
/**
 * A list of reserved tasks that enforces uniqueness between its elements and does not allow nulls.
 *
 * Supports a minimal set of list operations.
 *
 * @see RsvTask#equals(Object)
 * @see CollectionUtil#elementsAreUnique(Collection)
 */
public class UniqueRsvTaskList implements Iterable<RsvTask> {
    
    private final ObservableList<RsvTask> internalList = FXCollections.observableArrayList();

    /**
     * Signals that an operation targeting a specified task in the list would fail because there is
     * no such matching task in the list.
     */
    public static class RsvTaskNotFoundException extends Exception {}

    /**
     * Constructs empty RsvTaskList.
     */
    public UniqueRsvTaskList() {
    }

    /**
     * Returns true if the list contains an equivalent reserved task as the given argument.
     */
    public boolean contains(RsvTask toCheck) {
        assert toCheck != null;
        return internalList.contains(toCheck);
    }

    /**
     * Adds a reserved task to the list.
     *
     * @throws DuplicateTaskException if the reserved task to add is a duplicate of an existing
     *         reserved task in the list.
     */
    public void add(RsvTask toAdd) throws DuplicateTaskException {
        assert toAdd != null;
        if (contains(toAdd)) {
            throw new DuplicateTaskException();
        }
        internalList.add(toAdd);
    }

    /**
     * Removes the equivalent reserved task from the list.
     *
     * @throws TaskNotFoundException if no such task could be found in the list.
     */
    public boolean remove(RsvTask toRemove) throws RsvTaskNotFoundException {
        assert toRemove != null;
        final boolean taskFoundAndDeleted = internalList.remove(toRemove);
        if (!taskFoundAndDeleted) {
            throw new RsvTaskNotFoundException();
        }
        return taskFoundAndDeleted;
    }

    public ObservableList<RsvTask> getInternalList() {
        return internalList;
    }

    @Override
    public Iterator<RsvTask> iterator() {
        return internalList.iterator();
    }
    
    @Override
    public boolean equals(Object other) {
        return other == this // short circuit if same object
                || (other instanceof UniqueRsvTaskList // instanceof handles nulls
                && this.internalList.equals(
                ((UniqueRsvTaskList) other).internalList));
    }

    @Override
    public int hashCode() {
        return internalList.hashCode();
    }

}
```
###### \java\tars\model\task\TaskQuery.java
``` java
public class TaskQuery extends Task {

    private String tagQuery = "";
    private String statusString = "";
    public final static String MESSAGE_BOTH_STATUS_SEARCHED_ERROR =
            "Both '-do (Done)' and '-ud (Undone)' flags "
                    + "have been detected.\n"
                    + "Please search for either '-do (Done)' or '-ud (Undone)' status";

    public TaskQuery() {}

    public TaskQuery(Name name, DateTime dateTime, Priority priority,
            Status status, UniqueTagList tags) {
        super(name, dateTime, priority, status, tags);
    }

    /* --------------- SETTER METHODS -------------------- */

    public void createNameQuery(String nameQueryString)
            throws IllegalValueException {
        name = new Name(nameQueryString);
    }

    public void createDateTimeQuery(String[] dateTimeQueryString)
            throws DateTimeException, IllegalDateException {
        dateTime = new DateTime(dateTimeQueryString[0], dateTimeQueryString[1]);
    }

    public void createPriorityQuery(String priorityString)
            throws IllegalValueException {

        /*
         * To convert long versions of priority strings (i.e. high, medium, low) into characters
         * (i.e. h, m, l)
         */
        switch (priorityString) {
            case PRIORITY_HIGH:
                priorityString = PRIORITY_H;
                break;

            case PRIORITY_MEDIUM:
                priorityString = PRIORITY_M;
                break;

            case PRIORITY_LOW:
                priorityString = PRIORITY_L;
                break;

            default:
                break;
        }

        priority = new Priority(priorityString);
    }

    public void createStatusQuery(Boolean statusQuery) {
        status = new Status();
        status.status = statusQuery;
    }

    public void createTagsQuery(String tagQueryString) {
        tagQuery = tagQueryString;
    }

    /* --------------- GETTER METHODS -------------------- */

    public ArrayList<String> getNameKeywordsAsList() {
        return new ArrayList<String>(Arrays.asList(
                getName().taskName.split(StringUtil.STRING_WHITESPACE)));
    }

    public DateTime getDateTimeQueryRange() {
        if (getDateTime().getEndDate() != null) {
            return getDateTime();
        } else {
            return null;
        }
    }

    public ArrayList<String> getPriorityKeywordsAsList() {
        return new ArrayList<String>(Arrays.asList(priorityString()));
    }

    public String getStatusQuery() {
        if (status != null) {
            statusString = status.toString();
        }
        return statusString;
    }

    public ArrayList<String> getTagKeywordsAsList() {
        return new ArrayList<String>(
                Arrays.asList(tagQuery.split(StringUtil.STRING_WHITESPACE)));
    }

    @Override
    public String toString() {
        final StringBuilder builder = new StringBuilder();
        builder.append("Filter Search Keywords: ");

        if (!getName().toString().isEmpty()) {
            builder.append("[Task Name: ").append(getName()).append("] ");
        }
        if (getDateTime().getEndDate() != null) {
            builder.append("[DateTime: ").append(getDateTime()).append("] ");
        }
        if (!priorityString().isEmpty()) {
            builder.append("[Priority: ").append(priorityString()).append("] ");
        }
        if (!statusString.isEmpty()) {
            builder.append("[Status: ").append(statusString).append("] ");
        }
        if (!tagQuery.isEmpty()) {
            builder.append("[Tags: ").append(tagQuery).append("]");
        }

        return builder.toString();
    }

}
```
###### \java\tars\storage\Storage.java
``` java
    /**
     * Updates Tars Storage Directory
     * 
     * @param newFilePath
     * @param newConfig
     */
    void updateTarsStorageDirectory(String newFilePath, Config newConfig);
    
    void saveTarsInNewFilePath(ReadOnlyTars tars, String newFilePath) throws IOException;
    
    boolean isFileSavedSuccessfully(String filePath);
    
    Optional<ReadOnlyTars> readTarsFromNewFilePath(String newFilePath)
        throws DataConversionException, FileNotFoundException;
}
```
###### \java\tars\storage\StorageManager.java
``` java
    @Override
    public void saveTarsInNewFilePath(ReadOnlyTars tars, String newFilePath)
            throws IOException {
        tarsStorage = new XmlTarsStorage(newFilePath);
        tarsStorage.saveTars(tars, newFilePath);
    }

    public boolean isFileSavedSuccessfully(String filePath) {
        Path path = Paths.get(filePath);
        return Files.exists(path);
    }

    public void updateTarsStorageDirectory(String newFilePath,
            Config newConfig) {
        tarsStorage = new XmlTarsStorage(newFilePath);
        indicateTarsStorageDirectoryChanged(newFilePath, newConfig);
    }

    // Raise an event that the tars storage directory has changed
    private void indicateTarsStorageDirectoryChanged(String newFilePath,
            Config newConfig) {
        raise(new TarsStorageDirectoryChangedEvent(newFilePath, newConfig));
    }

```
###### \java\tars\ui\CommandBox.java
``` java
    private void setTextFieldKeyPressedHandler() {
        commandTextField.setOnKeyPressed(new EventHandler<KeyEvent>() {
            public void handle(KeyEvent ke) {
                if (ke.getCode().equals(KeyCode.UP)) {
                    setTextToShowPrevCmdText(ke);
                } else if (ke.getCode().equals(KeyCode.DOWN)) {
                    setTextToShowNextCmdText(ke);
                } else if (KeyCombinations.KEY_COMB_CTRL_RIGHT_ARROW
                        .match(ke)) {
                    raise(new KeyCombinationPressedEvent(
                            KeyCombinations.KEY_COMB_CTRL_RIGHT_ARROW));
                    ke.consume();
                } else if (KeyCombinations.KEY_COMB_CTRL_LEFT_ARROW.match(ke)) {
                    raise(new KeyCombinationPressedEvent(
                            KeyCombinations.KEY_COMB_CTRL_LEFT_ARROW));
                    ke.consume();
                } else if (KeyCombinations.KEY_COMB_CTRL_Z.match(ke)) {
                    handleUndoAndRedoKeyRequest(UndoCommand.COMMAND_WORD);
                } else if (KeyCombinations.KEY_COMB_CTRL_Y.match(ke)) {
                    handleUndoAndRedoKeyRequest(RedoCommand.COMMAND_WORD);
                }
            }
        });
    }

    private void setTextFieldValueHandler() {
        commandTextField.textProperty()
                .addListener((observable, oldValue, newValue) -> {
                    if (newValue.equals(RsvCommand.COMMAND_WORD)
                            || newValue.equals(ConfirmCommand.COMMAND_WORD)) {
                        raise(new CommandBoxTextFieldValueChangedEvent(
                                newValue));
                    }
                });

    }

```
###### \java\tars\ui\StatusBarFooter.java
``` java
    @Subscribe
    private void handleTarsStorageChangeDirectoryEvent(
            TarsStorageDirectoryChangedEvent event) {
        logger.info(LogsCenter.getEventHandlingLogMessage(event));
        setSaveLocation(String.format(LOG_MESSAGE_STORAGE_LOCATION_CHANGED,
                event.getNewFilePath()));
    }
}
```
