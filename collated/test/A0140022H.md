# A0140022H
###### \java\guitests\AddCommandTest.java
``` java
    @Test
    public void addRecurring() {
        TestTask[] recurringList = new TestTask[0];
        recurringList = TestUtil.addTasksToList(recurringList, td.taskC, td.taskD);
        try {
            recurringList[1].setName(new Name("Task C"));
            recurringList[1].setPriority(new Priority("l"));
        } catch (IllegalValueException e) {
            e.printStackTrace();
        }

        commandBox.runCommand("clear");
        commandBox.runCommand("add Task C /dt 03/09/2016 1400 to 04/09/2016 1400 /p l /r 2 every day");
        assertTrue(taskListPanel.isListMatching(recurringList));
    }
}
```
###### \java\guitests\ListCommandTest.java
``` java
 */
public class ListCommandTest extends TarsGuiTest{
	
	TestTask[] currentList = td.getTypicalTasks();;
	
	@Test
	public void listAllTask() {
		TestTask[] expectedList = currentList;
		commandBox.runCommand("ls");
		assertTrue(taskListPanel.isListMatching(expectedList));
		assertResultMessage(MESSAGE_SUCCESS);
	}
	
	@Test
	public void listAllTaskByDateTime() {
		TestTask[] expectedList = currentList;
		commandBox.runCommand("ls /dt");
		assertTrue(taskListPanel.isListMatching(expectedList));
		assertResultMessage(MESSAGE_SUCCESS_DATETIME);
	}
	
	@Test
	public void listAllTaskByDateTimeDescending() {
		TestTask[] expectedList = {td.taskG, td.taskF, td.taskE, td.taskD, td.taskC, td.taskB, td.taskA};
		commandBox.runCommand("ls /dt dsc");
		assertTrue(taskListPanel.isListMatching(expectedList));
		assertResultMessage(MESSAGE_SUCCESS_DATETIME_DESCENDING);
	}
	
	@Test
	public void listAllTaskByPriority() {
		TestTask[] expectedList = {td.taskC, td.taskF, td.taskB, td.taskE, td.taskA, td.taskD, td.taskG};
		commandBox.runCommand("ls /p");
		assertTrue(taskListPanel.isListMatching(expectedList));
		assertResultMessage(MESSAGE_SUCCESS_PRIORITY);
	}
	
	@Test
	public void listAllTaskByPriorityDescending() {
		TestTask[] expectedList = {td.taskA, td.taskD, td.taskG, td.taskB, td.taskE, td.taskC, td.taskF};
		commandBox.runCommand("ls /p dsc");
		assertTrue(taskListPanel.isListMatching(expectedList));
		assertResultMessage(MESSAGE_SUCCESS_PRIORITY_DESCENDING);
	}
	
	@Test
	public void listInvalidCommand() {
		//TestTask[] expectedList = {td.taskA, td.taskB, td.taskC, td.taskD, td.taskE, td.taskF};
		TestTask[] expectedList = currentList;
		commandBox.runCommand("ls /r");
		assertTrue(taskListPanel.isListMatching(expectedList));
		assertResultMessage(String.format(MESSAGE_INVALID_COMMAND_FORMAT, MESSAGE_USAGE));
	}
}
```
###### \java\tars\commons\util\DateTimeUtilTest.java
``` java
    @Test
    public void modifyDate() {
        String dateToModify = "06/09/2016 2200";

        String frequencyDay = "day";
        String frequencyWeek = "week";
        String frequencyMonth = "month";
        String frequencyYear = "year";

        String expectedDay = "07/09/2016 2200";
        String expectedWeek = "13/09/2016 2200";
        String expectedMonth = "06/10/2016 2200";
        String expectedYear = "06/09/2017 2200";

        String modifiedDay = DateTimeUtil.modifyDate(dateToModify, frequencyDay);
        String modifiedWeek = DateTimeUtil.modifyDate(dateToModify, frequencyWeek);
        String modifiedMonth = DateTimeUtil.modifyDate(dateToModify, frequencyMonth);
        String modifiedYear = DateTimeUtil.modifyDate(dateToModify, frequencyYear);

        assertEquals(expectedDay, modifiedDay);
        assertEquals(expectedWeek, modifiedWeek);
        assertEquals(expectedMonth, modifiedMonth);
        assertEquals(expectedYear, modifiedYear);
    }

    @Test
    public void isWithinWeek_dateTimeNullValue_returnFalse() {
        LocalDateTime nullDateTime = null;
        assertFalse(DateTimeUtil.isWithinWeek(nullDateTime));
    }

    @Test
    public void isWithinWeek_dateTimeWithinWeek_returnTrue() {
        LocalDateTime today = LocalDateTime.now();
        assertTrue(DateTimeUtil.isWithinWeek(today));
    }

    @Test
    public void isWithinWeek_dateTimeNotWithinWeek_returnFalse() {
        LocalDateTime nextMonth = LocalDateTime.now().plus(1, ChronoUnit.MONTHS);
        LocalDateTime lastMonth = LocalDateTime.now().minus(1, ChronoUnit.MONTHS);
        assertFalse(DateTimeUtil.isWithinWeek(nextMonth));
        assertFalse(DateTimeUtil.isWithinWeek(lastMonth));
    }

    @Test
    public void isOverDue_dateTimeNullValue_returnFalse() {
        LocalDateTime nullDateTime = null;
        assertFalse(DateTimeUtil.isOverDue(nullDateTime));
    }

    @Test
    public void isOverDue_dateTimeOverDue_returnTrue() {
        LocalDateTime yesterday = LocalDateTime.now().minus(1, ChronoUnit.DAYS);
        assertTrue(DateTimeUtil.isOverDue(yesterday));
    }

    @Test
    public void isOverDue_dateTimeNotOverDue_returnFalse() {
        LocalDateTime tomorrow = LocalDateTime.now().plus(1, ChronoUnit.DAYS);
        assertFalse(DateTimeUtil.isOverDue(tomorrow));
    }

    @Test
    public void isDateTimeWithinRange_emptyDateTimeSource() throws DateTimeException, IllegalDateException {
        DateTime dateTimeSource = new DateTime("", "");
        DateTime dateTimeQuery = new DateTime("17/01/2016 1200", "18/01/2016 1200");
        assertFalse(DateTimeUtil.isDateTimeWithinRange(dateTimeSource, dateTimeQuery));
    }

    @Test
    public void isDateTimeWithinRange_dateTimeOutOfRange() throws DateTimeException, IllegalDateException {
        DateTime dateTimeSource = new DateTime("15/01/2016 1200", "16/01/2016 1200");
        DateTime dateTimeSource2 = new DateTime("19/01/2016 1200", "20/01/2016 1200");
        DateTime dateTimeQuery = new DateTime("17/01/2016 1200", "18/01/2016 1200");

        assertFalse(DateTimeUtil.isDateTimeWithinRange(dateTimeSource, dateTimeQuery));
        assertFalse(DateTimeUtil.isDateTimeWithinRange(dateTimeSource2, dateTimeQuery));
    }

    @Test
    public void isDateTimeWithinRange_dateTimeWithinRange() throws DateTimeException, IllegalDateException {
        DateTime dateTimeSource = new DateTime("14/01/2016 1200", "16/01/2016 1200");
        DateTime dateTimeQueryFullyInRange = new DateTime("14/01/2016 2000", "15/01/2016 1200");
        DateTime dateTimeQueryPartiallyInRange = new DateTime("13/01/2016 1000", "15/01/2016 1200");

        assertTrue(DateTimeUtil.isDateTimeWithinRange(dateTimeSource, dateTimeQueryFullyInRange));
        assertTrue(DateTimeUtil.isDateTimeWithinRange(dateTimeSource, dateTimeQueryPartiallyInRange));
    }

    @Test
    public void isDateTimeWithinRange_dateTimeWithoutStartDate() throws DateTimeException, IllegalDateException {
        DateTime dateTimeSource = new DateTime("15/01/2016 1200", "17/01/2016 1100");
        DateTime dateTimeSourceWithoutStartDate = new DateTime("", "16/01/2016 1200");
        DateTime dateTimeQuery = new DateTime("14/01/2016 2000", "17/01/2016 1200");
        DateTime dateTimeQueryWithoutStartDate = new DateTime("", "16/01/2016 1200");
        DateTime dateTimeQueryWithoutStartDate2 = new DateTime("", "18/01/2016 1200");

        assertTrue(DateTimeUtil.isDateTimeWithinRange(dateTimeSource, dateTimeQuery));
        assertFalse(DateTimeUtil.isDateTimeWithinRange(dateTimeSource, dateTimeQueryWithoutStartDate2));
        assertTrue(DateTimeUtil.isDateTimeWithinRange(dateTimeSourceWithoutStartDate, dateTimeQuery));
        assertTrue(DateTimeUtil.isDateTimeWithinRange(dateTimeSourceWithoutStartDate, dateTimeQueryWithoutStartDate));
        assertFalse(DateTimeUtil.isDateTimeWithinRange(dateTimeSourceWithoutStartDate, dateTimeQueryWithoutStartDate2));
    }

}
```
###### \java\tars\logic\LogicManagerTest.java
``` java
     */
    private void assertCommandBehaviorForList(String inputCommand, String expectedMessage, ReadOnlyTars expectedTars,
            List<? extends ReadOnlyTask> expectedShownList) throws Exception {

        // Execute the command
        CommandResult result = logic.execute(inputCommand);

        // Confirm the ui display elements should contain the right data
        assertEquals(expectedMessage, result.feedbackToUser);
        assertEquals(expectedShownList, model.getFilteredTaskList());

        // Confirm the state of data (saved and in-memory) is as expected
        assertEquals(expectedTars, latestSavedTars);
    }

    private void assertCommandBehaviorWithRsvTaskList(String inputCommand, String expectedMessage,
            ReadOnlyTars expectedTars, List<? extends ReadOnlyTask> expectedShownTaskList,
            List<? extends RsvTask> expectedShownRsvTaskList) throws Exception {

        // Execute the command
        CommandResult result = logic.execute(inputCommand);

        // Confirm the ui display elements should contain the right data
        assertEquals(expectedMessage, result.feedbackToUser);
        assertEquals(expectedShownTaskList, model.getFilteredTaskList());
        assertEquals(expectedShownRsvTaskList, model.getFilteredRsvTaskList());

        // Confirm the state of data (saved and in-memory) is as expected
        assertEquals(expectedTars, model.getTars());
        assertEquals(expectedTars, latestSavedTars);

    }

    @Test
    public void execute_unknownCommandWord() throws Exception {
        String unknownCommand = "uicfhmowqewca";
        assertCommandBehavior(unknownCommand, MESSAGE_UNKNOWN_COMMAND);
    }

    @Test
    public void execute_help() throws Exception {
        assertCommandBehavior("help", HelpCommand.SHOWING_HELP_MESSAGE);
        assertTrue(helpShown);
    }

    @Test
    public void execute_exit() throws Exception {
        assertCommandBehavior("exit", ExitCommand.MESSAGE_EXIT_ACKNOWLEDGEMENT);
    }

    @Test
    public void execute_clear() throws Exception {
        TestDataHelper helper = new TestDataHelper();
        model.addTask(helper.generateTask(1));
        model.addTask(helper.generateTask(2));
        model.addTask(helper.generateTask(3));

        assertCommandBehavior("clear", ClearCommand.MESSAGE_SUCCESS, new Tars(), Collections.emptyList());
    }

    // ---------------- Tests for empty undo history ----------------

    @Test
    public void execute_undo_emptyCmdHistStack() throws Exception {
        assertCommandBehavior(UndoCommand.COMMAND_WORD, UndoCommand.MESSAGE_EMPTY_UNDO_CMD_HIST);
    }

    // ---------------- Tests for empty redo history ----------------

    @Test
    public void execute_redo_emptyCmdHistStack() throws Exception {
        assertCommandBehavior(RedoCommand.COMMAND_WORD, RedoCommand.MESSAGE_EMPTY_REDO_CMD_HIST);
    }

    // ---------------- Tests for undo and redo command ----------------

    @Test
    public void execute_undo_and_redo_add_successful() throws Exception {
        // setup expectations
        TestDataHelper helper = new TestDataHelper();
        Task toBeAdded = helper.meetAdam();
        Tars expectedTars = new Tars();
        expectedTars.addTask(toBeAdded);

        // execute command and verify result
        assertCommandBehavior(helper.generateAddCommand(toBeAdded),
                String.format(AddCommand.MESSAGE_SUCCESS, toBeAdded + "\n"), expectedTars,
                expectedTars.getTaskList());

        expectedTars.removeTask(toBeAdded);

        assertCommandBehavior(UndoCommand.COMMAND_WORD,
                String.format(UndoCommand.MESSAGE_SUCCESS,
                        String.format(AddCommand.MESSAGE_UNDO, toBeAdded)),
                expectedTars, expectedTars.getTaskList());

        expectedTars.addTask(toBeAdded);

        assertCommandBehavior(RedoCommand.COMMAND_WORD,
                String.format(RedoCommand.MESSAGE_SUCCESS,
                        String.format(AddCommand.MESSAGE_SUCCESS, toBeAdded + "\n")),
                expectedTars, expectedTars.getTaskList());
    }

    @Test
    public void execute_undo_and_redo_add_unsuccessful() throws Exception {
        // setup expectations
        TestDataHelper helper = new TestDataHelper();
        Task toBeAdded = helper.meetAdam();
        Tars expectedTars = new Tars();
        expectedTars.addTask(toBeAdded);

        // execute command and verify result
        assertCommandBehavior(helper.generateAddCommand(toBeAdded),
                String.format(AddCommand.MESSAGE_SUCCESS, toBeAdded + "\n"), expectedTars,
                expectedTars.getTaskList());

        expectedTars.removeTask(toBeAdded);
        model.deleteTask(toBeAdded);

        assertCommandBehavior(UndoCommand.COMMAND_WORD,
                String.format(UndoCommand.MESSAGE_UNSUCCESS, MESSAGE_TASK_CANNOT_BE_FOUND),
                expectedTars, expectedTars.getTaskList());

        model.addTask(toBeAdded);
        expectedTars.addTask(toBeAdded);

        assertCommandBehavior(RedoCommand.COMMAND_WORD,
                String.format(RedoCommand.MESSAGE_UNSUCCESS, MESSAGE_DUPLICATE_TASK), expectedTars,
                expectedTars.getTaskList());
    }

    @Test
    public void execute_undo_and_redo_delete_successful() throws Exception {
        // setup expectations
        TestDataHelper helper = new TestDataHelper();
        Task toBeRemoved = helper.meetAdam();
        Tars expectedTars = new Tars();
        expectedTars.addTask(toBeRemoved);

        // execute command and verify result
        assertCommandBehavior(helper.generateAddCommand(toBeRemoved),
                String.format(AddCommand.MESSAGE_SUCCESS, toBeRemoved + "\n"), expectedTars,
                expectedTars.getTaskList());

        expectedTars.removeTask(toBeRemoved);

        // execute command and verify result
        assertCommandBehavior("del 1",
                String.format(DeleteCommand.MESSAGE_DELETE_TASK_SUCCESS, toBeRemoved), expectedTars,
                expectedTars.getTaskList());

        expectedTars.addTask(toBeRemoved);

        assertCommandBehavior(UndoCommand.COMMAND_WORD,
                String.format(UndoCommand.MESSAGE_SUCCESS,
                        String.format(DeleteCommand.MESSAGE_UNDO, toBeRemoved)),
                expectedTars, expectedTars.getTaskList());

        expectedTars.removeTask(toBeRemoved);

        assertCommandBehavior(RedoCommand.COMMAND_WORD,
                String.format(RedoCommand.MESSAGE_SUCCESS,
                        String.format(DeleteCommand.MESSAGE_REDO, toBeRemoved)),
                expectedTars, expectedTars.getTaskList());
    }

    @Test
    public void execute_undo_and_redo_delete_unsuccessful() throws Exception {
        // setup expectations
        TestDataHelper helper = new TestDataHelper();
        Task toBeRemoved = helper.meetAdam();
        Tars expectedTars = new Tars();
        expectedTars.addTask(toBeRemoved);

        // execute command and verify result
        assertCommandBehavior(helper.generateAddCommand(toBeRemoved),
                String.format(AddCommand.MESSAGE_SUCCESS, toBeRemoved + "\n"), expectedTars,
                expectedTars.getTaskList());

        expectedTars.removeTask(toBeRemoved);

        // execute command and verify result
        assertCommandBehavior("del 1",
                String.format(DeleteCommand.MESSAGE_DELETE_TASK_SUCCESS, toBeRemoved), expectedTars,
                expectedTars.getTaskList());

        expectedTars.addTask(toBeRemoved);
        model.addTask(toBeRemoved);

        assertCommandBehavior(UndoCommand.COMMAND_WORD,
                String.format(UndoCommand.MESSAGE_UNSUCCESS,
                        String.format(DeleteCommand.MESSAGE_UNDO, toBeRemoved)),
                expectedTars, expectedTars.getTaskList());

        expectedTars.removeTask(toBeRemoved);
        model.deleteTask(toBeRemoved);

        assertCommandBehavior(RedoCommand.COMMAND_WORD,
                String.format(RedoCommand.MESSAGE_UNSUCCESS, MESSAGE_TASK_CANNOT_BE_FOUND),
                expectedTars, expectedTars.getTaskList());
    }

    @Test
    public void execute_undo_and_redo_edit_successful() throws Exception {
        // setup expectations
        TestDataHelper helper = new TestDataHelper();
        Task taskToAdd = helper.meetAdam();
        Tars expectedTars = new Tars();
        expectedTars.addTask(taskToAdd);

        // edit task
        String args =
                " /n Meet Betty Green /dt 20/09/2016 1800 to 21/09/2016 1800 /p h /ta tag3 /tr tag2";

        ArgumentTokenizer argsTokenizer = new ArgumentTokenizer(namePrefix, priorityPrefix,
                dateTimePrefix, addTagPrefix, removeTagPrefix);
        argsTokenizer.tokenize(args);

        model.addTask(taskToAdd);
        Task editedTask = expectedTars.editTask(taskToAdd, argsTokenizer);

        String inputCommand = "edit 1 /n Meet Betty Green /dt 20/09/2016 1800 "
                + "to 21/09/2016 1800 /p h /tr tag2 /ta tag3";

        // execute command
        assertCommandBehavior(inputCommand,
                String.format(EditCommand.MESSAGE_EDIT_TASK_SUCCESS, editedTask), expectedTars,
                expectedTars.getTaskList());

        expectedTars.replaceTask(editedTask, taskToAdd);

        assertCommandBehavior(UndoCommand.COMMAND_WORD,
                String.format(UndoCommand.MESSAGE_SUCCESS,
                        String.format(EditCommand.MESSAGE_UNDO, taskToAdd)),
                expectedTars, expectedTars.getTaskList());

        expectedTars.replaceTask(taskToAdd, editedTask);

        assertCommandBehavior(RedoCommand.COMMAND_WORD,
                String.format(RedoCommand.MESSAGE_SUCCESS,
                        String.format(EditCommand.MESSAGE_REDO, taskToAdd)),
                expectedTars, expectedTars.getTaskList());
    }

    @Test
    public void execute_undo_and_redo_rsv_successful() throws Exception {
        // setup expectations
        TestDataHelper helper = new TestDataHelper();
        RsvTask taskToRsv = helper.generateReservedTaskWithOneDateTimeOnly("Reserved Task");
        Tars expectedTars = new Tars();
        expectedTars.addRsvTask(taskToRsv);

        String inputCommand = "rsv Reserved Task /dt 05/09/2016 1400 to 06/09/2016 2200";

        // execute command
        assertCommandBehavior(inputCommand, String.format(RsvCommand.MESSAGE_SUCCESS, taskToRsv),
                expectedTars, expectedTars.getTaskList());

        expectedTars.removeRsvTask(taskToRsv);

        assertCommandBehavior(UndoCommand.COMMAND_WORD,
                String.format(UndoCommand.MESSAGE_SUCCESS,
                        String.format(RsvCommand.MESSAGE_UNDO_ADD, taskToRsv)),
                expectedTars, expectedTars.getTaskList());

        expectedTars.addRsvTask(taskToRsv);

        assertCommandBehavior(RedoCommand.COMMAND_WORD,
                String.format(RedoCommand.MESSAGE_SUCCESS,
                        String.format(RsvCommand.MESSAGE_REDO_ADD, taskToRsv)),
                expectedTars, expectedTars.getTaskList());

    }

    @Test
    public void execute_undo_and_redo_rsv_unsuccessful() throws Exception {
        // setup expectations
        TestDataHelper helper = new TestDataHelper();
        RsvTask taskToRsv = helper.generateReservedTaskWithOneDateTimeOnly("Reserved Task");
        Tars expectedTars = new Tars();
        expectedTars.addRsvTask(taskToRsv);

        String inputCommand = "rsv Reserved Task /dt 05/09/2016 1400 to 06/09/2016 2200";

        // execute command
        assertCommandBehavior(inputCommand, String.format(RsvCommand.MESSAGE_SUCCESS, taskToRsv),
                expectedTars, expectedTars.getTaskList());

        model.deleteRsvTask(taskToRsv);
        expectedTars.removeRsvTask(taskToRsv);

        assertCommandBehavior(UndoCommand.COMMAND_WORD,
                String.format(UndoCommand.MESSAGE_UNSUCCESS, MESSAGE_RSV_TASK_CANNOT_BE_FOUND),
                expectedTars, expectedTars.getTaskList());

        model.addRsvTask(taskToRsv);
        expectedTars.addRsvTask(taskToRsv);

        assertCommandBehavior(RedoCommand.COMMAND_WORD,
                String.format(RedoCommand.MESSAGE_UNSUCCESS, MESSAGE_DUPLICATE_TASK), expectedTars,
                expectedTars.getTaskList());
        
    }

    @Test
    public void execute_undo_and_redo_rsv_del_successful() throws Exception {
        // setup expectations
        TestDataHelper helper = new TestDataHelper();
        RsvTask taskToRsv = helper.generateReservedTaskWithOneDateTimeOnly("Reserved Task");
        Tars expectedTars = new Tars();

        // setup model
        model.addRsvTask(taskToRsv);

        String inputCommand = "rsv /del 1";

        // execute command
        assertCommandBehavior(inputCommand,
                String.format(RsvCommand.MESSAGE_SUCCESS_DEL, taskToRsv), expectedTars,
                expectedTars.getTaskList());

        expectedTars.addRsvTask(taskToRsv);

        assertCommandBehavior(UndoCommand.COMMAND_WORD,
                String.format(UndoCommand.MESSAGE_SUCCESS,
                        String.format(RsvCommand.MESSAGE_UNDO_DELETE, taskToRsv)),
                expectedTars, expectedTars.getTaskList());

        expectedTars.removeRsvTask(taskToRsv);

        assertCommandBehavior(RedoCommand.COMMAND_WORD,
                String.format(RedoCommand.MESSAGE_SUCCESS,
                        String.format(RsvCommand.MESSAGE_REDO_DELETE, taskToRsv)),
                expectedTars, expectedTars.getTaskList());
        
    }

    @Test
    public void execute_undo_and_redo_rsv_del_unsuccessful() throws Exception {
        // setup expectations
        TestDataHelper helper = new TestDataHelper();
        RsvTask taskToRsv = helper.generateReservedTaskWithOneDateTimeOnly("Reserved Task");
        Tars expectedTars = new Tars();

        // setup model
        model.addRsvTask(taskToRsv);

        String inputCommand = "rsv /del 1";

        // execute command
        assertCommandBehavior(inputCommand,
                String.format(RsvCommand.MESSAGE_SUCCESS_DEL, taskToRsv), expectedTars,
                expectedTars.getTaskList());

        model.addRsvTask(taskToRsv);
        expectedTars.addRsvTask(taskToRsv);

        assertCommandBehavior(UndoCommand.COMMAND_WORD,
                String.format(UndoCommand.MESSAGE_UNSUCCESS, MESSAGE_DUPLICATE_TASK), expectedTars,
                expectedTars.getTaskList());

        model.deleteRsvTask(taskToRsv);
        expectedTars.removeRsvTask(taskToRsv);

        assertCommandBehavior(RedoCommand.COMMAND_WORD,
                String.format(RedoCommand.MESSAGE_UNSUCCESS, MESSAGE_RSV_TASK_CANNOT_BE_FOUND),
                expectedTars, expectedTars.getTaskList());
        
    }

    @Test
    public void execute_undo_and_redo_confirm_successful() throws Exception {
        // setup expectations
        TestDataHelper helper = new TestDataHelper();
        RsvTask taskToRsv = helper.generateReservedTaskWithOneDateTimeOnly("Reserved Task");
        Task taskToConfirm = helper.generateTaskWithName("Reserved Task");
        Tars expectedTars = new Tars();
        expectedTars.addTask(taskToConfirm);

        // setup model
        model.addRsvTask(taskToRsv);

        String inputCommand = "confirm 1 1 /p h /t tag";

        // execute command
        assertCommandBehavior(inputCommand,
                String.format(ConfirmCommand.MESSAGE_CONFIRM_SUCCESS, taskToConfirm), expectedTars,
                expectedTars.getTaskList());

        expectedTars.removeTask(taskToConfirm);
        expectedTars.addRsvTask(taskToRsv);

        assertCommandBehavior(UndoCommand.COMMAND_WORD, String.format(UndoCommand.MESSAGE_SUCCESS, ""), expectedTars,
                expectedTars.getTaskList());

        expectedTars.addTask(taskToConfirm);
        expectedTars.removeRsvTask(taskToRsv);

        assertCommandBehavior(RedoCommand.COMMAND_WORD, String.format(RedoCommand.MESSAGE_SUCCESS, ""), expectedTars,
                expectedTars.getTaskList());

    }

    @Test
    public void execute_undo_and_redo_confirm_unsuccessful() throws Exception {
        // setup expectations
        TestDataHelper helper = new TestDataHelper();
        RsvTask taskToRsv = helper.generateReservedTaskWithOneDateTimeOnly("Reserved Task");
        Task taskToConfirm = helper.generateTaskWithName("Reserved Task");
        Tars expectedTars = new Tars();
        expectedTars.addTask(taskToConfirm);

        // setup model
        model.addRsvTask(taskToRsv);

        String inputCommand = "confirm 1 1 /p h /t tag";

        // execute command
        assertCommandBehavior(inputCommand,
                String.format(ConfirmCommand.MESSAGE_CONFIRM_SUCCESS, taskToConfirm), expectedTars,
                expectedTars.getTaskList());

        model.addRsvTask(taskToRsv);
        expectedTars.addRsvTask(taskToRsv);

        assertCommandBehavior(UndoCommand.COMMAND_WORD,
                String.format(UndoCommand.MESSAGE_UNSUCCESS, MESSAGE_DUPLICATE_TASK), expectedTars,
                expectedTars.getTaskList());

        model.deleteRsvTask(taskToRsv);
        expectedTars.removeRsvTask(taskToRsv);

        assertCommandBehavior(RedoCommand.COMMAND_WORD,
                String.format(RedoCommand.MESSAGE_UNSUCCESS, MESSAGE_RSV_TASK_CANNOT_BE_FOUND),
                expectedTars, expectedTars.getTaskList());

    }

    // ---------------- Tests for add command ----------------

    @Test
    public void execute_add_invalidArgsFormat() throws Exception {
        String expectedMessage = String.format(MESSAGE_INVALID_COMMAND_FORMAT, AddCommand.MESSAGE_USAGE);
        assertCommandBehavior("add /dt 22/04/2016 1400 to 23/04/2016 2200 /p h Valid Task Name", expectedMessage);
        assertCommandBehavior("add", expectedMessage);
    }

    @Test
    public void execute_add_invalidTaskData() throws Exception {
        assertCommandBehavior("add []\\[;] /dt 05/09/2016 1400 to 06/09/2016 2200 /p m", Name.MESSAGE_NAME_CONSTRAINTS);
        assertCommandBehavior("add name - hello world /dt 05/09/2016 1400 to 06/09/2016 2200 /p m",
                Name.MESSAGE_NAME_CONSTRAINTS);
        assertCommandBehavior("add Valid Task Name /dt @@@notAValidDate@@@ -p m", MESSAGE_INVALID_DATE);
        assertCommandBehavior("add Valid Task Name /dt 05/09/2016 1400 to 01/09/2016 2200 /p m",
                MESSAGE_INVALID_END_DATE);
        assertCommandBehavior("add Valid Task Name /dt 05/09/2016 1400 to 06/09/2016 2200 /p medium",
                Priority.MESSAGE_PRIORITY_CONSTRAINTS);
        assertCommandBehavior("add Valid Task Name /dt 05/09/2016 1400 to 06/09/2016 2200 /p m /t invalid_-[.tag",
                Tag.MESSAGE_TAG_CONSTRAINTS);

    }

    @Test
    public void execute_add_successful() throws Exception {
        // setup expectations
        TestDataHelper helper = new TestDataHelper();
        Task toBeAdded = helper.meetAdam();
        Tars expectedTars = new Tars();
        expectedTars.addTask(toBeAdded);

        // execute command and verify result
        assertCommandBehavior(helper.generateAddCommand(toBeAdded),
                String.format(AddCommand.MESSAGE_SUCCESS, toBeAdded + "\n"), expectedTars, expectedTars.getTaskList());
    }

    @Test
    public void execute_add_end_date_successful() throws Exception {
        TestDataHelper helper = new TestDataHelper();
        Task toBeAdded = helper.generateTaskWithEndDateOnly("Jane");
        Tars expectedTars = new Tars();
        expectedTars = new Tars();
        expectedTars.addTask(toBeAdded);

        // execute command and verify result
        assertCommandBehavior(helper.generateAddCommand(toBeAdded),
                String.format(AddCommand.MESSAGE_SUCCESS, toBeAdded + "\n"), expectedTars, expectedTars.getTaskList());
    }

    @Test
    public void execute_add_float_successful() throws Exception {
        // setup expectations
        TestDataHelper helper = new TestDataHelper();
        Task toBeAdded = helper.floatTask();
        Tars expectedTars = new Tars();
        expectedTars.addTask(toBeAdded);

        // execute command and verify result
        assertCommandBehavior(helper.generateAddCommand(toBeAdded),
                String.format(AddCommand.MESSAGE_SUCCESS, toBeAdded + "\n"), expectedTars, expectedTars.getTaskList());

    }

    @Test
    public void execute_add_empty_task_name_invalid_format() throws Exception {
        assertCommandBehavior("add ",
                String.format(String.format(MESSAGE_INVALID_COMMAND_FORMAT, AddCommand.MESSAGE_USAGE)));
    }

    // ---------------- Tests for tag command ----------------

    @Test
    public void execute_invalid_tag_prefix() throws Exception {
        assertCommandBehavior("tag /gg", String.format(MESSAGE_INVALID_COMMAND_FORMAT, TagCommand.MESSAGE_USAGE));
    }

    @Test
    public void execute_tag_unsuccessful() throws Exception {
        // setup expectations
        TestDataHelper helper = new TestDataHelper();
        Task toBeAdded = helper.meetAdam();
        Tars expectedAB = new Tars();
        expectedAB.addTask(toBeAdded);

        model.addTask(toBeAdded);

        assertCommandBehavior("tag abcde", String.format(MESSAGE_INVALID_COMMAND_FORMAT, TagCommand.MESSAGE_USAGE),
                expectedAB, expectedAB.getTaskList());

        assertCommandBehavior("tag /e 1 INVALID_TAG_NAME", Tag.MESSAGE_TAG_CONSTRAINTS, expectedAB,
                expectedAB.getTaskList());
    }

    @Test
    public void execute_tag_invalid_index() throws Exception {
        // EP: negative number
        assertCommandBehavior("tag /e -1 VALIDTASKNAME",
                String.format(MESSAGE_INVALID_COMMAND_FORMAT, TagCommand.MESSAGE_USAGE));

        assertCommandBehavior("tag /del -1", MESSAGE_INVALID_TAG_DISPLAYED_INDEX);

        // EP: zero
        assertCommandBehavior("tag /e 0 VALIDTASKNAME", MESSAGE_INVALID_TAG_DISPLAYED_INDEX);
        assertCommandBehavior("tag /del 0", MESSAGE_INVALID_TAG_DISPLAYED_INDEX);

        // EP: signed number
        assertCommandBehavior("tag /e +1 VALIDTASKNAME",
                String.format(MESSAGE_INVALID_COMMAND_FORMAT, TagCommand.MESSAGE_USAGE));
        assertCommandBehavior("tag /e -2 VALIDTASKNAME",
                String.format(MESSAGE_INVALID_COMMAND_FORMAT, TagCommand.MESSAGE_USAGE));
        assertCommandBehavior("tag /del +1", MESSAGE_INVALID_TAG_DISPLAYED_INDEX);
        assertCommandBehavior("tag /del -1", MESSAGE_INVALID_TAG_DISPLAYED_INDEX);

        // EP: invalid number
        assertCommandBehavior("tag /del aaa", String.format(MESSAGE_INVALID_COMMAND_FORMAT, TagCommand.MESSAGE_USAGE));
        assertCommandBehavior("tag /del bbb", String.format(MESSAGE_INVALID_COMMAND_FORMAT, TagCommand.MESSAGE_USAGE));
    }

    @Test
    public void execute_tag_empty_parameters() throws Exception {
        // setup expectations
        TestDataHelper helper = new TestDataHelper();
        Task toBeAdded = helper.meetAdam();
        Tars expectedAB = new Tars();
        expectedAB.addTask(toBeAdded);

        model.addTask(toBeAdded);

        // EP: empty parameters
        assertCommandBehavior("tag", String.format(MESSAGE_INVALID_COMMAND_FORMAT, TagCommand.MESSAGE_USAGE),
                expectedAB, expectedAB.getTaskList());
        assertCommandBehavior("tag  ", String.format(MESSAGE_INVALID_COMMAND_FORMAT, TagCommand.MESSAGE_USAGE),
                expectedAB, expectedAB.getTaskList());
        assertCommandBehavior("tag -e", String.format(MESSAGE_INVALID_COMMAND_FORMAT, TagCommand.MESSAGE_USAGE),
                expectedAB, expectedAB.getTaskList());
        assertCommandBehavior("tag -e  ", String.format(MESSAGE_INVALID_COMMAND_FORMAT, TagCommand.MESSAGE_USAGE),
                expectedAB, expectedAB.getTaskList());
        assertCommandBehavior("tag -del", String.format(MESSAGE_INVALID_COMMAND_FORMAT, TagCommand.MESSAGE_USAGE),
                expectedAB, expectedAB.getTaskList());
        assertCommandBehavior("tag -del  ", String.format(MESSAGE_INVALID_COMMAND_FORMAT, TagCommand.MESSAGE_USAGE),
                expectedAB, expectedAB.getTaskList());
    }

    @Test
    public void execute_tag_listing_successful() throws Exception {
        // setup expectations
        TestDataHelper helper = new TestDataHelper();
        Task toBeAdded = helper.meetAdam();
        Tars expectedAB = new Tars();
        expectedAB.addTask(toBeAdded);

        model.addTask(toBeAdded);

        // execute command and verify result
        assertCommandBehavior("tag /ls", new Formatter().formatTags(model.getUniqueTagList()), expectedAB,
                expectedAB.getTaskList());
    }

    @Test
    public void execute_tag_rename_successful() throws Exception {
        // setup expectations
        TestDataHelper helper = new TestDataHelper();
        Task toBeAdded = helper.meetAdam();
        Tars expectedAB = new Tars();
        expectedAB.addTask(toBeAdded);

        model.addTask(toBeAdded);

        ReadOnlyTag toBeRename = expectedAB.getUniqueTagList().getInternalList().get(0);
        Tag newTag = new Tag("tag3");

        expectedAB.getUniqueTagList().update(toBeRename, newTag);
        expectedAB.renameTag(toBeRename, newTag);

        // execute command and verify result
        assertCommandBehavior("tag /e 1 tag3",
                String.format(String.format(TagCommand.MESSAGE_RENAME_TAG_SUCCESS, "tag1", "tag3")), expectedAB,
                expectedAB.getTaskList());
    }

    @Test
    public void execute_tag_rename_duplicate() throws Exception {
        // setup expectations
        TestDataHelper helper = new TestDataHelper();
        Task toBeAdded = helper.meetAdam();
        Tars expectedAB = new Tars();
        expectedAB.addTask(toBeAdded);

        model.addTask(toBeAdded);

        // execute command and verify result
        assertCommandBehavior("tag /e 1 tag2", MESSAGE_DUPLICATE_TAG, expectedAB, expectedAB.getTaskList());
    }

    @Test
    public void execute_tag_rename_invalidIndex() throws Exception {
        // setup expectations
        TestDataHelper helper = new TestDataHelper();
        Task toBeAdded = helper.meetAdam();
        Tars expectedAB = new Tars();
        expectedAB.addTask(toBeAdded);

        model.addTask(toBeAdded);

        // execute command and verify result
        assertCommandBehavior("tag /e 3 VALIDTAGNAME", String.format(MESSAGE_INVALID_TAG_DISPLAYED_INDEX), expectedAB,
                expectedAB.getTaskList());

        assertCommandBehavior("tag /e 4 VALIDTAGNAME", String.format(MESSAGE_INVALID_TAG_DISPLAYED_INDEX), expectedAB,
                expectedAB.getTaskList());
    }

    @Test
    public void execute_tag_del_successful() throws Exception {
        // setup expectations
        TestDataHelper helper = new TestDataHelper();
        Task toBeAdded = helper.meetAdam();
        Tars expectedAB = new Tars();
        expectedAB.addTask(toBeAdded);

        model.addTask(toBeAdded);

        ReadOnlyTag toBeDeleted = expectedAB.getUniqueTagList().getInternalList().get(0);

        expectedAB.getUniqueTagList().remove(new Tag(toBeDeleted));
        expectedAB.deleteTag(toBeDeleted);

        // execute command and verify result
        assertCommandBehavior("tag /del 1", String.format(TagCommand.MESSAGE_DELETE_TAG_SUCCESS, toBeDeleted),
                expectedAB, expectedAB.getTaskList());
    }

    @Test
    public void execute_tag_del_invalidIndex() throws Exception {
        // setup expectations
        TestDataHelper helper = new TestDataHelper();
        Task toBeAdded = helper.meetAdam();
        Tars expectedAB = new Tars();
        expectedAB.addTask(toBeAdded);

        model.addTask(toBeAdded);

        // execute command and verify result
        assertCommandBehavior("tag /del 3", String.format(MESSAGE_INVALID_TAG_DISPLAYED_INDEX), expectedAB,
                expectedAB.getTaskList());

        assertCommandBehavior("tag /del 4", String.format(MESSAGE_INVALID_TAG_DISPLAYED_INDEX), expectedAB,
                expectedAB.getTaskList());
    }

    /**
```
###### \java\tars\logic\LogicManagerTest.java
``` java
     */
    @Test
    public void execute_add_recurring() throws Exception {
        // setup expectations
        TestDataHelper helper = new TestDataHelper();
        Task toBeAdded = helper.meetAdam();
        Task toBeAdded2 = helper.meetAdam();
        toBeAdded2.setDateTime(new DateTime("08/09/2016 1400", "08/09/2016 1500"));
        Tars expectedAB = new Tars();
        expectedAB.addTask(toBeAdded);
        expectedAB.addTask(toBeAdded2);

        // execute command and verify result

        String expectedMessage = String.format(AddCommand.MESSAGE_SUCCESS, toBeAdded + "\n");
        expectedMessage += String.format(AddCommand.MESSAGE_SUCCESS, toBeAdded2 + "\n");
        assertCommandBehavior(helper.generateAddCommand(toBeAdded).concat(" /r 2 every week"), expectedMessage,
                expectedAB, expectedAB.getTaskList());

    }

    @Test
    public void execute_addDuplicate_notAllowed() throws Exception {
        // setup expectations
        TestDataHelper helper = new TestDataHelper();
        Task toBeAdded = helper.meetAdam();
        Tars expectedTars = new Tars();
        expectedTars.addTask(toBeAdded);

        // setup starting state
        model.addTask(toBeAdded); // task already in internal address book

        // execute command and verify result
        assertCommandBehavior(helper.generateAddCommand(toBeAdded), MESSAGE_DUPLICATE_TASK, expectedTars,
                expectedTars.getTaskList());

    }

    @Test
    public void execute_listInvalidFlags_errorMessageShown() throws Exception {
        String expectedMessage = String.format(MESSAGE_INVALID_COMMAND_FORMAT, ListCommand.MESSAGE_USAGE);
        assertIncorrectIndexFormatBehaviorForCommand("ls -", expectedMessage);
    }

    /**
     * Test for list command
     * 
```
###### \java\tars\logic\LogicManagerTest.java
``` java
     * @throws Exception
     */
    @Test
    public void execute_list_showsAllTasks() throws Exception {
        // prepare expectations
        TestDataHelper helper = new TestDataHelper();
        Tars expectedTars = helper.generateTars(2);
        List<? extends ReadOnlyTask> expectedList = expectedTars.getTaskList();

        // prepare tars state
        helper.addToModel(model, 2);

        assertCommandBehavior("ls", ListCommand.MESSAGE_SUCCESS, expectedTars, expectedList);
    }

    /**
     * Test for list command
     * 
```
###### \java\tars\logic\LogicManagerTest.java
``` java
     * @throws Exception
     */
    @Test
    public void execute_list_showsAllTasksByPriority() throws Exception {
        TestDataHelper helper = new TestDataHelper();
        Task task1 = helper.generateTaskWithName("task1");
        Task task2 = helper.generateTaskWithName("task2");
        Task task3 = helper.generateTaskWithName("task3");
        task1.setPriority(new Priority("l"));
        task2.setPriority(new Priority("m"));
        task3.setPriority(new Priority("h"));
        Tars expectedTars = new Tars();
        expectedTars.addTask(task3);
        expectedTars.addTask(task2);
        expectedTars.addTask(task1);
        List<Task> listToSort = helper.generateTaskList(task3, task2, task1);
        List<Task> expectedList = helper.generateTaskList(task1, task2, task3);
        helper.addToModel(model, listToSort);

        assertCommandBehaviorForList("ls /p", ListCommand.MESSAGE_SUCCESS_PRIORITY, expectedTars, expectedList);
    }

    /**
     * Test for list command
     * 
```
###### \java\tars\logic\LogicManagerTest.java
``` java
     * @throws Exception
     */
    @Test
    public void execute_list_showsAllTasksByPriorityDescending() throws Exception {
        TestDataHelper helper = new TestDataHelper();
        Task task1 = helper.generateTaskWithName("task1");
        Task task2 = helper.generateTaskWithName("task2");
        Task task3 = helper.generateTaskWithName("task3");
        task1.setPriority(new Priority("l"));
        task2.setPriority(new Priority("m"));
        task3.setPriority(new Priority("h"));
        Tars expectedTars = new Tars();
        expectedTars.addTask(task1);
        expectedTars.addTask(task2);
        expectedTars.addTask(task3);
        List<Task> listToSort = helper.generateTaskList(task1, task2, task3);
        List<Task> expectedList = helper.generateTaskList(task3, task2, task1);
        helper.addToModel(model, listToSort);

        assertCommandBehaviorForList("ls /p dsc", ListCommand.MESSAGE_SUCCESS_PRIORITY_DESCENDING, expectedTars,
                expectedList);
    }

    /**
     * Test for list command
     * 
```
###### \java\tars\logic\LogicManagerTest.java
``` java
     * @throws Exception
     */
    @Test
    public void execute_list_showsAllTasksByDatetime() throws Exception {
        TestDataHelper helper = new TestDataHelper();
        Task task1 = helper.generateTaskWithName("task1");
        Task task2 = helper.generateTaskWithName("task2");
        Task task3 = helper.generateTaskWithName("task3");
        task1.setDateTime(new DateTime("", "01/02/2016 1600"));
        task2.setDateTime(new DateTime("", "02/02/2016 1600"));
        task3.setDateTime(new DateTime("", "03/02/2016 1600"));
        Tars expectedTars = new Tars();
        expectedTars.addTask(task3);
        expectedTars.addTask(task2);
        expectedTars.addTask(task1);
        List<Task> listToSort = helper.generateTaskList(task3, task2, task1);
        List<Task> expectedList = helper.generateTaskList(task1, task2, task3);
        helper.addToModel(model, listToSort);

        assertCommandBehaviorForList("ls /dt", ListCommand.MESSAGE_SUCCESS_DATETIME, expectedTars, expectedList);
    }

    /**
     * Test for list command
     * 
```
###### \java\tars\logic\LogicManagerTest.java
``` java
     * @throws Exception
     */
    @Test
    public void execute_list_showsAllTasksByDatetimeDescending() throws Exception {
        TestDataHelper helper = new TestDataHelper();
        Task task1 = helper.generateTaskWithName("task1");
        Task task2 = helper.generateTaskWithName("task2");
        Task task3 = helper.generateTaskWithName("task3");
        task1.setDateTime(new DateTime("", "01/02/2016 1600"));
        task2.setDateTime(new DateTime("", "02/02/2016 1600"));
        task3.setDateTime(new DateTime("", "03/02/2016 1600"));
        Tars expectedTars = new Tars();
        expectedTars.addTask(task1);
        expectedTars.addTask(task2);
        expectedTars.addTask(task3);
        List<Task> listToSort = helper.generateTaskList(task1, task2, task3);
        List<Task> expectedList = helper.generateTaskList(task3, task2, task1);
        helper.addToModel(model, listToSort);

        assertCommandBehaviorForList("ls /dt dsc", ListCommand.MESSAGE_SUCCESS_DATETIME_DESCENDING, expectedTars,
                expectedList);
    }

    /**
     * Confirms the 'invalid argument index number behaviour' for the given command targeting a
     * single task in the shown list, using visible index.
     * 
     * @param commandWord to test assuming it targets a single task in the last shown list based on
     *        visible index.
     */
    private void assertIncorrectIndexFormatBehaviorForCommand(String commandWord, String expectedMessage)
            throws Exception {
        assertCommandBehavior(commandWord, expectedMessage); // index missing
        assertCommandBehavior(commandWord + " +1", expectedMessage); // index should be unsigned
        assertCommandBehavior(commandWord + " -1", expectedMessage); // index should be unsigned
        assertCommandBehavior(commandWord + " 0", expectedMessage); // index cannot be 0
        assertCommandBehavior(commandWord + " not_a_number", expectedMessage);
    }

    /**
     * Confirms the 'invalid argument index number behaviour' for the given command targeting a
     * single task in the shown list, using visible index.
     * 
     * @param commandWord to test assuming it targets a single task in the last shown list based on
     *        visible index.
     */
    private void assertIndexNotFoundBehaviorForCommand(String commandWord) throws Exception {
        String expectedMessage = MESSAGE_INVALID_TASK_DISPLAYED_INDEX;
        TestDataHelper helper = new TestDataHelper();
        List<Task> taskList = helper.generateTaskList(2);

        // set AB state to 2 tasks
        model.resetData(new Tars());
        for (Task p : taskList) {
            model.addTask(p);
        }

        if ("edit".equals(commandWord)) { // Only For Edit Command
            assertCommandBehavior(commandWord + " 3 /n changeTaskName", expectedMessage, model.getTars(), taskList);
        } else { // For Select & Delete Commands
            assertCommandBehavior(commandWord + " 3", expectedMessage, model.getTars(), taskList);
        }
    }

    /**
```
