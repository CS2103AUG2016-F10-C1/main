# A0139924W
###### /java/tars/commons/util/DateTimeUtil.java
``` java
     * @return String[] with first index being the startDate time and second index being the end
     *         date time
     */
    public static String[] parseStringToDateTime(String dateTimeArg) {
        return NattyDateTimeUtil.parseStringToDateTime(dateTimeArg);
    }

    /**
     * Checks if given endDateTime is within the start and end of this week
     * 
```
###### /java/tars/commons/util/DateTimeUtil.java
``` java
     */
    public static Date setDateTime(Date toBeEdit, int hour, int min, int sec) {
        Calendar calendar = Calendar.getInstance();
        calendar.setTime(toBeEdit);
        calendar.set(Calendar.HOUR_OF_DAY, hour);
        calendar.set(Calendar.MINUTE, min);
        calendar.set(Calendar.SECOND, sec);
        toBeEdit = calendar.getTime();

        return toBeEdit;
    }

    /**
     * Modifies the date based on the frequency for recurring tasks
     * 
```
###### /java/tars/commons/util/NattyDateTimeUtil.java
``` java
 */
public class NattyDateTimeUtil {
    private static final SimpleDateFormat CONVERT_NATTY_TIME_FORMAT =
            new SimpleDateFormat("dd/MM/yyyy HHmm");
    private static final String DASH_DATE_FORMAT = "(\\b\\d{1,2})-(\\d{1,2})";
    private static final String SLASH_DATE_FORMAT = "(\\b\\d{1,2})/(\\d{1,2})";
    private static final String DASH_DATE_REPLACEMENT = "$2-$1";
    private static final String SLASH_DATE_REPLACEMENT = "$2/$1";

    private static final int EMPTY_GROUP_SIZE = 0;
    private static final int START_DATE_SIZE = 1;
    private static final int START_END_DATE_SIZE = 2;
    private static final int FIRST_GROUP = 0;
    private static final int SECOND_GROUP = 1;
    private static final int FIRST_CHILD = 0;
    private static final int SECOND_CHILD = 1;
    private static final String NATTY_TIME_PREFIX = "EXPLICIT_TIME";

    /**
     * Extracts the new task's dateTime from the string arguments using natty.
     * 
     * @return String[] with first index being the startDate time and second index being the end
     *         date time
     */
    public static String[] parseStringToDateTime(String dateTimeArg) {
        String endDateTime = StringUtil.EMPTY_STRING;
        String startDateTime = StringUtil.EMPTY_STRING;
        String formattedDateTimeArg = convertToUsDateFormat(dateTimeArg);

        Parser parser = new Parser(TimeZone.getDefault());
        List<DateGroup> groups = parser.parse(formattedDateTimeArg);

        if (isInvalidDateTimeArg(dateTimeArg, groups)) {
            throw new DateTimeException(Messages.MESSAGE_INVALID_DATE);
        }

        if (groups.size() > 0) {
            DateGroup group = groups.get(FIRST_GROUP);
            if (group.getDates().size() == START_DATE_SIZE) {
                return extractStartDate(group);
            }

            if (group.getDates().size() == START_END_DATE_SIZE) {
                return extractStartAndEndDate(group);
            }
        }

        return new String[] {startDateTime, endDateTime};
    }

    /**
     * Change the date format to US date format.
     * 
```
###### /java/tars/commons/util/NattyDateTimeUtil.java
``` java
     * @return formatted datetime in US format
     */
    private static String convertToUsDateFormat(String rawDateTime) {
        String formattedDateTime = rawDateTime.trim()
                .replaceAll(DASH_DATE_FORMAT, DASH_DATE_REPLACEMENT)
                .replaceAll(SLASH_DATE_FORMAT, SLASH_DATE_REPLACEMENT);
        return formattedDateTime;
    }

    /**
     * Change the date format to Asia date format.
     * 
```
###### /java/tars/commons/util/NattyDateTimeUtil.java
``` java
     * @return formatted datetime in Asia format
     */
    private static String convertToAsiaDateFormat(Date toBeFormattedDateTime) {
        return CONVERT_NATTY_TIME_FORMAT.format(toBeFormattedDateTime);
    }

    /**
     * Checks if the datetime is a invalid format.
     * 
```
###### /java/tars/commons/util/NattyDateTimeUtil.java
``` java
     * @return true if the given datetime is invalid
     */
    private static boolean isInvalidDateTimeArg(String dateTimeArg,
            List<DateGroup> groups) {
        return (dateTimeArg.trim().length() > StringUtil.EMPTY_STRING_LENGTH
                && groups.size() == EMPTY_GROUP_SIZE);
    }

    /**
     * Extracts start date time from natty group
     * 
```
###### /java/tars/commons/util/NattyDateTimeUtil.java
``` java
     */
    private static String[] extractStartDate(DateGroup group) {
        String treeString = StringUtil.EMPTY_STRING;
        String endDateTime = StringUtil.EMPTY_STRING;
        Date date;

        treeString = group.getSyntaxTree().getChild(FIRST_CHILD).toStringTree();
        date = group.getDates().get(FIRST_GROUP);
        if (!isTimePresent(treeString)) {
            date = DateTimeUtil.setDateTime(date, 23, 59, 0);
        }

        endDateTime = convertToAsiaDateFormat(date);

        return new String[] {StringUtil.EMPTY_STRING, endDateTime};
    }

    /**
     * Extracts start and end date time from natty group
     * 
```
###### /java/tars/commons/util/NattyDateTimeUtil.java
``` java
     */
    private static String[] extractStartAndEndDate(DateGroup group) {
        String firstTreeString = StringUtil.EMPTY_STRING;
        String secondTreeString = StringUtil.EMPTY_STRING;
        String startDateTime = StringUtil.EMPTY_STRING;
        String endDateTime = StringUtil.EMPTY_STRING;
        Date firstDate;
        Date secondDate;

        firstTreeString =
                group.getSyntaxTree().getChild(FIRST_CHILD).toStringTree();
        secondTreeString =
                group.getSyntaxTree().getChild(SECOND_CHILD).toStringTree();
        firstDate = group.getDates().get(FIRST_GROUP);
        secondDate = group.getDates().get(SECOND_GROUP);

        if (!isTimePresent(firstTreeString)) {
            firstDate = DateTimeUtil.setDateTime(firstDate, 0, 0, 0);
        }

        if (!isTimePresent(secondTreeString)) {
            secondDate = DateTimeUtil.setDateTime(secondDate, 23, 59, 0);
        }

        startDateTime = CONVERT_NATTY_TIME_FORMAT.format(firstDate);
        endDateTime = CONVERT_NATTY_TIME_FORMAT.format(secondDate);

        return new String[] {startDateTime, endDateTime};
    }

    /**
     * Checks if time is present
     * 
```
###### /java/tars/commons/util/NattyDateTimeUtil.java
``` java
     */
    private static boolean isTimePresent(String treeString) {
        return treeString.contains(NATTY_TIME_PREFIX);
    }
}
```
###### /java/tars/logic/commands/AddCommand.java
``` java
    @Override
    public CommandResult undo() {
        assert model != null;
        try {
            for (Task toAdd : toAddArray) {
                model.deleteTask(toAdd);
            }
            return new CommandResult(
                    String.format(UndoCommand.MESSAGE_SUCCESS, String.format(MESSAGE_UNDO, toAdd)));
        } catch (TaskNotFoundException e) {
            return new CommandResult(String.format(UndoCommand.MESSAGE_UNSUCCESS,
                    Messages.MESSAGE_TASK_CANNOT_BE_FOUND));
        }
    }

```
###### /java/tars/logic/commands/AddCommand.java
``` java
    @Override
    public CommandResult redo() {
        assert model != null;
        try {
            for (Task toAdd : toAddArray) {
                model.addTask(toAdd);
            }
            return new CommandResult(String.format(RedoCommand.MESSAGE_SUCCESS, messageSummary()));
        } catch (DuplicateTaskException e) {
            return new CommandResult(
                    String.format(RedoCommand.MESSAGE_UNSUCCESS, Messages.MESSAGE_DUPLICATE_TASK));
        }
    }

```
###### /java/tars/logic/commands/ClearCommand.java
``` java
 */
public class ClearCommand extends Command {

    public static final String COMMAND_WORD = "clear";
    public static final String MESSAGE_SUCCESS = "TARS has been cleared!";

    @Override
    public CommandResult execute() {
        assert model != null;
        model.resetData(Tars.getEmptyTars());
        
        model.getUndoableCmdHist().clear();
        model.getRedoableCmdHist().clear();
        
        return new CommandResult(MESSAGE_SUCCESS);
    }
}
```
###### /java/tars/logic/commands/ConfirmCommand.java
``` java
    @Override
    public CommandResult undo() {
        try {
            model.addRsvTask(rsvTask);
            model.deleteTask(toConfirm);
        } catch (DuplicateTaskException e) {
            return new CommandResult(
                    String.format(UndoCommand.MESSAGE_UNSUCCESS,
                            Messages.MESSAGE_DUPLICATE_TASK));
        } catch (TaskNotFoundException e) {
            return new CommandResult(
                    String.format(UndoCommand.MESSAGE_UNSUCCESS,
                            Messages.MESSAGE_TASK_CANNOT_BE_FOUND));
        }

        return new CommandResult(String.format(UndoCommand.MESSAGE_SUCCESS,
                StringUtil.EMPTY_STRING));
    }

```
###### /java/tars/logic/commands/ConfirmCommand.java
``` java
    @Override
    public CommandResult redo() {
        try {
            model.deleteRsvTask(rsvTask);
            model.addTask(toConfirm);
        } catch (DuplicateTaskException e) {
            return new CommandResult(
                    String.format(RedoCommand.MESSAGE_UNSUCCESS,
                            Messages.MESSAGE_DUPLICATE_TASK));
        } catch (RsvTaskNotFoundException e) {
            return new CommandResult(
                    String.format(RedoCommand.MESSAGE_UNSUCCESS,
                            Messages.MESSAGE_RSV_TASK_CANNOT_BE_FOUND));
        }

        return new CommandResult(String.format(RedoCommand.MESSAGE_SUCCESS,
                StringUtil.EMPTY_STRING));
    }

}
```
###### /java/tars/logic/commands/DeleteCommand.java
``` java
    @Override
    public CommandResult undo() {
        try {
            for (ReadOnlyTask t : deletedTasks) {
                Task taskToAdd = new Task(t);
                model.addTask(taskToAdd);
            }
            String formattedTaskList =
                    new Formatter().formatTaskList(deletedTasks);
            return new CommandResult(String.format(UndoCommand.MESSAGE_SUCCESS,
                    String.format(MESSAGE_UNDO, formattedTaskList)));
        } catch (DuplicateTaskException e) {
            return new CommandResult(
                    String.format(UndoCommand.MESSAGE_UNSUCCESS,
                            Messages.MESSAGE_DUPLICATE_TASK));
        }
    }

```
###### /java/tars/logic/commands/DeleteCommand.java
``` java
    @Override
    public CommandResult redo() {
        try {
            for (ReadOnlyTask t : deletedTasks) {
                Task taskToAdd = new Task(t);
                model.deleteTask(taskToAdd);
            }
            String formattedTaskList =
                    new Formatter().formatTaskList(deletedTasks);
            return new CommandResult(String.format(RedoCommand.MESSAGE_SUCCESS,
                    String.format(MESSAGE_REDO, formattedTaskList)));
        } catch (TaskNotFoundException e) {
            return new CommandResult(
                    String.format(RedoCommand.MESSAGE_UNSUCCESS,
                            Messages.MESSAGE_TASK_CANNOT_BE_FOUND));
        }
    }

}
```
###### /java/tars/logic/commands/EditCommand.java
``` java
     * @throws IllegalValueException
     * @throws TagNotFoundException
     */
    private void updateTask() throws IllegalValueException, TagNotFoundException {
        updateNameIfChanged();
        updatePriorityIfChanged();
        updateDateTimeIfChanged();
        addTagsIfFound();
        deleteTagsIfFound();
    }

    /**
     * Update the name field if there is a change
     * 
     * @throws IllegalValueException
     */
    private void updateNameIfChanged() throws IllegalValueException {
        if (isFieldChanged(NAME_PREFIX)) {
            Name editedName =
                    new Name(argsTokenizer.getValue(NAME_PREFIX).get());
            editedTask.setName(editedName);
        }
    }

    /**
     * Update the priority if there is a change
     * 
     * @throws IllegalValueException
     */
    private void updatePriorityIfChanged() throws IllegalValueException {
        if (isFieldChanged(PRIORITY_PREFIX)) {
            Priority editedPriority =
                    new Priority(argsTokenizer.getValue(PRIORITY_PREFIX).get());
            editedTask.setPriority(editedPriority);
        }
    }

    /**
     * Update the date time if there is a change
     * 
     * @throws IllegalDateException
     */
    private void updateDateTimeIfChanged() throws IllegalDateException {
        if (isFieldChanged(DATETIME_PREFIX)) {
            String[] dateTimeArray = DateTimeUtil.parseStringToDateTime(
                    argsTokenizer.getValue(DATETIME_PREFIX).get());
            DateTime editedDateTime =
                    new DateTime(dateTimeArray[DATETIME_INDEX_OF_STARTDATE],
                            dateTimeArray[DATETIME_INDEX_OF_ENDDATE]);
            editedTask.setDateTime(editedDateTime);
        }
    }
    
    /**
     * Add tag if there is a change
     * 
     * @throws IllegalValueException
     * @throws DuplicateTagException
     * @throws TagNotFoundException
     */
    private void addTagsIfFound() throws IllegalValueException, DuplicateTagException,
            TagNotFoundException {
        Set<String> tagsToAdd = argsTokenizer.getMultipleValues(ADD_TAG_PREFIX)
                .orElse(new HashSet<>());
        updateTagList(ADD_TAG_PREFIX, tagsToAdd);
    }
    
    /**
     * Remove tag if there is a change
     * 
     * @throws IllegalValueException
     * @throws DuplicateTagException
     * @throws TagNotFoundException
     */
    private void deleteTagsIfFound() throws IllegalValueException, DuplicateTagException,
            TagNotFoundException {
        Set<String> tagsToAdd = argsTokenizer.getMultipleValues(REMOVE_TAG_PREFIX)
                .orElse(new HashSet<>());
        updateTagList(REMOVE_TAG_PREFIX, tagsToAdd);
    }
    
    /**
     * Update tag list
     * 
     * @throws IllegalValueException
     * @throws TagNotFoundException
     */
    private void updateTagList(Prefix mutatorPrefix, Set<String> mutateTagNames)
            throws IllegalValueException, TagNotFoundException {
        UniqueTagList replacement = editedTask.getTags();

        for (String mutateTagName : mutateTagNames) {
            Tag mutateTag = new Tag(mutateTagName);
            
            if (ADD_TAG_PREFIX.equals(mutatorPrefix)) {
                replacement.add(mutateTag);
            }
            
            if (REMOVE_TAG_PREFIX.equals(mutatorPrefix)) {
                replacement.remove(mutateTag);
            }
        }

        editedTask.setTags(replacement);
    }

    /**
     * Checks if the field need to be updated
     * 
```
###### /java/tars/logic/commands/EditCommand.java
``` java
     * @return true if the field need update
     */
    private boolean isFieldChanged(Prefix prefix) {
        return !argsTokenizer.getValue(prefix).orElse(StringUtil.EMPTY_STRING)
                .equals(StringUtil.EMPTY_STRING);
    }

```
###### /java/tars/logic/commands/EditCommand.java
``` java
    @Override
    public CommandResult undo() {
        assert model != null;
        try {
            model.replaceTask(editedTask, new Task(toBeReplacedTask));
            return new CommandResult(String.format(UndoCommand.MESSAGE_SUCCESS,
                    String.format(MESSAGE_UNDO, toBeReplacedTask)));
        } catch (DuplicateTaskException e) {
            return new CommandResult(
                    String.format(UndoCommand.MESSAGE_UNSUCCESS,
                            Messages.MESSAGE_DUPLICATE_TASK));
        }
    }

```
###### /java/tars/logic/commands/EditCommand.java
``` java
    @Override
    public CommandResult redo() {
        assert model != null;
        try {
            model.replaceTask(toBeReplacedTask, editedTask);
            return new CommandResult(String.format(RedoCommand.MESSAGE_SUCCESS,
                    String.format(MESSAGE_REDO, toBeReplacedTask)));
        } catch (DuplicateTaskException e) {
            return new CommandResult(String
                    .format(RedoCommand.MESSAGE_UNSUCCESS, e.getMessage()));
        }
    }
}
```
###### /java/tars/logic/commands/RedoCommand.java
``` java
 */
public class RedoCommand extends Command {

    public static final String COMMAND_WORD = "redo";
    public static final String MESSAGE_SUCCESS = "Redo successfully.\n%1$s";
    public static final String MESSAGE_UNSUCCESS = "Redo unsuccessfully.\n%1$s";

    public static final String MESSAGE_EMPTY_REDO_CMD_HIST = "No more actions that can be redo.";
    public static final String MESSAGE_USAGE =
            COMMAND_WORD + ": Redo a previous command.\n" + "Example: " + COMMAND_WORD;

    @Override
    public CommandResult execute() {
        assert model != null;

        if (model.getRedoableCmdHist().size() == 0) {
            return new CommandResult(MESSAGE_EMPTY_REDO_CMD_HIST);
        }

        UndoableCommand command = (UndoableCommand) model.getRedoableCmdHist().pop();
        model.getUndoableCmdHist().push(command);
        return command.redo();
    }
}
```
###### /java/tars/logic/commands/RsvCommand.java
``` java
    @Override
    public CommandResult undo() {
        if (toReserve != null) {
            try {
                return undoRsvAdd();
            } catch (RsvTaskNotFoundException e) {
                return new CommandResult(String.format(UndoCommand.MESSAGE_UNSUCCESS,
                        Messages.MESSAGE_RSV_TASK_CANNOT_BE_FOUND));
            }
        } else {
            try {
                return undoRsvDelete();
            } catch (DuplicateTaskException e) {
                return new CommandResult(String.format(UndoCommand.MESSAGE_UNSUCCESS,
                        Messages.MESSAGE_DUPLICATE_TASK));
            }
        }
    }

```
###### /java/tars/logic/commands/RsvCommand.java
``` java
    @Override
    public CommandResult redo() {
        if (toReserve != null) {
            try {
                return redoRsvAdd();
            } catch (DuplicateTaskException e) {
                return new CommandResult(String.format(RedoCommand.MESSAGE_UNSUCCESS,
                        Messages.MESSAGE_DUPLICATE_TASK));
            }
        } else {
            try {
                return redoRsvDelete();
            } catch (RsvTaskNotFoundException e) {
                return new CommandResult(String.format(RedoCommand.MESSAGE_UNSUCCESS,
                        Messages.MESSAGE_RSV_TASK_CANNOT_BE_FOUND));
            }
        }
    }

    private CommandResult undoRsvAdd() throws RsvTaskNotFoundException {
        model.deleteRsvTask(toReserve);
        return new CommandResult(String.format(UndoCommand.MESSAGE_SUCCESS,
                String.format(MESSAGE_UNDO_DELETE, toReserve)));
    }
    
    private CommandResult undoRsvDelete() throws DuplicateTaskException {
        for (RsvTask rsvTask : rsvTasksToDelete) {
            model.addRsvTask(rsvTask);
        }

        String addedRsvTasksList = new Formatter().formatRsvTaskList(rsvTasksToDelete);
        return new CommandResult(String.format(UndoCommand.MESSAGE_SUCCESS,
                String.format(MESSAGE_UNDO_ADD, addedRsvTasksList)));
    }
    
    private CommandResult redoRsvAdd() throws DuplicateTaskException {
        model.addRsvTask(toReserve);
        return new CommandResult(String.format(RedoCommand.MESSAGE_SUCCESS,
                String.format(MESSAGE_REDO_ADD, toReserve)));
    }
    
    private CommandResult redoRsvDelete() throws RsvTaskNotFoundException {
        for (RsvTask rsvTask : rsvTasksToDelete) {
            model.deleteRsvTask(rsvTask);
        }

        String deletedRsvTasksList = new Formatter().formatRsvTaskList(rsvTasksToDelete);
        return new CommandResult(String.format(RedoCommand.MESSAGE_SUCCESS,
                String.format(MESSAGE_REDO_DELETE, deletedRsvTasksList)));
    }
}
```
###### /java/tars/logic/commands/TagCommand.java
``` java
 */
public class TagCommand extends UndoableCommand {

    public static final String COMMAND_WORD = "tag";

    public static final String MESSAGE_USAGE =
            COMMAND_WORD + ": [/ls] [/e <INDEX> <TAG_NAME>] [/del <INDEX>]";
    public static final String MESSAGE_RENAME_TAG_SUCCESS =
            "%1$s renamed to [%2$s]";
    public static final String MESSAGE_DELETE_TAG_SUCCESS = "Deleted Tag: %1$s";

    private final Prefix prefix;
    private final String[] args;

    private static final Prefix listPrefix = new Prefix("/ls");
    private static final Prefix editPrefix = new Prefix("/e");
    private static final Prefix deletePrefix = new Prefix("/del");

    private ReadOnlyTag toBeRenamed;
    private ReadOnlyTag toBeDeleted;
    private Tag newTag;
    private ArrayList<ReadOnlyTask> editedTaskList;

    public TagCommand(Prefix prefix, String... args) {
        this.prefix = prefix;
        this.args = args;
    }

    @Override
    public CommandResult execute() {
        CommandResult result = null;

        try {
            if (listPrefix.equals(prefix)) {
                result = executeListTag();
            } else if (editPrefix.equals(prefix)) {
                result = executeEditTag();
            } else if (deletePrefix.equals(prefix)) {
                result = executeDeleteTag();
            }
        } catch (DuplicateTagException e) {
            return new CommandResult(e.getMessage());
        } catch (TagNotFoundException e) {
            return new CommandResult(e.getMessage());
        } catch (IllegalValueException e) {
            return new CommandResult(Tag.MESSAGE_TAG_CONSTRAINTS);
        } catch (NumberFormatException e) {
            return new CommandResult(
                    String.format(Messages.MESSAGE_INVALID_COMMAND_FORMAT,
                            TagCommand.MESSAGE_USAGE));
        }

        return result;
    }

    private CommandResult executeListTag() {
        ObservableList<? extends ReadOnlyTag> allTags =
                model.getUniqueTagList();
        return new CommandResult(new Formatter().formatTags(allTags));
    }

    private CommandResult executeEditTag() throws DuplicateTagException,
            IllegalValueException, TagNotFoundException {
        int targetedIndex = Integer.parseInt(args[0]);
        String newTagName = args[1];

        if (isInValidIndex(targetedIndex)) {
            return new CommandResult(
                    Messages.MESSAGE_INVALID_TAG_DISPLAYED_INDEX);
        }

        toBeRenamed = model.getUniqueTagList()
                .get(targetedIndex - Formatter.DISPLAYED_INDEX_OFFSET);
        newTag = new Tag(newTagName);
        model.renameTasksWithNewTag(toBeRenamed, newTag);

        model.getUndoableCmdHist().push(this);
        return new CommandResult(
                String.format(String.format(MESSAGE_RENAME_TAG_SUCCESS,
                        toBeRenamed.getAsText(), newTagName)));
    }

    private CommandResult executeDeleteTag() throws DuplicateTagException,
            IllegalValueException, TagNotFoundException {
        int targetedIndex = Integer.parseInt(args[0]);

        if (isInValidIndex(targetedIndex)) {
            return new CommandResult(
                    Messages.MESSAGE_INVALID_TAG_DISPLAYED_INDEX);
        }

        toBeDeleted = model.getUniqueTagList()
                .get(targetedIndex - Formatter.DISPLAYED_INDEX_OFFSET);
        editedTaskList = model.removeTagFromAllTasks(toBeDeleted);

        model.getUndoableCmdHist().push(this);
        return new CommandResult(
                String.format(MESSAGE_DELETE_TAG_SUCCESS, toBeDeleted));
    }

    /**
     * Checks if the targetedIndex is a valid index
     * 
     * @param targetedIndex
     * @return true if targetedIndex is an invalid index
     */
    private boolean isInValidIndex(int targetedIndex) {
        return targetedIndex < 1
                || model.getUniqueTagList().size() < targetedIndex;
    }

    @Override
    public CommandResult undo() {
        try {
            if (editPrefix.equals(prefix)) {
                model.renameTasksWithNewTag(newTag, new Tag(toBeRenamed));

            } else if (deletePrefix.equals(prefix)) {
                model.addTagToAllTasks(toBeDeleted, editedTaskList);
            }
        } catch (Exception e) {
            return new CommandResult(UndoCommand.MESSAGE_UNSUCCESS);
        }

        return new CommandResult(String.format(UndoCommand.MESSAGE_SUCCESS,
                StringUtil.EMPTY_STRING));
    }

    @Override
    public CommandResult redo() {
        try {
            if (editPrefix.equals(prefix)) {
                model.renameTasksWithNewTag(toBeRenamed, newTag);
            } else if (deletePrefix.equals(prefix)) {
                editedTaskList = model.removeTagFromAllTasks(toBeDeleted);
            }
        } catch (Exception e) {
            return new CommandResult(RedoCommand.MESSAGE_UNSUCCESS);
        }

        return new CommandResult(String.format(RedoCommand.MESSAGE_SUCCESS,
                StringUtil.EMPTY_STRING));
    }

}
```
###### /java/tars/logic/commands/UndoableCommand.java
``` java
 */
public abstract class UndoableCommand extends Command {

    public abstract CommandResult undo();

    public abstract CommandResult redo();
}
```
###### /java/tars/logic/commands/UndoCommand.java
``` java
 */
public class UndoCommand extends Command {

    public static final String COMMAND_WORD = "undo";

    public static final String MESSAGE_SUCCESS = "Undo successfully.\n%1$s";
    public static final String MESSAGE_UNSUCCESS = "Undo unsuccessfully.\n%1$s";
    public static final String MESSAGE_EMPTY_UNDO_CMD_HIST = "No more actions that can be undo.";
    public static final String MESSAGE_USAGE =
            COMMAND_WORD + ": Undo a previous command\n" + "Example: " + COMMAND_WORD;

    @Override
    public CommandResult execute() {
        assert model != null;

        if (model.getUndoableCmdHist().size() == 0) {
            return new CommandResult(MESSAGE_EMPTY_UNDO_CMD_HIST);
        }

        UndoableCommand command = (UndoableCommand) model.getUndoableCmdHist().pop();
        model.getRedoableCmdHist().push(command);

        return command.undo();
    }

}
```
###### /java/tars/logic/parser/AddCommandParser.java
``` java
 */
public class AddCommandParser extends CommandParser {

    /**
     * Parses arguments in the context of the add task command.
     * 
     * @param args full command args string
     * @return the prepared command
     */
    @Override
    public Command prepareCommand(String args) {
        ArgumentTokenizer argsTokenizer =
                new ArgumentTokenizer(tagPrefix, priorityPrefix, dateTimePrefix, recurringPrefix);
        argsTokenizer.tokenize(args);

        try {
            return new AddCommand(argsTokenizer.getPreamble().get(),
                    DateTimeUtil.parseStringToDateTime(
                            argsTokenizer.getValue(dateTimePrefix).orElse(StringUtil.EMPTY_STRING)),
                    argsTokenizer.getValue(priorityPrefix).orElse(StringUtil.EMPTY_STRING),
                    argsTokenizer.getMultipleValues(tagPrefix).orElse(new HashSet<String>()),
                    ExtractorUtil.getRecurringFromArgs(
                            argsTokenizer.getValue(recurringPrefix).orElse(StringUtil.EMPTY_STRING),
                            recurringPrefix));
        } catch (IllegalValueException ive) {
            return new IncorrectCommand(ive.getMessage());
        } catch (DateTimeException dte) {
            return new IncorrectCommand(Messages.MESSAGE_INVALID_DATE);
        } catch (NoSuchElementException nse) {
            return new IncorrectCommand(
                    String.format(MESSAGE_INVALID_COMMAND_FORMAT, AddCommand.MESSAGE_USAGE));
        }
    }

}
```
###### /java/tars/logic/parser/ArgumentTokenizer.java
``` java
 */
public class ArgumentTokenizer {
    private static final int EMPTY_SIZE = 0;
    private static final int INVALID_POS = -1;
    private static final int START_INDEX_POS = -1;

    private final Prefix[] prefixes;
    private HashMap<Prefix, String> prefixValueMap;
    private TreeMap<Integer, Prefix> prefixPosMap;
    private String args;

    public ArgumentTokenizer(Prefix... prefixes) {
        this.prefixes = prefixes;
        init();
    }

    public void tokenize(String args) {
        resetExtractorState();
        this.args = args;
        this.prefixPosMap = getPrefixPositon();
        extractArguments();
    }

    private void init() {
        this.args = StringUtil.EMPTY_STRING;
        this.prefixValueMap = new HashMap<Prefix, String>();
        this.prefixPosMap = new TreeMap<Integer, Prefix>();
    }

    private void resetExtractorState() {
        this.prefixValueMap.clear();
    }

    /**
     * Gets all prefix positions from arguments string
     */
    private TreeMap<Integer, Prefix> getPrefixPositon() {
        prefixPosMap = new TreeMap<Integer, Prefix>();

        for (int i = StringUtil.START_INDEX; i < prefixes.length; i++) {
            int curIndexPos = START_INDEX_POS;

            do {
                curIndexPos = args.indexOf(StringUtil.STRING_WHITESPACE + prefixes[i].value, curIndexPos + StringUtil.LAST_INDEX);
                
                if (curIndexPos >= StringUtil.START_INDEX) {
                    prefixPosMap.put(curIndexPos, prefixes[i]);
                }
            } while (curIndexPos >= StringUtil.START_INDEX);
        }

        return prefixPosMap;
    }

    /**
     * Extracts the option's prefix and arg from arguments string.
     */
    private HashMap<Prefix, String> extractArguments() {
        prefixValueMap = new HashMap<Prefix, String>();

        int endPos = args.length();

        for (Map.Entry<Integer, Prefix> entry : prefixPosMap.descendingMap().entrySet()) {
            Prefix prefix = entry.getValue();
            Integer pos = entry.getKey();

            if (pos == INVALID_POS) {
                continue;
            }

            String arg = args.substring(pos, endPos).trim();
            endPos = pos;

            if (prefixValueMap.containsKey(prefix)) {
                prefixValueMap.put(prefix,
                        prefixValueMap.get(prefix).concat(StringUtil.STRING_WHITESPACE).concat(arg));
            } else {
                prefixValueMap.put(prefix, arg);
            }

        }

        return prefixValueMap;
    }

    public Optional<String> getValue(Prefix prefix) {
        if (!prefixValueMap.containsKey(prefix)) {
            return Optional.empty();
        }
        
        return Optional.of(getMultipleValues(prefix).get().iterator().next().trim());
    }

    public Optional<Set<String>> getMultipleValues(Prefix prefix) {
        if (!prefixValueMap.containsKey(prefix)) {
            return Optional.empty();
        }
        return Optional.of(getMultipleFromArgs(prefixValueMap.get(prefix), prefix));
    }
    
    public Optional<String> getMultipleRawValues(Prefix prefix) {
        if (!prefixValueMap.containsKey(prefix)) {
            return Optional.empty();
        }
        
        return Optional.of(prefixValueMap.get(prefix).replaceAll(prefix.value + StringUtil.STRING_WHITESPACE, StringUtil.EMPTY_STRING));
    }

    public int numPrefixFound() {
        return prefixPosMap.size();
    }

    public Optional<String> getPreamble() {
        if (args.trim().length() == StringUtil.EMPTY_STRING_LENGTH) {
            return Optional.empty();
        }

        if (prefixPosMap.size() == EMPTY_SIZE) {
            return Optional.of(args.trim());
        } else if (prefixPosMap.firstKey() == StringUtil.START_INDEX) {
            return Optional.empty();
        }

        return Optional.of(args.substring(StringUtil.START_INDEX, prefixPosMap.firstKey()).trim());
    }

    private Set<String> getMultipleFromArgs(String multipleArguments, Prefix prefix) {
        if (multipleArguments.isEmpty()) {
            return Collections.emptySet();
        }

        multipleArguments = multipleArguments.trim();

        // replace first delimiter prefix, then split
        List<String> multipleArgList = Arrays
                .asList(multipleArguments.replaceFirst(prefix.value + StringUtil.STRING_WHITESPACE, StringUtil.EMPTY_STRING)
                        .split(StringUtil.STRING_WHITESPACE + prefix.value + StringUtil.STRING_WHITESPACE));

        for (int i = StringUtil.START_INDEX; i < multipleArgList.size(); i++) {
            multipleArgList.set(i, multipleArgList.get(i).trim());
        }

        return new HashSet<>(multipleArgList);
    }
    
}
```
###### /java/tars/logic/parser/CommandParser.java
``` java
 */
public abstract class CommandParser {
    protected static final Prefix namePrefix = new Prefix("/n");
    protected static final Prefix tagPrefix = new Prefix("/t");
    protected static final Prefix priorityPrefix = new Prefix("/p");
    protected static final Prefix dateTimePrefix = new Prefix("/dt");
    protected static final Prefix recurringPrefix = new Prefix("/r");
    protected static final Prefix deletePrefix = new Prefix("/del");
    protected static final Prefix addTagPrefix = new Prefix("/ta");
    protected static final Prefix removeTagPrefix = new Prefix("/tr");
    protected static final Prefix donePrefix = new Prefix("/do");
    protected static final Prefix undonePrefix = new Prefix("/ud");
    protected static final Prefix listPrefix = new Prefix("/ls");
    protected static final Prefix editPrefix = new Prefix("/e");

    public abstract Command prepareCommand(String args);
}
```
###### /java/tars/logic/parser/Parser.java
``` java
 */
public class Parser {

    /**
     * Used for initial separation of command word and args.
     */
    private static final Pattern BASIC_COMMAND_FORMAT =
            Pattern.compile("(?<commandWord>\\S+)(?<arguments>.*)");

    /**
     * Used for mapping a list of known command
     */
    private static Map<String, Class<? extends CommandParser>> commandParserMap =
            new HashMap<String, Class<? extends CommandParser>>();

    static {
        fillCommandMap();
    }

    private static void fillCommandMap() {
        commandParserMap.put(AddCommand.COMMAND_WORD, AddCommandParser.class);
        commandParserMap.put(RsvCommand.COMMAND_WORD, RsvCommandParser.class);
        commandParserMap.put(EditCommand.COMMAND_WORD, EditCommandParser.class);
        commandParserMap.put(DeleteCommand.COMMAND_WORD, DeleteCommandParser.class);
        commandParserMap.put(ConfirmCommand.COMMAND_WORD, ConfirmCommandParser.class);
        commandParserMap.put(ClearCommand.COMMAND_WORD, ClearCommandParser.class);
        commandParserMap.put(FindCommand.COMMAND_WORD, FindCommandParser.class);
        commandParserMap.put(ListCommand.COMMAND_WORD, ListCommandParser.class);
        commandParserMap.put(UndoCommand.COMMAND_WORD, UndoCommandParser.class);
        commandParserMap.put(RedoCommand.COMMAND_WORD, RedoCommandParser.class);
        commandParserMap.put(DoCommand.COMMAND_WORD, DoCommandParser.class);
        commandParserMap.put(UdCommand.COMMAND_WORD, UdCommandParser.class);
        commandParserMap.put(CdCommand.COMMAND_WORD, CdCommandParser.class);
        commandParserMap.put(TagCommand.COMMAND_WORD, TagCommandParser.class);
        commandParserMap.put(FreeCommand.COMMAND_WORD, FreeCommandParser.class);
        commandParserMap.put(ExitCommand.COMMAND_WORD, ExitCommandParser.class);
        commandParserMap.put(HelpCommand.COMMAND_WORD, HelpCommandParser.class);
    }

    /**
     * Parses user input into command for execution.
     *
     * @param userInput full user input string
     * @return the command based on the user input
     */
    public Command parseCommand(String userInput) {
        final Matcher matcher = BASIC_COMMAND_FORMAT.matcher(userInput.trim());
        if (!matcher.matches()) {
            return new IncorrectCommand(
                    String.format(MESSAGE_INVALID_COMMAND_FORMAT, HelpCommand.MESSAGE_USAGE));
        }

        final String commandWord = matcher.group("commandWord");
        final String arguments = matcher.group("arguments");

        if (!commandParserMap.containsKey(commandWord)) {
            return new IncorrectCommandParser().prepareCommand(arguments);
        }

        try {
            return commandParserMap.get(commandWord).newInstance().prepareCommand(arguments);
        } catch (Exception ex) {
            return new IncorrectCommandParser().prepareCommand(arguments);
        }
    }

}
```
###### /java/tars/logic/parser/Prefix.java
``` java
 */
public class Prefix {
    public final String value;

    public Prefix(String value) {
        this.value = value;
    }

    @Override
    public boolean equals(Object other) {
        if (!(other instanceof Prefix)) {
            return false;
        }

        if (other == this) {
            return true;
        }

        Prefix otherPrefix = (Prefix) other;
        return otherPrefix.value.equals(this.value);
    }

    @Override
    public int hashCode() {
        return this.value == null ? 0 : this.value.hashCode();
    }
}
```
###### /java/tars/logic/parser/RedoCommandParser.java
``` java
 */
public class RedoCommandParser extends CommandParser {

    @Override
    public Command prepareCommand(String args) {
        if (!args.isEmpty()) {
            return new IncorrectCommand(
                    String.format(MESSAGE_INVALID_COMMAND_FORMAT, RedoCommand.MESSAGE_USAGE));
        }
        return new RedoCommand();
    }

}
```
###### /java/tars/logic/parser/TagCommandParser.java
``` java
 *
 */
public class TagCommandParser extends CommandParser {
    private static final Pattern TAG_EDIT_COMMAND_FORMAT = Pattern.compile("\\d+ \\w+$");

    /**
     * Parses arguments in the context of the tag command.
     * 
     * @param args full command args string
     * @return the prepared command
     */
    @Override
    public Command prepareCommand(String args) {
        ArgumentTokenizer argsTokenizer =
                new ArgumentTokenizer(listPrefix, editPrefix, deletePrefix);
        argsTokenizer.tokenize(args);

        if (argsTokenizer.getValue(listPrefix).isPresent()) {
            return new TagCommand(listPrefix);
        }

        if (argsTokenizer.getValue(editPrefix).isPresent()) {
            String editArgs = argsTokenizer.getValue(editPrefix).get();
            final Matcher matcher = TAG_EDIT_COMMAND_FORMAT.matcher(editArgs);
            if (matcher.matches()) {
                return new TagCommand(editPrefix, editArgs.split(StringUtil.STRING_WHITESPACE));
            }
        }

        if (argsTokenizer.getValue(deletePrefix).isPresent()) {
            String index = argsTokenizer.getValue(deletePrefix).get();
            return new TagCommand(deletePrefix, index);
        }

        return new IncorrectCommand(
                String.format(MESSAGE_INVALID_COMMAND_FORMAT, TagCommand.MESSAGE_USAGE));
    }

}
```
###### /java/tars/logic/parser/UndoCommandParser.java
``` java
 *
 */
public class UndoCommandParser extends CommandParser {

    @Override
    public Command prepareCommand(String args) {
        if (!args.isEmpty()) {
            return new IncorrectCommand(
                    String.format(MESSAGE_INVALID_COMMAND_FORMAT, UndoCommand.MESSAGE_USAGE));
        }
        return new UndoCommand();
    }

}
```
###### /java/tars/model/ModelManager.java
``` java
  @Override
  public synchronized void renameTasksWithNewTag(ReadOnlyTag toBeRenamed, Tag newTag)
      throws IllegalValueException, TagNotFoundException, DuplicateTagException {

    tars.getUniqueTagList().update(toBeRenamed, newTag);
    tars.renameTasksWithNewTag(toBeRenamed, newTag);

    indicateTarsChanged();
  }

```
###### /java/tars/model/ModelManager.java
``` java
  @Override
  public synchronized ArrayList<ReadOnlyTask> removeTagFromAllTasks(ReadOnlyTag toBeDeleted)
      throws TagNotFoundException, IllegalValueException {

    ArrayList<ReadOnlyTask> editedTasks = tars.removeTagFromAllTasks(toBeDeleted);
    tars.getUniqueTagList().remove(new Tag(toBeDeleted));

    indicateTarsChanged();
    return editedTasks;
  }

```
###### /java/tars/model/ModelManager.java
``` java
  @Override
  public synchronized void addTagToAllTasks(ReadOnlyTag toBeAdded, ArrayList<ReadOnlyTask> allTasks)
      throws DuplicateTagException, IllegalValueException, TagNotFoundException {
    tars.addTagToAllTasks(toBeAdded, allTasks);
    tars.getUniqueTagList().add(new Tag(toBeAdded));

    indicateTarsChanged();
  }

  @Override
  public synchronized void deleteTask(ReadOnlyTask target) throws TaskNotFoundException {
    tars.removeTask(target);
    indicateTarsChanged();
  }

  @Override
  public synchronized void addTask(Task task) throws DuplicateTaskException {
    tars.addTask(task);
    raise(new TaskAddedEvent(tars.getTaskList().size(), task));
    updateFilteredListToShowAll();
    indicateTarsChanged();
  }

  @Override
  public synchronized void deleteRsvTask(RsvTask target) throws RsvTaskNotFoundException {
    tars.removeRsvTask(target);
    indicateTarsChanged();
  }

  @Override
  public synchronized void addRsvTask(RsvTask rsvTask) throws DuplicateTaskException {
    tars.addRsvTask(rsvTask);
    indicateTarsChanged();
  }

```
###### /java/tars/model/ModelManager.java
``` java
  @Override
  public synchronized void replaceTask(ReadOnlyTask toUndo, Task replacement)
      throws DuplicateTaskException {
    tars.replaceTask(toUndo, replacement);
    indicateTarsChanged();
  }

  // =========== Filtered Task List Accessors ===========

  @Override
  public UnmodifiableObservableList<ReadOnlyTask> getFilteredTaskList() {
    return new UnmodifiableObservableList<>(filteredTasks);
  }

  @Override
  public UnmodifiableObservableList<RsvTask> getFilteredRsvTaskList() {
    return new UnmodifiableObservableList<>(filteredRsvTasks);
  }

  @Override
  public void updateFilteredListToShowAll() {
    filteredTasks.setPredicate(null);
  }

  @Override
  public void updateFilteredTaskList(Set<String> keywords) {
    updateFilteredTaskList(new PredicateExpression(new NameQualifier(keywords)));
  }

  public void updateFilteredTaskListUsingQuickSearch(ArrayList<String> quickSearchKeywords) {
    updateFilteredTaskList(new PredicateExpression(new QuickSearchQualifier(quickSearchKeywords)));
  }

  public void updateFilteredTaskListUsingFlags(TaskQuery taskQuery) {
    updateFilteredTaskList(new PredicateExpression(new FlagSearchQualifier(taskQuery)));
  }

  private void updateFilteredTaskList(Expression expression) {
    filteredTasks.setPredicate(expression::satisfies);
  }

```
###### /java/tars/model/tag/ReadOnlyTag.java
``` java
 */
public interface ReadOnlyTag {
    public String getAsText();
}
```
###### /java/tars/model/Tars.java
``` java
    public void addTag(Tag t) throws UniqueTagList.DuplicateTagException {
        tags.add(t);
    }

```
###### /java/tars/model/Tars.java
``` java
    public void removeTag(Tag t) throws UniqueTagList.TagNotFoundException {
        tags.remove(t);
    }

    /**
     * Rename all task with the new tag
     * 
```
###### /java/tars/model/Tars.java
``` java
     * @param toBeRenamed tag to be replaced with new the new tag
     * @param newTag new tag
     * @throws IllegalValueException if the given tag name string is invalid.
     * @throws TagNotFoundException if there is no matching tags.
     */
    public void renameTasksWithNewTag(ReadOnlyTag toBeRenamed, Tag newTag)
            throws IllegalValueException, TagNotFoundException {

        for (int i = 0; i < tasks.getInternalList().size(); i++) {
            Task toEdit = new Task(tasks.getInternalList().get(i));
            UniqueTagList tags = toEdit.getTags();
            if (tags.contains(new Tag(toBeRenamed))) {
                tags.update(toBeRenamed, newTag);
                toEdit.setTags(tags);
                tasks.getInternalList().set(i, toEdit);
            }
        }
    }

    /**
     * Remove the tag from all tasks
     * 
```
###### /java/tars/model/Tars.java
``` java
     * @param toBeDeleted
     * @throws IllegalValueException if the given tag name string is invalid.
     * @throws TagNotFoundException if there is no matching tags.
     */
    public ArrayList<ReadOnlyTask> removeTagFromAllTasks(ReadOnlyTag toBeDeleted)
            throws IllegalValueException, TagNotFoundException, DuplicateTagException {
        ArrayList<ReadOnlyTask> editedTasks = new ArrayList<ReadOnlyTask>();

        for (int i = 0; i < tasks.getInternalList().size(); i++) {
            Task toEdit = new Task(tasks.getInternalList().get(i));
            UniqueTagList tags = toEdit.getTags();
            if (tags.contains(new Tag(toBeDeleted))) {
                tags.remove(new Tag(toBeDeleted));
                toEdit.setTags(tags);
                tasks.getInternalList().set(i, toEdit);
                editedTasks.add(toEdit);
            }
        }

        return editedTasks;
    }

    /**
     * Remove the tag from all tasks
     * 
```
###### /java/tars/model/Tars.java
``` java
     * @param toBeDeleted
     * @throws IllegalValueException if the given tag name string is invalid.
     * @throws TagNotFoundException if there is no matching tags.
     */
    public void addTagToAllTasks(ReadOnlyTag toBeAdded, ArrayList<ReadOnlyTask> allTasks)
            throws IllegalValueException, TagNotFoundException, DuplicateTagException {

        for (int i = 0; i < allTasks.size(); i++) {
            for (int j = 0; j < tasks.getInternalList().size(); j++) {
                Task toEdit = new Task(tasks.getInternalList().get(j));
                if (toEdit.equals(allTasks.get(i))) {
                    UniqueTagList tags = toEdit.getTags();
                    tags.add(new Tag(toBeAdded));
                    toEdit.setTags(tags);
                    tasks.getInternalList().set(i, toEdit);
                }
            }
        }
    }

```
###### /java/tars/ui/CommandBox.java
``` java
     */
    private void handleUndoAndRedoKeyRequest(String commandWord) {
        if (UndoCommand.COMMAND_WORD.equals(commandWord)) {
            mostRecentResult = logic.execute(UndoCommand.COMMAND_WORD);
        } else if (RedoCommand.COMMAND_WORD.equals(commandWord)) {
            mostRecentResult = logic.execute(RedoCommand.COMMAND_WORD);
        }
        resultDisplay.postMessage(mostRecentResult.feedbackToUser);
        logger.info("Result: " + mostRecentResult.feedbackToUser);
    }

    /**
     * Adds the user input command text into the "prev" stack
     * 
     * @@A0124333U
     */
    private void addCmdTextToPrevStack(String cmdText) {
        if (!prevCmdTextHistStack.contains(cmdText)) {
            prevCmdTextHistStack.push(cmdText);
        }
    }

    /**
     * Adds the user input command text into the "next" stack
     */
    private void addCmdTextToNextStack(String cmdText) {
        if (!nextCmdTextHistStack.contains(cmdText)) {
            nextCmdTextHistStack.push(cmdText);
        }
    }

    /**
     * Shows the prev cmdtext in the CommandBox. Does nothing if "prev" stack is empty
     */
    private void setTextToShowPrevCmdText(KeyEvent ke) {
        if (!prevCmdTextHistStack.isEmpty()) {
            if (nextCmdTextHistStack.isEmpty()) {
                nextCmdTextHistStack.push(commandTextField.getText());
            }
            String cmdTextToShow = prevCmdTextHistStack.pop();
            addCmdTextToNextStack(cmdTextToShow);
            if (commandTextField.getText().equals(cmdTextToShow)
                    && !prevCmdTextHistStack.isEmpty()) {
                cmdTextToShow = prevCmdTextHistStack.pop();
                addCmdTextToNextStack(cmdTextToShow);
            }
            ke.consume();
            commandTextField.setText(cmdTextToShow);
        }
    }

    /**
     * Shows the next cmdtext in the CommandBox. Does nothing if "next" stack is empty
     */
    private void setTextToShowNextCmdText(KeyEvent ke) {
        if (!nextCmdTextHistStack.isEmpty()) {
            String cmdTextToShow = nextCmdTextHistStack.pop();
            addCmdTextToPrevStack(cmdTextToShow);
            if (commandTextField.getText().equals(cmdTextToShow)
                    && !nextCmdTextHistStack.isEmpty()) {
                cmdTextToShow = nextCmdTextHistStack.pop();
                if (!nextCmdTextHistStack.isEmpty()) {
                    addCmdTextToNextStack(cmdTextToShow);
                }
            }
            ke.consume();
            commandTextField.setText(cmdTextToShow);
        }
    }

    /**
     * Sets the command box style to indicate a correct command.
     */
    private void setStyleToIndicateCorrectCommand() {
        commandTextField.getStyleClass().remove("error");
        commandTextField.setText("");
    }

    @Subscribe
    private void handleIncorrectCommandAttempted(
            IncorrectCommandAttemptedEvent event) {
        logger.info(LogsCenter.getEventHandlingLogMessage(event,
                "Invalid command: " + previousCommandTest));
        setStyleToIndicateIncorrectCommand();
        restoreCommandText();
    }

    /**
     * Restores the command box text to the previously entered command
     */
    private void restoreCommandText() {
        commandTextField.setText(previousCommandTest);
    }

    /**
     * Sets the command box style to indicate an error
     */
    private void setStyleToIndicateIncorrectCommand() {
        commandTextField.getStyleClass().add("error");
    }

}
```
###### /java/tars/ui/formatter/DateFormatter.java
``` java
 */
public class DateFormatter {
    private static final DateTimeFormatter DATE_FORMAT =
            DateTimeFormatter.ofPattern("E, MMM dd");
    private static final DateTimeFormatter TIME_FORMAT =
            DateTimeFormatter.ofPattern("hh:mm a");
    private static final DateTimeFormatter NORMAL_DATETIME_FORMAT =
            DateTimeFormatter.ofPattern("E, MMM dd hh:mm a");
    private static final DateTimeFormatter NORMAL_DATE_DIFF_YEAR_FORMAT =
            DateTimeFormatter.ofPattern("E, MMM dd yyyy hh:mm a");

    private static final String TODAY_PREFIX_TEXT = "Today at ";
    private static final String TOMORROW_PREFIX_TEXT = "Tomorrow at ";
    
    public static String formatDate(DateTime dateTime) {
        LocalDateTime startDateTime = dateTime.getStartDate();
        LocalDateTime endDateTime = dateTime.getEndDate();

        if (startDateTime != null && endDateTime == null) {
            return DateFormatter.generateSingleDateFormat(startDateTime);
        } else if (startDateTime == null && endDateTime != null) {
            return DateFormatter.generateSingleDateFormat(endDateTime);
        } else if (startDateTime != null && endDateTime != null) {
            return DateFormatter.generateDateRangeFormat(startDateTime,
                    endDateTime);
        } else {
            return StringUtil.EMPTY_STRING;
        }
    }

    public static String generateSingleDateFormat(LocalDateTime firstDate) {
        if (isToday(firstDate)) {
            return TODAY_PREFIX_TEXT + TIME_FORMAT.format(firstDate);
        } else if (isTomorrow(firstDate)) {
            return TOMORROW_PREFIX_TEXT + TIME_FORMAT.format(firstDate);
        } else {
            return NORMAL_DATETIME_FORMAT.format(firstDate);
        }
    }

    public static String generateDateRangeFormat(LocalDateTime firstDate,
            LocalDateTime secondDate) {
        if (isSameDay(firstDate, secondDate)) {
            return DATE_FORMAT.format(firstDate) + " "
                    + TIME_FORMAT.format(firstDate) + " - "
                    + TIME_FORMAT.format(secondDate);
        } else if (isSameYear(firstDate, secondDate)) {
            return NORMAL_DATETIME_FORMAT.format(firstDate) + " - "
                    + NORMAL_DATETIME_FORMAT.format(secondDate);
        } else {
            return NORMAL_DATE_DIFF_YEAR_FORMAT.format(firstDate) + " - "
                    + NORMAL_DATE_DIFF_YEAR_FORMAT.format(secondDate);
        }
    }

    private static boolean isToday(LocalDateTime firstDate) {
        return isSameDay(firstDate, LocalDateTime.now());
    }

    private static boolean isTomorrow(LocalDateTime firstDate) {
        return isSameDay(firstDate, LocalDateTime.now().plusDays(1));
    }

    private static boolean isSameDay(LocalDateTime firstDate,
            LocalDateTime secondDate) {
        DateTimeFormatter sameDayDateFormat =
                DateTimeFormatter.ofPattern("ddMMyyyy");
        return sameDayDateFormat.format(firstDate)
                .equals(sameDayDateFormat.format(secondDate));
    }

    private static boolean isSameYear(LocalDateTime firstDate,
            LocalDateTime secondDate) {
        DateTimeFormatter sameDayDateFormat =
                DateTimeFormatter.ofPattern("yyyy");
        return sameDayDateFormat.format(firstDate)
                .equals(sameDayDateFormat.format(secondDate));
    }
}
```
###### /java/tars/ui/formatter/Formatter.java
``` java
 */
public class Formatter {
    /** Format of indexed list item */
    private static final String MESSAGE_INDEXED_LIST_ITEM = "%1$d.\t%2$s";

    public static final String EMPTY_LIST_MESSAGE = "0 %1$s listed.";

    /** Offset required to convert between 1-indexing and 0-indexing. */
    public static final int DISPLAYED_INDEX_OFFSET = 1;

    public String formatTags(List<? extends ReadOnlyTag> tags) {
        final List<String> formattedTags = new ArrayList<>();

        if (tags.size() == 0) {
            return String.format(EMPTY_LIST_MESSAGE, "tags");
        }

        for (ReadOnlyTag tag : tags) {
            formattedTags.add(tag.getAsText());
        }
        return asIndexedList(formattedTags);
    }

    public String formatTaskList(List<? extends ReadOnlyTask> taskList) {
        final List<String> formattedTasks = new ArrayList<>();

        if (taskList.size() == 0) {
            return String.format(EMPTY_LIST_MESSAGE, "tasks");
        }

        for (ReadOnlyTask task : taskList) {
            formattedTasks.add(task.getAsText());
        }
        return asIndexedList(formattedTasks);
    }

    public String formatRsvTaskList(List<? extends RsvTask> rsvTaskList) {
        final List<String> formattedTasks = new ArrayList<>();

        if (rsvTaskList.size() == 0) {
            return String.format(EMPTY_LIST_MESSAGE, "tasks");
        }

        for (RsvTask task : rsvTaskList) {
            formattedTasks.add(task.toString());
        }
        return asIndexedList(formattedTasks);
    }

    /**
     * Formats a list of strings as an indexed list.
     */
    private static String asIndexedList(List<String> listItems) {
        final StringBuilder formatted = new StringBuilder();
        int displayIndex = DISPLAYED_INDEX_OFFSET;
        for (String listItem : listItems) {
            formatted.append(getIndexedListItem(displayIndex++, listItem))
                    .append(StringUtil.STRING_NEWLINE);
        }
        return formatted.toString();
    }

    /**
     * Formats a string as an indexed list item.
     *
     * @param visibleIndex index for this listing
     */
    private static String getIndexedListItem(int visibleIndex,
            String listItem) {
        return String.format(MESSAGE_INDEXED_LIST_ITEM, visibleIndex, listItem);
    }

    /**
     * Formats a given RsvTask dateTime list to display
     * 
```
