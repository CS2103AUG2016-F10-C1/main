# A0139924W
###### /java/tars/commons/util/DateTimeUtil.java
``` java
    /**
     * Extracts the new task's dateTime from the string arguments.
     * 
     * @return String[] with first index being the startDate time and second index being the end
     *         date time
     */
    public static String[] parseStringToDateTime(String dateTimeArg) {
        return NattyDateTimeUtil.parseStringToDateTime(dateTimeArg);
    }
```
###### /java/tars/commons/util/DateTimeUtil.java
``` java
    /**
     * Modify the date based on the new hour, min and sec
     */
    public static Date setDateTime(Date toBeEdit, int hour, int min, int sec) {
        Calendar calendar = Calendar.getInstance();
        calendar.setTime(toBeEdit);
        calendar.set(Calendar.HOUR_OF_DAY, hour);
        calendar.set(Calendar.MINUTE, min);
        calendar.set(Calendar.SECOND, sec);
        toBeEdit = calendar.getTime();

        return toBeEdit;
    }

```
###### /java/tars/commons/util/NattyDateTimeUtil.java
``` java
/**
 * Natty date time utility
 */
public class NattyDateTimeUtil {
    private static final SimpleDateFormat CONVERT_NATTY_TIME_FORMAT =
            new SimpleDateFormat("dd/MM/yyyy HHmm");
    private static final String DASH_DATE_FORMAT = "(\\b\\d{1,2})-(\\d{1,2})";
    private static final String SLASH_DATE_FORMAT = "(\\b\\d{1,2})/(\\d{1,2})";
    private static final String DASH_DATE_REPLACEMENT = "$2-$1";
    private static final String SLASH_DATE_REPLACEMENT = "$2/$1";

    private static final int EMPTY_GROUP_SIZE = 0;
    private static final int START_DATE_SIZE = 1;
    private static final int START_END_DATE_SIZE = 2;
    private static final int FIRST_GROUP = 0;
    private static final int SECOND_GROUP = 1;
    private static final int FIRST_CHILD = 0;
    private static final int SECOND_CHILD = 1;
    private static final String NATTY_TIME_PREFIX = "EXPLICIT_TIME";

    /**
     * Extracts the new task's dateTime from the string arguments using natty.
     * 
     * @return String[] with first index being the startDate time and second index being the end
     *         date time
     */
    public static String[] parseStringToDateTime(String dateTimeArg) {
        String endDateTime = StringUtil.EMPTY_STRING;
        String startDateTime = StringUtil.EMPTY_STRING;
        String formattedDateTimeArg = convertToUsDateFormat(dateTimeArg);

        Parser parser = new Parser(TimeZone.getDefault());
        List<DateGroup> groups = parser.parse(formattedDateTimeArg);

        if (isInvalidDateTimeArg(dateTimeArg, groups)) {
            throw new DateTimeException(Messages.MESSAGE_INVALID_DATE);
        }

        if (groups.size() > EMPTY_GROUP_SIZE) {
            DateGroup group = groups.get(FIRST_GROUP);
            if (group.getDates().size() == START_DATE_SIZE) {
                return extractStartDate(group);
            }

            if (group.getDates().size() == START_END_DATE_SIZE) {
                return extractStartAndEndDate(group);
            }
        }

        return new String[] {startDateTime, endDateTime};
    }

    /**
     * Change the date format to US date format.
     * 
     * @return formatted datetime in US format
     */
    private static String convertToUsDateFormat(String rawDateTime) {
        String formattedDateTime = rawDateTime.trim()
                .replaceAll(DASH_DATE_FORMAT, DASH_DATE_REPLACEMENT)
                .replaceAll(SLASH_DATE_FORMAT, SLASH_DATE_REPLACEMENT);
        return formattedDateTime;
    }

    /**
     * Change the date format to Asia date format.
     * 
     * @return formatted datetime in Asia format
     */
    private static String convertToAsiaDateFormat(Date toBeFormattedDateTime) {
        return CONVERT_NATTY_TIME_FORMAT.format(toBeFormattedDateTime);
    }

    /**
     * Checks if the datetime is a invalid format.
     * 
     * @return true if the given datetime is invalid
     */
    private static boolean isInvalidDateTimeArg(String dateTimeArg,
            List<DateGroup> groups) {
        return (dateTimeArg.trim().length() > StringUtil.EMPTY_STRING_LENGTH
                && groups.size() == EMPTY_GROUP_SIZE);
    }

    /**
     * Extracts start date time from natty group
     */
    private static String[] extractStartDate(DateGroup group) {
        String treeString = StringUtil.EMPTY_STRING;
        String endDateTime = StringUtil.EMPTY_STRING;
        Date date;

        treeString = group.getSyntaxTree().getChild(FIRST_CHILD).toStringTree();
        date = group.getDates().get(FIRST_GROUP);
        if (!isTimePresent(treeString)) {
            date = DateTimeUtil.setDateTime(date,
                    DateTimeUtil.DATETIME_LAST_HOUR_OF_DAY,
                    DateTimeUtil.DATETIME_LAST_MINUTE_OF_DAY,
                    DateTimeUtil.DATETIME_FIRST_SECOND_OF_DAY);
        }

        endDateTime = convertToAsiaDateFormat(date);

        return new String[] {StringUtil.EMPTY_STRING, endDateTime};
    }

    /**
     * Extracts start and end date time from natty group
     */
    private static String[] extractStartAndEndDate(DateGroup group) {
        String firstTreeString = StringUtil.EMPTY_STRING;
        String secondTreeString = StringUtil.EMPTY_STRING;
        String startDateTime = StringUtil.EMPTY_STRING;
        String endDateTime = StringUtil.EMPTY_STRING;
        Date firstDate;
        Date secondDate;

        firstTreeString =
                group.getSyntaxTree().getChild(FIRST_CHILD).toStringTree();
        secondTreeString =
                group.getSyntaxTree().getChild(SECOND_CHILD).toStringTree();
        firstDate = group.getDates().get(FIRST_GROUP);
        secondDate = group.getDates().get(SECOND_GROUP);

        if (!isTimePresent(firstTreeString)) {
            firstDate = DateTimeUtil.setDateTime(firstDate,
                    DateTimeUtil.DATETIME_FIRST_HOUR_OF_DAY,
                    DateTimeUtil.DATETIME_FIRST_MINUTE_OF_DAY,
                    DateTimeUtil.DATETIME_FIRST_SECOND_OF_DAY);
        }

        if (!isTimePresent(secondTreeString)) {
            secondDate = DateTimeUtil.setDateTime(secondDate,
                    DateTimeUtil.DATETIME_LAST_HOUR_OF_DAY,
                    DateTimeUtil.DATETIME_LAST_MINUTE_OF_DAY,
                    DateTimeUtil.DATETIME_FIRST_SECOND_OF_DAY);
        }

        startDateTime = CONVERT_NATTY_TIME_FORMAT.format(firstDate);
        endDateTime = CONVERT_NATTY_TIME_FORMAT.format(secondDate);

        return new String[] {startDateTime, endDateTime};
    }

    /**
     * Checks if time is present
     */
    private static boolean isTimePresent(String treeString) {
        return treeString.contains(NATTY_TIME_PREFIX);
    }
}
```
###### /java/tars/logic/commands/AddCommand.java
``` java
    @Override
    public CommandResult undo() {
        assert model != null;
        try {
            for (Task toAdd : taskArray) {
                model.deleteTask(toAdd);
            }
            return new CommandResult(String.format(UndoCommand.MESSAGE_SUCCESS,
                    String.format(MESSAGE_UNDO, toAdd)));
        } catch (TaskNotFoundException e) {
            return new CommandResult(
                    String.format(UndoCommand.MESSAGE_UNSUCCESS,
                            Messages.MESSAGE_TASK_CANNOT_BE_FOUND));
        }
    }

```
###### /java/tars/logic/commands/AddCommand.java
``` java
    @Override
    public CommandResult redo() {
        assert model != null;
        try {
            for (Task toAdd : taskArray) {
                model.addTask(toAdd);
            }
            return new CommandResult(String.format(RedoCommand.MESSAGE_SUCCESS,
                    messageSummary()));
        } catch (DuplicateTaskException e) {
            return new CommandResult(
                    String.format(RedoCommand.MESSAGE_UNSUCCESS,
                            Messages.MESSAGE_DUPLICATE_TASK));
        }
    }

```
###### /java/tars/logic/commands/ClearCommand.java
``` java
/**
 * Clears tars.
 */
public class ClearCommand extends Command {

    public static final String COMMAND_WORD = "clear";
    public static final String MESSAGE_SUCCESS = "TARS has been cleared!";

    @Override
    public CommandResult execute() {
        assert model != null;
        model.resetData(Tars.getEmptyTars());

        model.getUndoableCmdHist().clear();
        model.getRedoableCmdHist().clear();

        return new CommandResult(MESSAGE_SUCCESS);
    }
}
```
###### /java/tars/logic/commands/ConfirmCommand.java
``` java
    @Override
    public CommandResult undo() {
        try {
            model.addRsvTask(rsvTask);
            model.deleteTask(toConfirm);
        } catch (DuplicateTaskException e) {
            return new CommandResult(
                    String.format(UndoCommand.MESSAGE_UNSUCCESS,
                            Messages.MESSAGE_DUPLICATE_TASK));
        } catch (TaskNotFoundException e) {
            return new CommandResult(
                    String.format(UndoCommand.MESSAGE_UNSUCCESS,
                            Messages.MESSAGE_TASK_CANNOT_BE_FOUND));
        }

        return new CommandResult(String.format(UndoCommand.MESSAGE_SUCCESS,
                StringUtil.EMPTY_STRING));
    }

```
###### /java/tars/logic/commands/ConfirmCommand.java
``` java
    @Override
    public CommandResult redo() {
        try {
            model.deleteRsvTask(rsvTask);
            model.addTask(toConfirm);
        } catch (DuplicateTaskException e) {
            return new CommandResult(
                    String.format(RedoCommand.MESSAGE_UNSUCCESS,
                            Messages.MESSAGE_DUPLICATE_TASK));
        } catch (RsvTaskNotFoundException e) {
            return new CommandResult(
                    String.format(RedoCommand.MESSAGE_UNSUCCESS,
                            Messages.MESSAGE_RSV_TASK_CANNOT_BE_FOUND));
        }

        return new CommandResult(String.format(RedoCommand.MESSAGE_SUCCESS,
                StringUtil.EMPTY_STRING));
    }

}
```
###### /java/tars/logic/commands/DeleteCommand.java
``` java
    @Override
    public CommandResult undo() {
        try {
            for (ReadOnlyTask t : deletedTasks) {
                Task taskToAdd = new Task(t);
                model.addTask(taskToAdd);
            }
            String formattedTaskList =
                    new Formatter().formatTaskList(deletedTasks);
            return new CommandResult(String.format(UndoCommand.MESSAGE_SUCCESS,
                    String.format(MESSAGE_UNDO, formattedTaskList)));
        } catch (DuplicateTaskException e) {
            return new CommandResult(
                    String.format(UndoCommand.MESSAGE_UNSUCCESS,
                            Messages.MESSAGE_DUPLICATE_TASK));
        }
    }

```
###### /java/tars/logic/commands/DeleteCommand.java
``` java
    @Override
    public CommandResult redo() {
        try {
            for (ReadOnlyTask t : deletedTasks) {
                Task taskToAdd = new Task(t);
                model.deleteTask(taskToAdd);
            }
            String formattedTaskList =
                    new Formatter().formatTaskList(deletedTasks);
            return new CommandResult(String.format(RedoCommand.MESSAGE_SUCCESS,
                    String.format(MESSAGE_REDO, formattedTaskList)));
        } catch (TaskNotFoundException e) {
            return new CommandResult(
                    String.format(RedoCommand.MESSAGE_UNSUCCESS,
                            Messages.MESSAGE_TASK_CANNOT_BE_FOUND));
        }
    }

}
```
###### /java/tars/logic/commands/EditCommand.java
``` java
    /**
     * Update task if there is a change
     * 
     * @throws IllegalValueException
     * @throws TagNotFoundException
     */
    private void updateTask() throws IllegalValueException, TagNotFoundException {
        updateNameIfChanged();
        updatePriorityIfChanged();
        updateDateTimeIfChanged();
        addTagsIfFound();
        deleteTagsIfFound();
    }

    /**
     * Update the name field if there is a change
     * 
     * @throws IllegalValueException
     */
    private void updateNameIfChanged() throws IllegalValueException {
        if (isFieldChanged(NAME_PREFIX)) {
            Name editedName =
                    new Name(argsTokenizer.getValue(NAME_PREFIX).get());
            editedTask.setName(editedName);
        }
    }

    /**
     * Update the priority if there is a change
     * 
     * @throws IllegalValueException
     */
    private void updatePriorityIfChanged() throws IllegalValueException {
        if (isFieldChanged(PRIORITY_PREFIX)) {
            Priority editedPriority =
                    new Priority(argsTokenizer.getValue(PRIORITY_PREFIX).get());
            editedTask.setPriority(editedPriority);
        }
    }

    /**
     * Update the date time if there is a change
     * 
     * @throws IllegalDateException
     */
    private void updateDateTimeIfChanged() throws IllegalDateException {
        if (isFieldChanged(DATETIME_PREFIX)) {
            String[] dateTimeArray = DateTimeUtil.parseStringToDateTime(
                    argsTokenizer.getValue(DATETIME_PREFIX).get());
            DateTime editedDateTime =
                    new DateTime(dateTimeArray[DATETIME_INDEX_OF_STARTDATE],
                            dateTimeArray[DATETIME_INDEX_OF_ENDDATE]);
            editedTask.setDateTime(editedDateTime);
        }
    }
    
    /**
     * Add tag if there is a change
     * 
     * @throws IllegalValueException
     * @throws DuplicateTagException
     * @throws TagNotFoundException
     */
    private void addTagsIfFound() throws IllegalValueException, DuplicateTagException,
            TagNotFoundException {
        Set<String> tagsToAdd = argsTokenizer.getMultipleValues(ADD_TAG_PREFIX)
                .orElse(new HashSet<>());
        updateTagList(ADD_TAG_PREFIX, tagsToAdd);
    }
    
    /**
     * Remove tag if there is a change
     * 
     * @throws IllegalValueException
     * @throws DuplicateTagException
     * @throws TagNotFoundException
     */
    private void deleteTagsIfFound() throws IllegalValueException, DuplicateTagException,
            TagNotFoundException {
        Set<String> tagsToAdd = argsTokenizer.getMultipleValues(REMOVE_TAG_PREFIX)
                .orElse(new HashSet<>());
        updateTagList(REMOVE_TAG_PREFIX, tagsToAdd);
    }
    
    /**
     * Update tag list
     * 
     * @throws IllegalValueException
     * @throws TagNotFoundException
     */
    private void updateTagList(Prefix mutatorPrefix, Set<String> mutateTagNames)
            throws IllegalValueException, TagNotFoundException {
        UniqueTagList replacement = editedTask.getTags();

        for (String mutateTagName : mutateTagNames) {
            Tag mutateTag = new Tag(mutateTagName);
            
            if (ADD_TAG_PREFIX.equals(mutatorPrefix)) {
                replacement.add(mutateTag);
            }
            
            if (REMOVE_TAG_PREFIX.equals(mutatorPrefix)) {
                replacement.remove(mutateTag);
            }
        }

        editedTask.setTags(replacement);
    }

    /**
     * Checks if the field need to be updated
     * 
     * @return true if the field need update
     */
    private boolean isFieldChanged(Prefix prefix) {
        return !argsTokenizer.getValue(prefix).orElse(StringUtil.EMPTY_STRING)
                .equals(StringUtil.EMPTY_STRING);
    }
    
    @Override
    public CommandResult undo() {
        assert model != null;
        try {
            model.replaceTask(editedTask, new Task(toBeReplacedTask));
            return new CommandResult(String.format(UndoCommand.MESSAGE_SUCCESS,
                    String.format(MESSAGE_UNDO, toBeReplacedTask)));
        } catch (DuplicateTaskException e) {
            return new CommandResult(
                    String.format(UndoCommand.MESSAGE_UNSUCCESS,
                            Messages.MESSAGE_DUPLICATE_TASK));
        }
    }

    @Override
    public CommandResult redo() {
        assert model != null;
        try {
            model.replaceTask(toBeReplacedTask, editedTask);
            return new CommandResult(String.format(RedoCommand.MESSAGE_SUCCESS,
                    String.format(MESSAGE_REDO, toBeReplacedTask)));
        } catch (DuplicateTaskException e) {
            return new CommandResult(String
                    .format(RedoCommand.MESSAGE_UNSUCCESS, e.getMessage()));
        }
    }
}
```
###### /java/tars/logic/commands/RedoCommand.java
``` java
/**
 * Redo an undoable command.
 */
public class RedoCommand extends Command {

    public static final String COMMAND_WORD = "redo";
    public static final String MESSAGE_SUCCESS = "Redo successfully.\n%1$s";
    public static final String MESSAGE_UNSUCCESS = "Redo unsuccessfully.\n%1$s";

    public static final String MESSAGE_EMPTY_REDO_CMD_HIST =
            "No more actions that can be redo.";
    public static final String MESSAGE_USAGE = COMMAND_WORD
            + ": Redo a previous command.\n" + "Example: " + COMMAND_WORD;

    @Override
    public CommandResult execute() {
        assert model != null;

        if (model.getRedoableCmdHist().isEmpty()) {
            return new CommandResult(MESSAGE_EMPTY_REDO_CMD_HIST);
        }

        UndoableCommand command =
                (UndoableCommand) model.getRedoableCmdHist().pop();
        model.getUndoableCmdHist().push(command);
        return command.redo();
    }
}
```
###### /java/tars/logic/commands/RsvCommand.java
``` java
    @Override
    public CommandResult undo() {
        if (toReserve != null) {
            try {
                return undoRsvAdd();
            } catch (RsvTaskNotFoundException e) {
                return new CommandResult(
                        String.format(UndoCommand.MESSAGE_UNSUCCESS,
                                Messages.MESSAGE_RSV_TASK_CANNOT_BE_FOUND));
            }
        } else {
            try {
                return undoRsvDelete();
            } catch (DuplicateTaskException e) {
                return new CommandResult(
                        String.format(UndoCommand.MESSAGE_UNSUCCESS,
                                Messages.MESSAGE_DUPLICATE_TASK));
            }
        }
    }

```
###### /java/tars/logic/commands/RsvCommand.java
``` java
    @Override
    public CommandResult redo() {
        if (toReserve != null) {
            try {
                return redoRsvAdd();
            } catch (DuplicateTaskException e) {
                return new CommandResult(
                        String.format(RedoCommand.MESSAGE_UNSUCCESS,
                                Messages.MESSAGE_DUPLICATE_TASK));
            }
        } else {
            try {
                return redoRsvDelete();
            } catch (RsvTaskNotFoundException e) {
                return new CommandResult(
                        String.format(RedoCommand.MESSAGE_UNSUCCESS,
                                Messages.MESSAGE_RSV_TASK_CANNOT_BE_FOUND));
            }
        }
    }

    private CommandResult undoRsvAdd() throws RsvTaskNotFoundException {
        model.deleteRsvTask(toReserve);
        return new CommandResult(String.format(UndoCommand.MESSAGE_SUCCESS,
                String.format(MESSAGE_UNDO_DELETE, toReserve)));
    }

    private CommandResult undoRsvDelete() throws DuplicateTaskException {
        for (RsvTask rsvTask : rsvTasksToDelete) {
            model.addRsvTask(rsvTask);
        }

        String addedRsvTasksList =
                new Formatter().formatRsvTaskList(rsvTasksToDelete);
        return new CommandResult(String.format(UndoCommand.MESSAGE_SUCCESS,
                String.format(MESSAGE_UNDO_ADD, addedRsvTasksList)));
    }

    private CommandResult redoRsvAdd() throws DuplicateTaskException {
        model.addRsvTask(toReserve);
        return new CommandResult(String.format(RedoCommand.MESSAGE_SUCCESS,
                String.format(MESSAGE_REDO_ADD, toReserve)));
    }

    private CommandResult redoRsvDelete() throws RsvTaskNotFoundException {
        for (RsvTask rsvTask : rsvTasksToDelete) {
            model.deleteRsvTask(rsvTask);
        }

        String deletedRsvTasksList =
                new Formatter().formatRsvTaskList(rsvTasksToDelete);
        return new CommandResult(String.format(RedoCommand.MESSAGE_SUCCESS,
                String.format(MESSAGE_REDO_DELETE, deletedRsvTasksList)));
    }
}
```
###### /java/tars/logic/commands/TagCommand.java
``` java
/**
 * Rename and delete tag from a list of tags in TARS
 */
public class TagCommand extends UndoableCommand {

    public static final String COMMAND_WORD = "tag";
    public static final String MESSAGE_USAGE =
            COMMAND_WORD + ": [/ls] [/e <INDEX> <TAG_NAME>] [/del <INDEX>]";
    public static final String MESSAGE_RENAME_TAG_SUCCESS =
            "%1$s renamed to [%2$s]";
    public static final String MESSAGE_DELETE_TAG_SUCCESS = "Deleted Tag: %1$s";

    private static final int TAG_SECOND_INDEX = 1;
    private static final int TAG_FIRST_INDEX = 0;
    private static final Prefix listPrefix = new Prefix("/ls");
    private static final Prefix editPrefix = new Prefix("/e");
    private static final Prefix deletePrefix = new Prefix("/del");

    private final Prefix prefix;
    private final String[] args;

    private ReadOnlyTag toBeRenamed;
    private ReadOnlyTag toBeDeleted;
    private Tag newTag;
    private ArrayList<ReadOnlyTask> editedTaskList;

    public TagCommand(Prefix prefix, String... args) {
        this.prefix = prefix;
        this.args = args;
    }

    @Override
    public CommandResult execute() {
        CommandResult result = null;

        try {
            if (listPrefix.equals(prefix)) {
                result = executeListTag();
            } else if (editPrefix.equals(prefix)) {
                result = executeEditTag();
            } else if (deletePrefix.equals(prefix)) {
                result = executeDeleteTag();
            }
        } catch (DuplicateTagException e) {
            return new CommandResult(e.getMessage());
        } catch (TagNotFoundException e) {
            return new CommandResult(e.getMessage());
        } catch (IllegalValueException e) {
            return new CommandResult(Tag.MESSAGE_TAG_CONSTRAINTS);
        } catch (NumberFormatException e) {
            return new CommandResult(
                    String.format(Messages.MESSAGE_INVALID_COMMAND_FORMAT,
                            TagCommand.MESSAGE_USAGE));
        }

        return result;
    }

    private CommandResult executeListTag() {
        ObservableList<? extends ReadOnlyTag> allTags =
                model.getUniqueTagList();
        return new CommandResult(new Formatter().formatTags(allTags));
    }

    private CommandResult executeEditTag() throws DuplicateTagException,
            IllegalValueException, TagNotFoundException {
        int targetedIndex = Integer.parseInt(args[TAG_FIRST_INDEX]);
        String newTagName = args[TAG_SECOND_INDEX];

        if (isInValidIndex(targetedIndex)) {
            return new CommandResult(
                    Messages.MESSAGE_INVALID_TAG_DISPLAYED_INDEX);
        }

        toBeRenamed = model.getUniqueTagList()
                .get(targetedIndex - StringUtil.DISPLAYED_INDEX_OFFSET);
        newTag = new Tag(newTagName);
        model.renameTasksWithNewTag(toBeRenamed, newTag);

        model.getUndoableCmdHist().push(this);
        return new CommandResult(
                String.format(String.format(MESSAGE_RENAME_TAG_SUCCESS,
                        toBeRenamed.getAsText(), newTagName)));
    }

    private CommandResult executeDeleteTag() throws DuplicateTagException,
            IllegalValueException, TagNotFoundException {
        int targetedIndex = Integer.parseInt(args[TAG_FIRST_INDEX]);

        if (isInValidIndex(targetedIndex)) {
            return new CommandResult(
                    Messages.MESSAGE_INVALID_TAG_DISPLAYED_INDEX);
        }

        toBeDeleted = model.getUniqueTagList()
                .get(targetedIndex - StringUtil.DISPLAYED_INDEX_OFFSET);
        editedTaskList = model.removeTagFromAllTasks(toBeDeleted);

        model.getUndoableCmdHist().push(this);
        return new CommandResult(
                String.format(MESSAGE_DELETE_TAG_SUCCESS, toBeDeleted));
    }

    /**
     * Checks if the targetedIndex is a valid index
     * 
     * @param targetedIndex
     * @return true if targetedIndex is an invalid index
     */
    private boolean isInValidIndex(int targetedIndex) {
        return targetedIndex < 1
                || model.getUniqueTagList().size() < targetedIndex;
    }

    @Override
    public CommandResult undo() {
        try {
            if (editPrefix.equals(prefix)) {
                model.renameTasksWithNewTag(newTag, new Tag(toBeRenamed));

            } else if (deletePrefix.equals(prefix)) {
                model.addTagToAllTasks(toBeDeleted, editedTaskList);
            }
        } catch (Exception e) {
            return new CommandResult(UndoCommand.MESSAGE_UNSUCCESS);
        }

        return new CommandResult(String.format(UndoCommand.MESSAGE_SUCCESS,
                StringUtil.EMPTY_STRING));
    }

    @Override
    public CommandResult redo() {
        try {
            if (editPrefix.equals(prefix)) {
                model.renameTasksWithNewTag(toBeRenamed, newTag);
            } else if (deletePrefix.equals(prefix)) {
                editedTaskList = model.removeTagFromAllTasks(toBeDeleted);
            }
        } catch (Exception e) {
            return new CommandResult(RedoCommand.MESSAGE_UNSUCCESS);
        }

        return new CommandResult(String.format(RedoCommand.MESSAGE_SUCCESS,
                StringUtil.EMPTY_STRING));
    }

}
```
###### /java/tars/logic/commands/UndoableCommand.java
``` java
/**
 * Represents a undoable command with hidden internal logic and the ability to be executed.
 */
public abstract class UndoableCommand extends Command {

    public abstract CommandResult undo();

    public abstract CommandResult redo();
}
```
###### /java/tars/logic/commands/UndoCommand.java
``` java
/**
 * Undo an undoable command.
 */
public class UndoCommand extends Command {

    public static final String COMMAND_WORD = "undo";

    public static final String MESSAGE_SUCCESS = "Undo successfully.\n%1$s";
    public static final String MESSAGE_UNSUCCESS = "Undo unsuccessfully.\n%1$s";
    public static final String MESSAGE_EMPTY_UNDO_CMD_HIST =
            "No more actions that can be undo.";
    public static final String MESSAGE_USAGE = COMMAND_WORD
            + ": Undo a previous command\n" + "Example: " + COMMAND_WORD;

    @Override
    public CommandResult execute() {
        assert model != null;

        if (model.getUndoableCmdHist().isEmpty()) {
            return new CommandResult(MESSAGE_EMPTY_UNDO_CMD_HIST);
        }

        UndoableCommand command =
                (UndoableCommand) model.getUndoableCmdHist().pop();
        model.getRedoableCmdHist().push(command);

        return command.undo();
    }

}
```
###### /java/tars/logic/parser/AddCommandParser.java
``` java
/**
 * Add command parser
 */
public class AddCommandParser extends CommandParser {

    /**
     * Parses arguments in the context of the add task command.
     * 
     * @param args full command args string
     * @return the prepared command
     */
    @Override
    public Command prepareCommand(String args) {
        ArgumentTokenizer argsTokenizer =
                new ArgumentTokenizer(tagPrefix, priorityPrefix, dateTimePrefix, recurringPrefix);
        argsTokenizer.tokenize(args);

        try {
            return new AddCommand(argsTokenizer.getPreamble().get(),
                    DateTimeUtil.parseStringToDateTime(
                            argsTokenizer.getValue(dateTimePrefix).orElse(StringUtil.EMPTY_STRING)),
                    argsTokenizer.getValue(priorityPrefix).orElse(StringUtil.EMPTY_STRING),
                    argsTokenizer.getMultipleValues(tagPrefix).orElse(new HashSet<String>()),
                    ExtractorUtil.getRecurringFromArgs(
                            argsTokenizer.getValue(recurringPrefix).orElse(StringUtil.EMPTY_STRING),
                            recurringPrefix));
        } catch (IllegalValueException ive) {
            return new IncorrectCommand(ive.getMessage());
        } catch (DateTimeException dte) {
            return new IncorrectCommand(Messages.MESSAGE_INVALID_DATE);
        } catch (NoSuchElementException nse) {
            return new IncorrectCommand(
                    String.format(MESSAGE_INVALID_COMMAND_FORMAT, AddCommand.MESSAGE_USAGE));
        }
    }

}
```
###### /java/tars/logic/parser/ArgumentTokenizer.java
``` java
/**
 * Tokenizes arguments string of the form: {@code preamble <prefix>value <prefix>value ...}<br>
 * e.g. {@code some preamble text /dt today at 3pm /t tag1 /t tag2 /ls} where prefixes are
 * {@code /dt /t}.<br>
 * 1. An argument's value can be an empty string e.g. the value of {@code /ls} in the above
 * example.<br>
 * 2. Leading and trailing whitespaces of an argument value will be discarded.<br>
 * 3. A prefix need to have leading and trailing spaces e.g. the {@code /d today at 3pm /t tag1} in
 * the above example<br>
 * 4. An argument may be repeated and all its values will be accumulated e.g. the value of
 * {@code /t} in the above example.<br>
 */
public class ArgumentTokenizer {
    private static final int EMPTY_SIZE = 0;
    private static final int INVALID_POS = -1;
    private static final int START_INDEX_POS = -1;

    private final Prefix[] prefixes;
    private HashMap<Prefix, String> prefixValueMap;
    private TreeMap<Integer, Prefix> prefixPosMap;
    private String args;

    public ArgumentTokenizer(Prefix... prefixes) {
        this.prefixes = prefixes;
        init();
    }

    public void tokenize(String args) {
        resetExtractorState();
        this.args = args;
        this.prefixPosMap = getPrefixPositon();
        extractArguments();
    }

    private void init() {
        this.args = StringUtil.EMPTY_STRING;
        this.prefixValueMap = new HashMap<Prefix, String>();
        this.prefixPosMap = new TreeMap<Integer, Prefix>();
    }

    private void resetExtractorState() {
        this.prefixValueMap.clear();
    }

    /**
     * Gets all prefix positions from arguments string
     */
    private TreeMap<Integer, Prefix> getPrefixPositon() {
        prefixPosMap = new TreeMap<Integer, Prefix>();

        for (int i = StringUtil.START_INDEX; i < prefixes.length; i++) {
            int curIndexPos = START_INDEX_POS;

            do {
                curIndexPos = args.indexOf(
                        StringUtil.STRING_WHITESPACE + prefixes[i].value,
                        curIndexPos + StringUtil.LAST_INDEX);

                if (curIndexPos >= StringUtil.START_INDEX) {
                    prefixPosMap.put(curIndexPos, prefixes[i]);
                }
            } while (curIndexPos >= StringUtil.START_INDEX);
        }

        return prefixPosMap;
    }

    /**
     * Extracts the option's prefix and arg from arguments string.
     */
    private HashMap<Prefix, String> extractArguments() {
        prefixValueMap = new HashMap<Prefix, String>();

        int endPos = args.length();

        for (Map.Entry<Integer, Prefix> entry : prefixPosMap.descendingMap()
                .entrySet()) {
            Prefix prefix = entry.getValue();
            Integer pos = entry.getKey();

            if (pos == INVALID_POS) {
                continue;
            }

            String arg = args.substring(pos, endPos).trim();
            endPos = pos;

            if (prefixValueMap.containsKey(prefix)) {
                prefixValueMap.put(prefix, prefixValueMap.get(prefix)
                        .concat(StringUtil.STRING_WHITESPACE).concat(arg));
            } else {
                prefixValueMap.put(prefix, arg);
            }

        }

        return prefixValueMap;
    }

    public Optional<String> getValue(Prefix prefix) {
        if (!prefixValueMap.containsKey(prefix)) {
            return Optional.empty();
        }

        return Optional
                .of(getMultipleValues(prefix).get().iterator().next().trim());
    }

    public Optional<Set<String>> getMultipleValues(Prefix prefix) {
        if (!prefixValueMap.containsKey(prefix)) {
            return Optional.empty();
        }
        return Optional
                .of(getMultipleFromArgs(prefixValueMap.get(prefix), prefix));
    }

    public Optional<String> getMultipleRawValues(Prefix prefix) {
        if (!prefixValueMap.containsKey(prefix)) {
            return Optional.empty();
        }

        return Optional.of(prefixValueMap.get(prefix).replaceAll(
                prefix.value + StringUtil.STRING_WHITESPACE,
                StringUtil.EMPTY_STRING));
    }

    public int numPrefixFound() {
        return prefixPosMap.size();
    }

    public Optional<String> getPreamble() {
        if (args.trim().length() == StringUtil.EMPTY_STRING_LENGTH) {
            return Optional.empty();
        }

        if (prefixPosMap.size() == EMPTY_SIZE) {
            return Optional.of(args.trim());
        } else if (prefixPosMap.firstKey() == StringUtil.START_INDEX) {
            return Optional.empty();
        }

        return Optional.of(
                args.substring(StringUtil.START_INDEX, prefixPosMap.firstKey())
                        .trim());
    }

    private Set<String> getMultipleFromArgs(String multipleArguments,
            Prefix prefix) {
        if (multipleArguments.isEmpty()) {
            return Collections.emptySet();
        }

        multipleArguments = multipleArguments.trim();

        // replace first delimiter prefix, then split
        List<String> multipleArgList = Arrays.asList(multipleArguments
                .replaceFirst(prefix.value + StringUtil.STRING_WHITESPACE,
                        StringUtil.EMPTY_STRING)
                .split(StringUtil.STRING_WHITESPACE + prefix.value
                        + StringUtil.STRING_WHITESPACE));

        for (int i = StringUtil.START_INDEX; i < multipleArgList.size(); i++) {
            multipleArgList.set(i, multipleArgList.get(i).trim());
        }

        return new HashSet<>(multipleArgList);
    }

}
```
###### /java/tars/logic/parser/CommandParser.java
``` java
/**
 * Represents a parser command with hidden internal logic and the ability to be executed.
 */
public abstract class CommandParser {
    protected static final Prefix namePrefix = new Prefix("/n");
    protected static final Prefix tagPrefix = new Prefix("/t");
    protected static final Prefix priorityPrefix = new Prefix("/p");
    protected static final Prefix dateTimePrefix = new Prefix("/dt");
    protected static final Prefix recurringPrefix = new Prefix("/r");
    protected static final Prefix deletePrefix = new Prefix("/del");
    protected static final Prefix addTagPrefix = new Prefix("/ta");
    protected static final Prefix removeTagPrefix = new Prefix("/tr");
    protected static final Prefix donePrefix = new Prefix("/do");
    protected static final Prefix undonePrefix = new Prefix("/ud");
    protected static final Prefix listPrefix = new Prefix("/ls");
    protected static final Prefix editPrefix = new Prefix("/e");

    public abstract Command prepareCommand(String args);
}
```
###### /java/tars/logic/parser/Parser.java
``` java
/**
 * Parses user input.
 */
public class Parser {

    private static final String PARSER_MATCHER_ARGUMENTS = "arguments";

    private static final String PARSER_MATCHER_COMMANDWORD = "commandWord";

    /**
     * Used for initial separation of command word and args.
     */
    private static final Pattern BASIC_COMMAND_FORMAT =
            Pattern.compile("(?<commandWord>\\S+)(?<arguments>.*)");

    /**
     * Used for mapping a list of known command
     */
    private static Map<String, Class<? extends CommandParser>> commandParserMap =
            new HashMap<String, Class<? extends CommandParser>>();

    static {
        fillCommandMap();
    }

    private static void fillCommandMap() {
        commandParserMap.put(AddCommand.COMMAND_WORD, AddCommandParser.class);
        commandParserMap.put(RsvCommand.COMMAND_WORD, RsvCommandParser.class);
        commandParserMap.put(EditCommand.COMMAND_WORD, EditCommandParser.class);
        commandParserMap.put(DeleteCommand.COMMAND_WORD,
                DeleteCommandParser.class);
        commandParserMap.put(ConfirmCommand.COMMAND_WORD,
                ConfirmCommandParser.class);
        commandParserMap.put(ClearCommand.COMMAND_WORD,
                ClearCommandParser.class);
        commandParserMap.put(FindCommand.COMMAND_WORD, FindCommandParser.class);
        commandParserMap.put(ListCommand.COMMAND_WORD, ListCommandParser.class);
        commandParserMap.put(UndoCommand.COMMAND_WORD, UndoCommandParser.class);
        commandParserMap.put(RedoCommand.COMMAND_WORD, RedoCommandParser.class);
        commandParserMap.put(DoCommand.COMMAND_WORD, DoCommandParser.class);
        commandParserMap.put(UdCommand.COMMAND_WORD, UdCommandParser.class);
        commandParserMap.put(CdCommand.COMMAND_WORD, CdCommandParser.class);
        commandParserMap.put(TagCommand.COMMAND_WORD, TagCommandParser.class);
        commandParserMap.put(FreeCommand.COMMAND_WORD, FreeCommandParser.class);
        commandParserMap.put(ExitCommand.COMMAND_WORD, ExitCommandParser.class);
        commandParserMap.put(HelpCommand.COMMAND_WORD, HelpCommandParser.class);
    }

    /**
     * Parses user input into command for execution.
     *
     * @param userInput full user input string
     * @return the command based on the user input
     */
    public Command parseCommand(String userInput) {
        final Matcher matcher = BASIC_COMMAND_FORMAT.matcher(userInput.trim());
        if (!matcher.matches()) {
            return new IncorrectCommand(String.format(
                    MESSAGE_INVALID_COMMAND_FORMAT, HelpCommand.MESSAGE_USAGE));
        }

        final String commandWord = matcher.group(PARSER_MATCHER_COMMANDWORD);
        final String arguments = matcher.group(PARSER_MATCHER_ARGUMENTS);

        if (!commandParserMap.containsKey(commandWord)) {
            return new IncorrectCommandParser().prepareCommand(arguments);
        }

        try {
            return commandParserMap.get(commandWord).newInstance()
                    .prepareCommand(arguments);
        } catch (Exception ex) {
            return new IncorrectCommandParser().prepareCommand(arguments);
        }
    }

}
```
###### /java/tars/logic/parser/Prefix.java
``` java
/**
 * A prefix that marks the beginning of an argument e.g. '/t' in 'add CS2103 Project Meeting /t
 * meeting'
 */
public class Prefix {
    private static final int HASHCODE_NULL_VALUE = 0;
    public final String value;

    public Prefix(String value) {
        this.value = value;
    }

    @Override
    public boolean equals(Object other) {
        if (!(other instanceof Prefix)) {
            return false;
        }

        if (other == this) {
            return true;
        }

        Prefix otherPrefix = (Prefix) other;
        return otherPrefix.value.equals(this.value);
    }

    @Override
    public int hashCode() {
        return this.value == null ? HASHCODE_NULL_VALUE : this.value.hashCode();
    }

}
```
###### /java/tars/logic/parser/RedoCommandParser.java
``` java
/**
 * Redo command parser
 */
public class RedoCommandParser extends CommandParser {

    @Override
    public Command prepareCommand(String args) {
        if (!args.isEmpty()) {
            return new IncorrectCommand(String.format(
                    MESSAGE_INVALID_COMMAND_FORMAT, RedoCommand.MESSAGE_USAGE));
        }
        return new RedoCommand();
    }

}
```
###### /java/tars/logic/parser/TagCommandParser.java
``` java
/**
 * Tag command parser
 */
public class TagCommandParser extends CommandParser {
    private static final Pattern TAG_EDIT_COMMAND_FORMAT =
            Pattern.compile("\\d+ \\w+$");

    /**
     * Parses arguments in the context of the tag command.
     * 
     * @param args full command args string
     * @return the prepared command
     */
    @Override
    public Command prepareCommand(String args) {
        ArgumentTokenizer argsTokenizer =
                new ArgumentTokenizer(listPrefix, editPrefix, deletePrefix);
        argsTokenizer.tokenize(args);

        if (argsTokenizer.getValue(listPrefix).isPresent()) {
            return new TagCommand(listPrefix);
        }

        if (argsTokenizer.getValue(editPrefix).isPresent()) {
            String editArgs = argsTokenizer.getValue(editPrefix).get();
            final Matcher matcher = TAG_EDIT_COMMAND_FORMAT.matcher(editArgs);
            if (matcher.matches()) {
                return new TagCommand(editPrefix,
                        editArgs.split(StringUtil.STRING_WHITESPACE));
            }
        }

        if (argsTokenizer.getValue(deletePrefix).isPresent()) {
            String index = argsTokenizer.getValue(deletePrefix).get();
            return new TagCommand(deletePrefix, index);
        }

        return new IncorrectCommand(String.format(
                MESSAGE_INVALID_COMMAND_FORMAT, TagCommand.MESSAGE_USAGE));
    }

}
```
###### /java/tars/logic/parser/UndoCommandParser.java
``` java
/**
 * Undo command parser
 */
public class UndoCommandParser extends CommandParser {

    @Override
    public Command prepareCommand(String args) {
        if (!args.isEmpty()) {
            return new IncorrectCommand(String.format(
                    MESSAGE_INVALID_COMMAND_FORMAT, UndoCommand.MESSAGE_USAGE));
        }
        return new UndoCommand();
    }

}
```
###### /java/tars/model/Model.java
``` java
    /** 
     * Rename all task with the old tag with new tag name 
     */
    void renameTasksWithNewTag(ReadOnlyTag toBeRenamed, Tag newTag)
            throws IllegalValueException, TagNotFoundException,
            DuplicateTagException;

    /** Remove the tag from all task */
    ArrayList<ReadOnlyTask> removeTagFromAllTasks(ReadOnlyTag toBeDeleted)
            throws DuplicateTagException, IllegalValueException,
            TagNotFoundException;

    /** Add tag to all task */
    void addTagToAllTasks(ReadOnlyTag toBeAdded,
            ArrayList<ReadOnlyTask> toBeEdited) throws DuplicateTagException,
            IllegalValueException, TagNotFoundException;

```
###### /java/tars/model/Model.java
``` java
    /**
     * Returns the undoable command history stack
     */
    Stack<Command> getUndoableCmdHist();

    /** Returns the redoable command history stack */
    Stack<Command> getRedoableCmdHist();
    
```
###### /java/tars/model/ModelManager.java
``` java
    @Override
    public synchronized void renameTasksWithNewTag(ReadOnlyTag toBeRenamed,
            Tag newTag) throws IllegalValueException, TagNotFoundException,
            DuplicateTagException {

        tars.getUniqueTagList().update(toBeRenamed, newTag);
        tars.renameTasksWithNewTag(toBeRenamed, newTag);

        indicateTarsChanged();
    }

```
###### /java/tars/model/ModelManager.java
``` java
    @Override
    public synchronized ArrayList<ReadOnlyTask> removeTagFromAllTasks(
            ReadOnlyTag toBeDeleted)
            throws TagNotFoundException, IllegalValueException {

        ArrayList<ReadOnlyTask> editedTasks =
                tars.removeTagFromAllTasks(toBeDeleted);
        tars.getUniqueTagList().remove(new Tag(toBeDeleted));

        indicateTarsChanged();
        return editedTasks;
    }

```
###### /java/tars/model/ModelManager.java
``` java
    @Override
    public synchronized void addTagToAllTasks(ReadOnlyTag toBeAdded,
            ArrayList<ReadOnlyTask> allTasks) throws DuplicateTagException,
            IllegalValueException, TagNotFoundException {
        tars.addTagToAllTasks(toBeAdded, allTasks);
        tars.getUniqueTagList().add(new Tag(toBeAdded));

        indicateTarsChanged();
    }

    @Override
    public synchronized void deleteTask(ReadOnlyTask target)
            throws TaskNotFoundException {
        tars.removeTask(target);
        indicateTarsChanged();
    }

    @Override
    public synchronized void addTask(Task task) throws DuplicateTaskException {
        tars.addTask(task);
        raise(new TaskAddedEvent(tars.getTaskList().size(), task));
        updateFilteredListToShowAll();
        indicateTarsChanged();
    }

    @Override
    public synchronized void deleteRsvTask(RsvTask target)
            throws RsvTaskNotFoundException {
        tars.removeRsvTask(target);
        indicateTarsChanged();
    }

    @Override
    public synchronized void addRsvTask(RsvTask rsvTask)
            throws DuplicateTaskException {
        tars.addRsvTask(rsvTask);
        raise(new RsvTaskAddedEvent(tars.getRsvTaskList().size(), rsvTask));
        raise(new RsvTaskAddedEvent(tars.getRsvTaskList().size(), rsvTask));
        indicateTarsChanged();
    }

```
###### /java/tars/model/ModelManager.java
``` java
    @Override
    public synchronized void replaceTask(ReadOnlyTask toUndo, Task replacement)
            throws DuplicateTaskException {
        tars.replaceTask(toUndo, replacement);
        indicateTarsChanged();
    }

```
###### /java/tars/model/tag/ReadOnlyTag.java
``` java
/**
 * Unmodifiable view of tars
 */
public interface ReadOnlyTag {
    public String getAsText();
}
```
###### /java/tars/model/Tars.java
``` java
    public void addTag(Tag t) throws UniqueTagList.DuplicateTagException {
        tags.add(t);
    }

```
###### /java/tars/model/Tars.java
``` java
    public void removeTag(Tag t) throws UniqueTagList.TagNotFoundException {
        tags.remove(t);
    }

```
###### /java/tars/model/Tars.java
``` java
    /**
     * Rename all task with the new tag
     * 
     * @param toBeRenamed tag to be replaced with new the new tag
     * @param newTag new tag
     * @throws IllegalValueException if the given tag name string is invalid.
     * @throws TagNotFoundException if there is no matching tags.
     */
    public void renameTasksWithNewTag(ReadOnlyTag toBeRenamed, Tag newTag)
            throws IllegalValueException, TagNotFoundException {

        for (int i = StringUtil.START_INDEX; i < tasks.getInternalList()
                .size(); i++) {
            Task toEdit = new Task(tasks.getInternalList().get(i));
            UniqueTagList tags = toEdit.getTags();
            if (tags.contains(new Tag(toBeRenamed))) {
                tags.update(toBeRenamed, newTag);
                toEdit.setTags(tags);
                tasks.getInternalList().set(i, toEdit);
            }
        }
    }

    /**
     * Remove the tag from all tasks
     * 
     * @param toBeDeleted
     * @throws IllegalValueException if the given tag name string is invalid.
     * @throws TagNotFoundException if there is no matching tags.
     */
    public ArrayList<ReadOnlyTask> removeTagFromAllTasks(
            ReadOnlyTag toBeDeleted) throws IllegalValueException,
            TagNotFoundException, DuplicateTagException {
        ArrayList<ReadOnlyTask> editedTasks = new ArrayList<ReadOnlyTask>();

        for (int i = StringUtil.START_INDEX; i < tasks.getInternalList()
                .size(); i++) {
            Task toEdit = new Task(tasks.getInternalList().get(i));
            UniqueTagList tags = toEdit.getTags();
            if (tags.contains(new Tag(toBeDeleted))) {
                tags.remove(new Tag(toBeDeleted));
                toEdit.setTags(tags);
                tasks.getInternalList().set(i, toEdit);
                editedTasks.add(toEdit);
            }
        }

        return editedTasks;
    }

    /**
     * Remove the tag from all tasks
     * 
     * @param toBeDeleted
     * @throws IllegalValueException if the given tag name string is invalid.
     * @throws TagNotFoundException if there is no matching tags.
     */
    public void addTagToAllTasks(ReadOnlyTag toBeAdded,
            ArrayList<ReadOnlyTask> allTasks) throws IllegalValueException,
            TagNotFoundException, DuplicateTagException {

        for (int i = StringUtil.START_INDEX; i < allTasks.size(); i++) {
            for (int j = StringUtil.START_INDEX; j < tasks.getInternalList()
                    .size(); j++) {
                Task toEdit = new Task(tasks.getInternalList().get(j));
                if (toEdit.equals(allTasks.get(i))) {
                    UniqueTagList tags = toEdit.getTags();
                    tags.add(new Tag(toBeAdded));
                    toEdit.setTags(tags);
                    tasks.getInternalList().set(i, toEdit);
                }
            }
        }
    }

```
###### /java/tars/ui/CommandBox.java
``` java
    /**
     * Handle any undo and redo request
     */
    private void handleUndoAndRedoKeyRequest(String commandWord) {
        if (UndoCommand.COMMAND_WORD.equals(commandWord)) {
            mostRecentResult = logic.execute(UndoCommand.COMMAND_WORD);
        } else if (RedoCommand.COMMAND_WORD.equals(commandWord)) {
            mostRecentResult = logic.execute(RedoCommand.COMMAND_WORD);
        }
        resultDisplay.postMessage(mostRecentResult.feedbackToUser);
        logger.info(String.format(LOG_MESSAGE_RESULT,
                mostRecentResult.feedbackToUser));
    }

```
###### /java/tars/ui/formatter/DateFormatter.java
``` java
/**
 * Container for formatting dates
 */
public class DateFormatter {
    private static final String DATE_FORMAT_DASH = " - ";
    private static final DateTimeFormatter DATE_FORMAT =
            DateTimeFormatter.ofPattern("E, MMM dd yyyy");
    private static final DateTimeFormatter TIME_FORMAT =
            DateTimeFormatter.ofPattern("hh:mm a");
    private static final DateTimeFormatter NORMAL_DATETIME_FORMAT =
            DateTimeFormatter.ofPattern("E, MMM dd yyyy hh:mm a");
    private static final DateTimeFormatter SAME_DAY_DATE_FORMAT =
            DateTimeFormatter.ofPattern("ddMMyyyy");

    private static final String TODAY_PREFIX_TEXT = "Today at ";
    private static final String TOMORROW_PREFIX_TEXT = "Tomorrow at ";

    public static String formatDate(DateTime dateTime) {
        LocalDateTime startDateTime = dateTime.getStartDate();
        LocalDateTime endDateTime = dateTime.getEndDate();

        if (startDateTime != null && endDateTime == null) {
            return DateFormatter.generateSingleDateFormat(startDateTime);
        } else if (startDateTime == null && endDateTime != null) {
            return DateFormatter.generateSingleDateFormat(endDateTime);
        } else if (startDateTime != null && endDateTime != null) {
            return DateFormatter.generateDateRangeFormat(startDateTime,
                    endDateTime);
        } else {
            return StringUtil.EMPTY_STRING;
        }
    }

    public static String generateSingleDateFormat(LocalDateTime firstDate) {
        if (isToday(firstDate)) {
            return TODAY_PREFIX_TEXT + TIME_FORMAT.format(firstDate);
        } else if (isTomorrow(firstDate)) {
            return TOMORROW_PREFIX_TEXT + TIME_FORMAT.format(firstDate);
        } else {
            return NORMAL_DATETIME_FORMAT.format(firstDate);
        }
    }

    public static String generateDateRangeFormat(LocalDateTime firstDate,
            LocalDateTime secondDate) {
        if (isSameDay(firstDate, secondDate)) {
            return DATE_FORMAT.format(firstDate) + StringUtil.STRING_WHITESPACE
                    + TIME_FORMAT.format(firstDate) + DATE_FORMAT_DASH
                    + TIME_FORMAT.format(secondDate);
        } else {
            return NORMAL_DATETIME_FORMAT.format(firstDate) + DATE_FORMAT_DASH
                    + NORMAL_DATETIME_FORMAT.format(secondDate);
        }
    }

    private static boolean isToday(LocalDateTime firstDate) {
        return isSameDay(firstDate, LocalDateTime.now());
    }

    private static boolean isTomorrow(LocalDateTime firstDate) {
        return isSameDay(firstDate, LocalDateTime.now().plusDays(1));
    }

    private static boolean isSameDay(LocalDateTime firstDate,
            LocalDateTime secondDate) {
        return SAME_DAY_DATE_FORMAT.format(firstDate)
                .equals(SAME_DAY_DATE_FORMAT.format(secondDate));
    }

}
```
###### /java/tars/ui/formatter/Formatter.java
``` java
/**
 * Container for formatting
 */
public class Formatter {
    private static final int INITIAL_COUNT = 1;
    private static final String STRING_TASKS = "tasks";
    private static final String STRING_TAGS = "tags";

    /** Format of indexed list item */
    private static final String MESSAGE_INDEXED_LIST_ITEM = "%1$d.\t%2$s";

    public static final String EMPTY_LIST_MESSAGE = "0 %1$s listed.";
    public static final String DATETIME_FORMAT_STRING = "[%1$s] %2$s\n\n";
    private static String OVERDUED_TASKS_STRING = "[%1$s] %2$s\n";

    public String formatTags(List<? extends ReadOnlyTag> tags) {
        final List<String> formattedTags = new ArrayList<>();

        if (tags.size() == 0) {
            return String.format(EMPTY_LIST_MESSAGE, STRING_TAGS);
        }

        for (ReadOnlyTag tag : tags) {
            formattedTags.add(tag.getAsText());
        }
        return asIndexedList(formattedTags);
    }

    public String formatTaskList(List<? extends ReadOnlyTask> taskList) {
        final List<String> formattedTasks = new ArrayList<>();

        if (taskList.size() == 0) {
            return String.format(EMPTY_LIST_MESSAGE, STRING_TASKS);
        }

        for (ReadOnlyTask task : taskList) {
            formattedTasks.add(task.getAsText());
        }
        return asIndexedList(formattedTasks);
    }

    public String formatRsvTaskList(List<? extends RsvTask> rsvTaskList) {
        final List<String> formattedTasks = new ArrayList<>();

        if (rsvTaskList.size() == 0) {
            return String.format(EMPTY_LIST_MESSAGE, STRING_TASKS);
        }

        for (RsvTask task : rsvTaskList) {
            formattedTasks.add(task.toString());
        }
        return asIndexedList(formattedTasks);
    }

    /**
     * Formats a list of strings as an indexed list.
     */
    private static String asIndexedList(List<String> listItems) {
        final StringBuilder formatted = new StringBuilder();
        int displayIndex = StringUtil.DISPLAYED_INDEX_OFFSET;
        for (String listItem : listItems) {
            formatted.append(getIndexedListItem(displayIndex++, listItem))
                    .append(StringUtil.STRING_NEWLINE);
        }
        return formatted.toString();
    }

    /**
     * Formats a string as an indexed list item.
     *
     * @param visibleIndex index for this listing
     */
    private static String getIndexedListItem(int visibleIndex,
            String listItem) {
        return String.format(MESSAGE_INDEXED_LIST_ITEM, visibleIndex, listItem);
    }

```
###### /java/tars/ui/StatusBarFooter.java
``` java
    private void setSaveLocation(String location) {
        this.saveLocationLabel.setText(location);
    }

    private void addSaveLocation() {
        this.saveLocationStatus = new StatusBar();
        this.saveLocationLabel = new Label();
        this.saveLocationStatus.setText(StringUtil.EMPTY_STRING);
        this.saveLocationStatus.getRightItems().add(saveLocationLabel);
        FxViewUtil.applyAnchorBoundaryParameters(saveLocationStatus,
                BOUNDARY_PARAMETERS_ZERO, BOUNDARY_PARAMETERS_ZERO,
                BOUNDARY_PARAMETERS_ZERO, BOUNDARY_PARAMETERS_ZERO);
        saveLocStatusBarPane.getChildren().add(saveLocationStatus);
    }

    private void setSyncStatus(String status) {
        this.syncStatusLabel.setText(status);
    }

    private void addSyncStatus() {
        this.syncStatus = new StatusBar();
        this.syncStatusLabel = new Label();
        this.syncStatus.setText(StringUtil.EMPTY_STRING);
        this.syncStatus.getLeftItems().add(syncStatusLabel);
        FxViewUtil.applyAnchorBoundaryParameters(syncStatus,
                BOUNDARY_PARAMETERS_ZERO, BOUNDARY_PARAMETERS_ZERO,
                BOUNDARY_PARAMETERS_ZERO, BOUNDARY_PARAMETERS_ZERO);
        syncStatusBarPane.getChildren().add(syncStatus);
    }

```
