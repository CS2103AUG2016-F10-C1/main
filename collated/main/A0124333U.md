# A0124333U
###### \java\tars\commons\core\KeyCombinations.java
``` java
 */
import javafx.scene.input.KeyCode;
import javafx.scene.input.KeyCodeCombination;
import javafx.scene.input.KeyCombination;

public class KeyCombinations {

    public static final KeyCombination KEY_COMB_CTRL_RIGHT_ARROW = new KeyCodeCombination(KeyCode.RIGHT,
            KeyCombination.CONTROL_DOWN);
    public static final KeyCombination KEY_COMB_CTRL_LEFT_ARROW = new KeyCodeCombination(KeyCode.LEFT,
            KeyCombination.CONTROL_DOWN);
    
    public static final KeyCombination KEY_COMB_CTRL_Z =
            new KeyCodeCombination(KeyCode.Z, KeyCombination.CONTROL_DOWN);
    public static final KeyCombination KEY_COMB_CTRL_Y =
            new KeyCodeCombination(KeyCode.Y, KeyCombination.CONTROL_DOWN);
    
}
```
###### \java\tars\commons\events\storage\TarsStorageDirectoryChangedEvent.java
``` java
 */
public class TarsStorageDirectoryChangedEvent extends BaseEvent {

    private final String newFilePath;
    private final Config newConfig;

    public TarsStorageDirectoryChangedEvent(String newFilePath,
            Config newConfig) {
        this.newFilePath = newFilePath;
        this.newConfig = newConfig;
    }

    public String getNewFilePath() {
        return this.newFilePath;
    }

    public Config getNewConfig() {
        return this.newConfig;
    }

    @Override
    public String toString() {
        return "File Path changed to " + this.newFilePath;
    }

}
```
###### \java\tars\commons\events\ui\KeyCombinationPressedEvent.java
``` java
 */
public class KeyCombinationPressedEvent extends BaseEvent {

    private KeyCombination keyComb;

    public KeyCombinationPressedEvent(KeyCombination keyComb) {
        this.keyComb = keyComb;
    }

    public KeyCombination getKeyCombination() {
        return keyComb;
    }

    @Override
    public String toString() {
        return this.getClass().getSimpleName();
    }

}
```
###### \java\tars\commons\util\DateTimeUtil.java
``` java
     * @param dateTimeSource
     * @param dateTimeQuery
     */
    public static boolean isDateTimeWithinRange(DateTime dateTimeSource, DateTime dateTimeQuery) {

        DateTime dateTime1 = new DateTime();
        DateTime dateTime2 = new DateTime();

        // Return false if task is a floating task (i.e. no start or end
        // dateTime
        if (dateTimeSource.getEndDate() == null) {
            return false;
        }

        fillDateTime(dateTime1, dateTimeSource);
        fillDateTime(dateTime2, dateTimeQuery);

        if (dateTime1.getEndDate().isBefore(dateTime2.getStartDate())
                || dateTime1.getStartDate().isAfter(dateTime2.getEndDate())) {
            return false;
        }

        return true;
    }

    private static DateTime fillDateTime(DateTime dateTimeToFill, DateTime filledDateTime) {
        dateTimeToFill.setEndDateTime(filledDateTime.getEndDate());

        if (filledDateTime.getStartDate() != null) {
            dateTimeToFill.setStartDateTime(filledDateTime.getStartDate());
        } else {
            dateTimeToFill.setStartDateTime(filledDateTime.getEndDate());
        }
        return dateTimeToFill;
    }

    /**
     * Returns an arraylist of free datetime slots in a specified date
     * 
     */
    public static ArrayList<DateTime> getListOfFreeTimeSlotsInDate(DateTime dateToCheck,
            ArrayList<DateTime> listOfFilledTimeSlotsInDate) {
        ArrayList<DateTime> listOfFreeTimeSlots = new ArrayList<DateTime>();
        LocalDateTime startDateTime = dateToCheck.getStartDate();
        LocalDateTime endDateTime;

        for (DateTime dt : listOfFilledTimeSlotsInDate) {
            if (dt.getStartDate() == null) {
                continue;
            } else {
                endDateTime = dt.getStartDate();
            }

            if (startDateTime.isBefore(endDateTime)) {
                listOfFreeTimeSlots
                .add(new DateTime(startDateTime, endDateTime));
            }

            if (startDateTime.isBefore(dt.getEndDate())) {
                startDateTime = dt.getEndDate();
            }
        }

        if (startDateTime.isBefore(dateToCheck.getEndDate())) {
            listOfFreeTimeSlots
            .add(new DateTime(startDateTime, dateToCheck.getEndDate()));
        }

        return listOfFreeTimeSlots;
    }

    public static String getDayAndDateString(DateTime dateTime) {
        StringBuilder sb = new StringBuilder();

        sb.append(dateTime.getEndDate().getDayOfWeek()
                .getDisplayName(TextStyle.FULL, Locale.ENGLISH)).append(StringUtil.STRING_COMMA)
        .append(dateTime.getEndDate()
                .format(stringFormatterWithoutTime));

        return sb.toString();
    }

    public static String getStringOfFreeDateTimeInDate(DateTime dateToCheck,
            ArrayList<DateTime> listOfFreeTimeSlotsInDate) {
        StringBuilder sb = new StringBuilder();

        sb.append(getDayAndDateString(dateToCheck)).append(StringUtil.STRING_COLON);

        int counter = 1;

        for (DateTime dt : listOfFreeTimeSlotsInDate) {
            sb.append(StringUtil.STRING_NEWLINE).append(counter).append(StringUtil.STRING_FULLSTOP)
            .append(dt.getStartDate()
                    .format(stringFormatterWithoutDate))
            .append("hrs to ")
            .append(dt.getEndDate().format(stringFormatterWithoutDate))
            .append("hrs (")
            .append(getDurationInMinutesBetweenTwoLocalDateTime(
                    dt.getStartDate(), dt.getEndDate()))
            .append(")");
            counter++;
        }

        return sb.toString();

    }

    public static String getDurationInMinutesBetweenTwoLocalDateTime(LocalDateTime startDateTime,
            LocalDateTime endDateTime) {
        Duration duration = Duration.between(startDateTime, endDateTime);
        long hours = duration.toHours();
        long minutes = duration.toMinutes() % 60;

        return hours + " hr " + minutes + " min";
    }

    /**
     * Modify the date based on the new hour, min and sec
     * 
```
###### \java\tars\logic\commands\CdCommand.java
``` java
 */
public class CdCommand extends Command {

    public static final String COMMAND_WORD = "cd";

    public static final String MESSAGE_USAGE = COMMAND_WORD + ": Changes the directory of the "
            + "TARS storage file.\n" + "Parameters: <FILE_PATH.xml> \n" + "Example: " + COMMAND_WORD
            + " data/tars.xml";

    public static final String MESSAGE_INVALID_FILEPATH = "Invalid file path. File paths should not"
            + " include any white spaces and should end with the file type .xml \n" + "Example: " + COMMAND_WORD
            + " data/tars.xml";

    public static final String MESSAGE_SUCCESS = "Change Directory Success! Directory of TARS storage file"
            + " changed to: '%1$s'.";

    public static final String MESSAGE_FAILURE = "Unable to write to location, please choose another directory";

    private final String newFilePath;
    private final static String xmlFileExt = "xml";;
    private Storage storageUpdater = new StorageManager();

    public CdCommand(String filepath) {
        this.newFilePath = filepath;
    }

    public final static String getXmlFileExt() {
        return xmlFileExt;
    }

    @Override
    public String toString() {
        return this.newFilePath;
    }

    @Override
    public CommandResult execute() {
        Config newConfig = new Config();
        newConfig.setTarsFilePath(newFilePath);
        XmlTarsStorage xmlTarsStorage = new XmlTarsStorage(newFilePath);

        try {
            xmlTarsStorage.saveTars(model.getTars(), newFilePath); // try to save TARS data into new file
            
            if (!isFileSavedSuccessfully(newFilePath)) {
                return new CommandResult(MESSAGE_FAILURE); 
            }
            
            storageUpdater.updateTarsStorageDirectory(newFilePath, newConfig);
            ConfigUtil.updateConfig(newConfig);

            return new CommandResult(String.format(MESSAGE_SUCCESS, newFilePath));
            
        } catch (IOException ioe) {
            return new CommandResult(MESSAGE_FAILURE);
        }
    }

    private boolean isFileSavedSuccessfully(String filePath) {
        Path path = Paths.get(filePath);
        return Files.exists(path);
    }

}
```
###### \java\tars\logic\commands\ConfirmCommand.java
``` java
 */
public class ConfirmCommand extends UndoableCommand {

    public static final String COMMAND_WORD = "confirm";

    public static final String MESSAGE_USAGE =
            COMMAND_WORD + ": Confirms a datetime for a reserved task"
                    + " and adds it to the task list.\n"
                    + "Parameters: <RSV_TASK_INDEX> <DATETIME_INDEX> [/p PRIORITY] [/t TAG_NAME ...]\n"
                    + "Example: " + COMMAND_WORD + " 1 3 /p h /t tag";

    public static final String MESSAGE_CONFIRM_SUCCESS =
            "Task Confirmation Success! New task added: %1$s";
    private String conflictingTaskList = "";

    private final int taskIndex;
    private final int dateTimeIndex;
    private final String priority;
    private final Set<Tag> tagSet = new HashSet<>();

    private Task toConfirm;
    private RsvTask rsvTask;

    public ConfirmCommand(int taskIndex, int dateTimeIndex, String priority,
            Set<String> tags) throws IllegalValueException {
        this.taskIndex = taskIndex;
        this.dateTimeIndex = dateTimeIndex;
        this.priority = priority;

        for (String tagName : tags) {
            tagSet.add(new Tag(tagName));
        }
    }

    @Override
    public CommandResult execute() {
        assert model != null;
        UnmodifiableObservableList<RsvTask> lastShownList =
                model.getFilteredRsvTaskList();

        if (lastShownList.size() < taskIndex) {
            indicateAttemptToExecuteIncorrectCommand();
            return new CommandResult(
                    Messages.MESSAGE_INVALID_RSV_TASK_DISPLAYED_INDEX);
        }

        rsvTask = lastShownList.get(taskIndex - 1);

        if (rsvTask.getDateTimeList().size() < dateTimeIndex) {
            indicateAttemptToExecuteIncorrectCommand();
            return new CommandResult(
                    Messages.MESSAGE_INVALID_DATETIME_DISPLAYED_INDEX);
        }

        try {
            toConfirm = new Task(rsvTask.getName(),
                    rsvTask.getDateTimeList().get((dateTimeIndex - 1)),
                    new Priority(priority), new Status(),
                    new UniqueTagList(tagSet));
        } catch (IllegalValueException ive) {
            return new CommandResult(String
                    .format(MESSAGE_INVALID_COMMAND_FORMAT, MESSAGE_USAGE));
        }

        try {
            model.deleteRsvTask(rsvTask);
        } catch (RsvTaskNotFoundException rtnfe) {
            return new CommandResult(Messages.MESSAGE_RSV_TASK_CANNOT_BE_FOUND);
        }

        try {
            conflictingTaskList +=
                    model.getTaskConflictingDateTimeWarningMessage(
                            toConfirm.getDateTime());
            model.addTask(toConfirm);
        } catch (DuplicateTaskException e) {
            return new CommandResult(Messages.MESSAGE_DUPLICATE_TASK);
        }

        model.getUndoableCmdHist().push(this);
        return new CommandResult(getSuccessMessageSummary());
    }

    private String getSuccessMessageSummary() {
        String summary =
                String.format(MESSAGE_CONFIRM_SUCCESS, toConfirm.toString());

        if (!conflictingTaskList.isEmpty()) {
            summary += StringUtil.STRING_NEWLINE
                    + Messages.MESSAGE_CONFLICTING_TASKS_WARNING
                    + conflictingTaskList;
        }

        return summary;
    }

```
###### \java\tars\logic\commands\FreeCommand.java
``` java
 */
public class FreeCommand extends Command {

    public static final String COMMAND_WORD = "free";

    public static final String MESSAGE_USAGE =
            COMMAND_WORD + ": Suggests free timeslots in a specified day.\n"
                    + "Parameters: <DATETIME>\n" + "Example: free 29/10/2016";

    public static final String MESSAGE_DATE_RANGE_DETECTED = "Range of datetime detected. Please only input a single datetime";
    public static final String MESSAGE_SUCCESS = "Free timeslots on %1$s";
    public static final String MESSAGE_FREE_DAY = "You have no event tasks or reserved event tasks on %1$s";
    public static final String MESSAGE_NO_FREE_TIMESLOTS = "You have no free time slots on %1$s";

    private DateTime dateToCheck;

    public FreeCommand(DateTime dateToCheck) {
        this.dateToCheck = dateToCheck;
        //Ensure that dateToCheck covers the whole day
        this.dateToCheck.setStartDateTime(dateToCheck.getEndDate().withHour(0).withMinute(0).withSecond(0));
        this.dateToCheck.setEndDateTime(dateToCheck.getEndDate().withHour(23).withMinute(59).withSecond(59));
    }

    @Override
    public CommandResult execute() {
        ArrayList<DateTime> listOfFilledTimeSlots = model.getListOfFilledTimeSlotsInDate(dateToCheck);
        ArrayList<DateTime> listOfFreeTimeSlots = DateTimeUtil.getListOfFreeTimeSlotsInDate(dateToCheck,
                listOfFilledTimeSlots);

        if (listOfFilledTimeSlots.isEmpty()) {
            return new CommandResult(String.format(MESSAGE_FREE_DAY, DateTimeUtil.getDayAndDateString(dateToCheck)));
        } else if (listOfFreeTimeSlots.isEmpty()) {
            return new CommandResult(
                    String.format(MESSAGE_NO_FREE_TIMESLOTS, DateTimeUtil.getDayAndDateString(dateToCheck)));
        } else {
            return new CommandResult(String.format(MESSAGE_SUCCESS,
                    DateTimeUtil.getStringOfFreeDateTimeInDate(dateToCheck, listOfFreeTimeSlots)));
        }
    }

}
```
###### \java\tars\logic\commands\RsvCommand.java
``` java
 */
public class RsvCommand extends UndoableCommand {

    public static final String COMMAND_WORD = "rsv";
    public static final String COMMAND_WORD_DEL = "rsv /del";

    public static final String MESSAGE_USAGE = COMMAND_WORD + ": Reserves one or more timeslot for a task.\n"
            + "Parameters: <TASK_NAME> </dt DATETIME> [/dt DATETIME ...]\n" + "Example: " + COMMAND_WORD
            + " Meet John Doe /dt 26/09/2016 0900 to 1030, 28/09/2016 1000 to 1130";

    public static final String MESSAGE_USAGE_DEL = COMMAND_WORD_DEL
            + ": Deletes a reserved task in the last reserved task listing \n"
            + "Parameters: INDEX (must be a positive integer)\n "
            + "Example: " + COMMAND_WORD_DEL + " 1\n" + "OR "
            + COMMAND_WORD_DEL + " 1..3";

    public static final String MESSAGE_DATETIME_NOT_FOUND =
            "At least one DateTime is required!\n" + MESSAGE_USAGE;

    public static final String MESSAGE_INVALID_RSV_TASK_DISPLAYED_INDEX =
            "The Reserved Task Index is invalid!";

    public static final String MESSAGE_SUCCESS = "New task reserved: %1$s";
    public static final String MESSAGE_SUCCESS_DEL = "Deleted reserved tasks:\n%1$s";
    public static final String MESSAGE_UNDO_DELETE = "Deleted %1$s";
    public static final String MESSAGE_UNDO_ADD = "Added:\n%1$s";
    public static final String MESSAGE_REDO_DELETE = "Deleted:%1$s";
    public static final String MESSAGE_REDO_ADD = "Added %1$s";

    private static final String MESSAGE_CONFLICT_FOR = "\nConflicts for ";

    private RsvTask toReserve = null;
    private String rangeIndexString = "";
    private String conflictingTaskList = "";
    
    private static final int INDEX_OF_ENDDATE = 1;
    private static final int INDEX_OF_STARTDATE = 0;

    private ArrayList<RsvTask> rsvTasksToDelete;

    /**
     * Convenience constructor using raw values.
     *
     * @throws IllegalValueException if any of the raw values are invalid
     * @throws DateTimeException if given dateTime string is invalid.
     */
    public RsvCommand(String name, Set<String[]> dateTimeStringSet) throws IllegalValueException {

        Set<DateTime> dateTimeSet = new HashSet<>();
        for (String[] dateTimeStringArray : dateTimeStringSet) {
            dateTimeSet.add(new DateTime(dateTimeStringArray[INDEX_OF_STARTDATE], dateTimeStringArray[INDEX_OF_ENDDATE]));
        }

        this.toReserve = new RsvTask(new Name(name), new ArrayList<DateTime>(dateTimeSet));
    }

    public RsvCommand(String rangeIndexString) {
        this.rangeIndexString = rangeIndexString;
    }

    @Override
    public CommandResult execute() {
        assert model != null;

        if (toReserve != null) {
            return addRsvTask();
        } else {
            return delRsvTask();
        }

    }

    private CommandResult addRsvTask() {
        try {
            for (DateTime dt : toReserve.getDateTimeList()) {
                if (!model.getTaskConflictingDateTimeWarningMessage(dt).isEmpty()) {
                    conflictingTaskList += MESSAGE_CONFLICT_FOR + dt.toString() + StringUtil.STRING_COLON;
                    conflictingTaskList += model.getTaskConflictingDateTimeWarningMessage(dt);
                }
            }
            model.addRsvTask(toReserve);
            model.getUndoableCmdHist().push(this);
            return new CommandResult(getSuccessMessageSummary());
        } catch (DuplicateTaskException e) {
            return new CommandResult(Messages.MESSAGE_DUPLICATE_TASK);
        }
    }

    private CommandResult delRsvTask() {
        rsvTasksToDelete = new ArrayList<RsvTask>();

        try {
            rsvTasksToDelete = getRsvTasksFromIndexes(this.rangeIndexString.split(StringUtil.STRING_WHITESPACE));
        } catch (InvalidTaskDisplayedException itde) {
            return new CommandResult(itde.getMessage());
        }
        
        for (RsvTask t : rsvTasksToDelete) {
            try {
                model.deleteRsvTask(t);
            } catch (RsvTaskNotFoundException rtnfe) {
                return new CommandResult(Messages.MESSAGE_RSV_TASK_CANNOT_BE_FOUND);
            }
        }
        
        model.getUndoableCmdHist().push(this);
        String deletedRsvTasksList = new Formatter().formatRsvTaskList(rsvTasksToDelete);
        return new CommandResult(String.format(MESSAGE_SUCCESS_DEL, deletedRsvTasksList));
    }

    /**
     * Gets Tasks to delete
     * 
     * @param indexes
     * @throws InvalidTaskDisplayedException
     */
    private ArrayList<RsvTask> getRsvTasksFromIndexes(String[] indexes)
            throws InvalidTaskDisplayedException {
        UnmodifiableObservableList<RsvTask> lastShownList = model.getFilteredRsvTaskList();
        ArrayList<RsvTask> rsvTasksList = new ArrayList<RsvTask>();

        for (int i = StringUtil.START_INDEX; i < indexes.length; i++) {
            int targetIndex = Integer.parseInt(indexes[i]);
            if (lastShownList.size() < targetIndex) {
                indicateAttemptToExecuteIncorrectCommand();
                throw new InvalidTaskDisplayedException(
                        Messages.MESSAGE_INVALID_RSV_TASK_DISPLAYED_INDEX);
            }
            RsvTask rsvTask = lastShownList.get(targetIndex - StringUtil.LAST_INDEX);
            rsvTasksList.add(rsvTask);
        }
        return rsvTasksList;
    }

    private String getSuccessMessageSummary() {
        String summary = String.format(MESSAGE_SUCCESS, toReserve.toString());

        if (!conflictingTaskList.isEmpty()) {
            summary += StringUtil.STRING_NEWLINE + Messages.MESSAGE_CONFLICTING_TASKS_WARNING + conflictingTaskList;
        }

        return summary;
    }
    
```
###### \java\tars\logic\parser\ConfirmCommandParser.java
``` java
 *
 */
public class ConfirmCommandParser extends CommandParser {

    @Override
    public Command prepareCommand(String args) {
        // there is no arguments
        if (args.trim().length() == 0) {
            return new IncorrectCommand(
                    String.format(MESSAGE_INVALID_COMMAND_FORMAT, ConfirmCommand.MESSAGE_USAGE));
        }

        ArgumentTokenizer argsTokenizer = new ArgumentTokenizer(priorityPrefix, tagPrefix);
        argsTokenizer.tokenize(args);

        int taskIndex;
        int dateTimeIndex;

        try {
            String indexArgs = argsTokenizer.getPreamble().get();
            String[] indexStringArray = StringUtil.indexString(indexArgs).split(StringUtil.STRING_WHITESPACE);
            if (indexStringArray.length != 2) {
                return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT,
                        ConfirmCommand.MESSAGE_USAGE));
            } else {
                taskIndex = Integer.parseInt(indexStringArray[0]);
                dateTimeIndex = Integer.parseInt(indexStringArray[1]);
            }
        } catch (IllegalValueException | NoSuchElementException e) {
            return new IncorrectCommand(
                    String.format(MESSAGE_INVALID_COMMAND_FORMAT, ConfirmCommand.MESSAGE_USAGE));
        } catch (InvalidRangeException ire) {
            return new IncorrectCommand(ire.getMessage());
        }

        try {
            return new ConfirmCommand(taskIndex, dateTimeIndex,
                    argsTokenizer.getValue(priorityPrefix).orElse(StringUtil.EMPTY_STRING),
                    argsTokenizer.getMultipleValues(tagPrefix).orElse(new HashSet<>()));
        } catch (IllegalValueException ive) {
            return new IncorrectCommand(
                    String.format(MESSAGE_INVALID_COMMAND_FORMAT, ConfirmCommand.MESSAGE_USAGE));
        }
    }

}
```
###### \java\tars\logic\parser\FreeCommandParser.java
``` java
 *
 */
public class FreeCommandParser extends CommandParser {
    
    public static final int FIRST_DATETIME_INDEX = 0;
    public static final int SECOND_DATETIME_INDEX = 1;

    @Override
    public Command prepareCommand(String args) {
        args = args.trim();

        if (args.isEmpty()) {
            return new IncorrectCommand(String.format(
                    MESSAGE_INVALID_COMMAND_FORMAT, FreeCommand.MESSAGE_USAGE));
        }

        String[] dateTimeStringArray = {StringUtil.EMPTY_STRING};

        try {
            dateTimeStringArray = DateTimeUtil.parseStringToDateTime(args);
        } catch (DateTimeException dte) {
            return new IncorrectCommand(String.format(
                    MESSAGE_INVALID_COMMAND_FORMAT, FreeCommand.MESSAGE_USAGE));
        }

        if (!dateTimeStringArray[FIRST_DATETIME_INDEX].isEmpty()) {
            return new IncorrectCommand(
                    FreeCommand.MESSAGE_DATE_RANGE_DETECTED);
        } else {
            try {
                return new FreeCommand(new DateTime(dateTimeStringArray[FIRST_DATETIME_INDEX],
                        dateTimeStringArray[SECOND_DATETIME_INDEX]));
            } catch (DateTimeException dte) {
                return new IncorrectCommand(Messages.MESSAGE_INVALID_DATE);
            } catch (IllegalDateException ide) {
                return new IncorrectCommand(Messages.MESSAGE_INVALID_DATE);
            }
        }
    }

}
```
###### \java\tars\logic\parser\RsvCommandParser.java
``` java
 *
 */
public class RsvCommandParser extends CommandParser {

    @Override
    public Command prepareCommand(String args) {
        // there is no arguments
        if (args.trim().length() == 0) {
            return new IncorrectCommand(
                    String.format(MESSAGE_INVALID_COMMAND_FORMAT, RsvCommand.MESSAGE_USAGE));
        }

        ArgumentTokenizer argsTokenizer = new ArgumentTokenizer(dateTimePrefix, deletePrefix);
        argsTokenizer.tokenize(args);

        if (argsTokenizer.getValue(deletePrefix).isPresent()) {
            return prepareRsvDel(argsTokenizer);
        } else {
            return prepareRsvAdd(argsTokenizer);
        }
    }

    // Parses arguments for adding a reserved task
    private Command prepareRsvAdd(ArgumentTokenizer argsTokenizer) {
        if (!argsTokenizer.getValue(dateTimePrefix).isPresent()) {
            return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT,
                    RsvCommand.MESSAGE_DATETIME_NOT_FOUND));
        }

        Set<String[]> dateTimeStringSet = new HashSet<>();

        try {
            for (String dateTimeString : argsTokenizer.getMultipleValues(dateTimePrefix).get()) {
                dateTimeStringSet.add(DateTimeUtil.parseStringToDateTime(dateTimeString));
            }

            return new RsvCommand(argsTokenizer.getPreamble().get(), dateTimeStringSet);
        } catch (IllegalValueException ive) {
            return new IncorrectCommand(ive.getMessage());
        } catch (DateTimeException dte) {
            return new IncorrectCommand(Messages.MESSAGE_INVALID_DATE);
        } catch (NoSuchElementException nse) {
            return new IncorrectCommand(
                    String.format(MESSAGE_INVALID_COMMAND_FORMAT, RsvCommand.MESSAGE_USAGE));
        }
    }

    // Parses arguments for deleting one or more reserved tasks
    private Command prepareRsvDel(ArgumentTokenizer argsTokenizer) {
        try {
            if (argsTokenizer.getPreamble().isPresent()) {
                return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT,
                        RsvCommand.MESSAGE_USAGE_DEL));
            }

            String rangeIndex = StringUtil.indexString(argsTokenizer.getValue(deletePrefix).get());
            return new RsvCommand(rangeIndex);
        } catch (InvalidRangeException | IllegalValueException ie) {
            return new IncorrectCommand(
                    String.format(MESSAGE_INVALID_COMMAND_FORMAT, RsvCommand.MESSAGE_USAGE_DEL));
        }
    }

}
```
###### \java\tars\model\Model.java
``` java
     */
    void deleteRsvTask(RsvTask target) throws RsvTaskNotFoundException;
    
    /** Adds the given reserved task */
    void addRsvTask(RsvTask rsvTask) throws DuplicateTaskException;
    
    /** Checks for tasks with conflicting datetime and returns a string of all conflicting tasks */
    public String getTaskConflictingDateTimeWarningMessage(DateTime dateTimeToCheck);

    /** Rename all task with the old tag with new tag name */
    void renameTasksWithNewTag(ReadOnlyTag toBeRenamed, Tag newTag)
            throws IllegalValueException, TagNotFoundException, DuplicateTagException;

    /** Remove the tag from all task */
    ArrayList<ReadOnlyTask> removeTagFromAllTasks(ReadOnlyTag toBeDeleted)
            throws DuplicateTagException, IllegalValueException, TagNotFoundException;
    
    /** Add tag to all task */
    void addTagToAllTasks(ReadOnlyTag toBeAdded, ArrayList<ReadOnlyTask> toBeEdited)
            throws DuplicateTagException, IllegalValueException, TagNotFoundException;

    /** Marks tasks as done or undone. */
    void mark(ArrayList<ReadOnlyTask> toMarkList, Status status) throws DuplicateTaskException;

    /** Returns the filtered task list as an {@code UnmodifiableObservableList<ReadOnlyTask>} */
    UnmodifiableObservableList<ReadOnlyTask> getFilteredTaskList();
    
    /** Returns the filtered task list as an {@code UnmodifiableObservableList<RsvTask>} */
    UnmodifiableObservableList<RsvTask> getFilteredRsvTaskList();

    /** Updates the filter of the filtered task list to show all tasks */
    void updateFilteredListToShowAll();

    /** Updates the filter of the filtered task list to filter by the given keywords*/
    void updateFilteredTaskList(Set<String> keywords);
    
    /**
     * Updates the filter of the filtered task list to filter by the given keywords of each given
     * task attribute
     * 
```
###### \java\tars\model\Model.java
``` java
     */
    void updateFilteredTaskListUsingFlags(TaskQuery taskQuery);
    
    /** Updates the filter of the filtered task list to filter by the given keywords of a string 
     * consisting of all the attributes of each task*/
    void updateFilteredTaskListUsingQuickSearch(ArrayList<String> lazySearchKeywords);

    /** Returns the undoable command history stack */
    Stack<Command> getUndoableCmdHist();
    
    /** Returns the redoable command history stack */
    Stack<Command> getRedoableCmdHist();
    
    /** Returns the unique tag list as an {@code ObservableList<? extends ReadOnlyTag>} */
    ObservableList<? extends ReadOnlyTag> getUniqueTagList();
    
    /**
     * Returns an ArrayList of DateTime in a specified date
     * 
```
###### \java\tars\model\Model.java
``` java
     */
    public ArrayList<DateTime> getListOfFilledTimeSlotsInDate(DateTime dateToCheck);

    /**
     * Sorts the filtered task list by the given keywords
     * 
```
###### \java\tars\model\ModelManager.java
``` java
   */
  public String getTaskConflictingDateTimeWarningMessage(DateTime dateTimeToCheck) {
    StringBuilder conflictingTasksStringBuilder = new StringBuilder(StringUtil.EMPTY_STRING);
    int taskCount = 1;
    int rsvCount = 1;

    if (dateTimeToCheck.getEndDate() == null) {
      return StringUtil.EMPTY_STRING;
    }

    for (ReadOnlyTask t : tars.getTaskList()) {

      if (t.getStatus().status == Status.UNDONE
          && DateTimeUtil.isDateTimeWithinRange(t.getDateTime(), dateTimeToCheck)) {
        conflictingTasksStringBuilder.append("\nTask ").append(taskCount).append(": ")
            .append(t.getAsText());
        taskCount++;
      }
    }

    for (RsvTask rt : tars.getRsvTaskList()) {
      if (rt.getDateTimeList().stream()
          .filter(
              dateTimeSource -> DateTimeUtil.isDateTimeWithinRange(dateTimeSource, dateTimeToCheck))
          .count() > 0) {
        conflictingTasksStringBuilder.append("\nRsvTask ").append(rsvCount).append(": ")
            .append(rt.toString());
        rsvCount++;

      }
    }

    return conflictingTasksStringBuilder.toString();
  }

  /**
   * Returns a sorted arraylist of filled datetime slots in a specified date Datetimes with no
   * startdate are not added into the list
   */
  public ArrayList<DateTime> getListOfFilledTimeSlotsInDate(DateTime dateToCheck) {
    ArrayList<DateTime> listOfDateTime = new ArrayList<DateTime>();

    for (ReadOnlyTask t : tars.getTaskList()) {
      if (t.getStatus().status == Status.UNDONE && t.getDateTime().getStartDate() != null
          && DateTimeUtil.isDateTimeWithinRange(t.getDateTime(), dateToCheck)) {
        listOfDateTime.add(t.getDateTime());
      }
    }

    for (RsvTask rt : tars.getRsvTaskList()) {
      for (DateTime dt : rt.getDateTimeList()) {
        if (dt.getStartDate() != null && DateTimeUtil.isDateTimeWithinRange(dt, dateToCheck)) {
          listOfDateTime.add(dt);
        }
      }
    }

    Collections.sort(listOfDateTime);

    return listOfDateTime;
  }


```
###### \java\tars\model\ModelManager.java
``` java
     * @param task
     * @return true if ALL keywords are found in the task name
     */
    @Override
    public boolean run(ReadOnlyTask task) {
      return nameKeyWords.stream()
          .filter(keyword -> StringUtil.containsIgnoreCase(task.getName().taskName, keyword))
          .count() == nameKeyWords.size();
    }

    @Override
    public String toString() {
      return "name=" + String.join(StringUtil.STRING_COMMA, nameKeyWords);
    }
  }


```
###### \java\tars\model\Tars.java
``` java
     * @throws UniqueTaskList.DuplicateTaskException if an equivalent reserved task already exists.
     */
    public void addRsvTask(RsvTask rt) throws DuplicateTaskException {
        rsvTasks.add(rt);
    }

    /**
     * Marks every task in respective lists as done or undone
     * 
```
###### \java\tars\model\task\rsv\RsvTask.java
``` java
 */
public class RsvTask {

    protected Name name;
    protected ArrayList<DateTime> dateTimeList = new ArrayList<DateTime>();

    public RsvTask() {

    }

    public RsvTask(Name name, ArrayList<DateTime> dateTimeList) {
        assert !CollectionUtil.isAnyNull(name, dateTimeList);

        this.name = name;
        this.dateTimeList = dateTimeList;

    }

    /**
     * Copy constructor.
     */
    public RsvTask(RsvTask source) {
        this(source.getName(), source.getDateTimeList());
    }

    /*
     * Accessors
     */

    public Name getName() {
        return name;
    }

    public ArrayList<DateTime> getDateTimeList() {
        return dateTimeList;
    }

    /*
     * Mutators
     */
    public void setName(Name name) {
        this.name = name;
    }

    public void setDateTimeList(ArrayList<DateTime> dateTimeList) {
        this.dateTimeList = dateTimeList;
    }

    @Override
    public boolean equals(Object other) {
        return other == this // short circuit if same object
                || (other instanceof RsvTask // instanceof handles nulls
                        && this.isSameStateAs((RsvTask) other));
    }

    private boolean isSameStateAs(RsvTask other) {
        return other == this // short circuit if same object
                || (other != null // this is first to avoid NPE below
                        && other.getName().equals(this.getName())
                        && other.getDateTimeList()
                                .equals(this.getDateTimeList()));
    }

    @Override
    public int hashCode() {
        // use this method for custom fields hashing instead of implementing
        // your own
        return Objects.hash(name, dateTimeList);
    }

    @Override
    public String toString() {
        final StringBuilder builder = new StringBuilder();
        builder.append(getName()).append(" DateTime: ").append(getDateTimeList().toString());

        return builder.toString();
    }

}
```
###### \java\tars\model\task\rsv\UniqueRsvTaskList.java
``` java
 *
 * @see RsvTask#equals(Object)
 * @see CollectionUtil#elementsAreUnique(Collection)
 */
public class UniqueRsvTaskList implements Iterable<RsvTask> {

    /**
     * Signals that an operation targeting a specified task in the list would
     * fail because there is no such matching task in the list.
     */
    public static class RsvTaskNotFoundException extends Exception {
    }

    private final ObservableList<RsvTask> internalList = FXCollections.observableArrayList();

    /**
     * Constructs empty RsvTaskList.
     */
    public UniqueRsvTaskList() {
    }

    /**
     * Returns true if the list contains an equivalent reserved task as the
     * given argument.
     */
    public boolean contains(RsvTask toCheck) {
        assert toCheck != null;
        return internalList.contains(toCheck);
    }

    /**
     * Adds a reserved task to the list.
     *
     * @throws DuplicateTaskException
     *             if the reserved task to add is a duplicate of an existing
     *             reserved task in the list.
     */
    public void add(RsvTask toAdd) throws DuplicateTaskException {
        assert toAdd != null;
        if (contains(toAdd)) {
            throw new DuplicateTaskException();
        }
        internalList.add(toAdd);
    }

    /**
     * Removes the equivalent reserved task from the list.
     *
     * @throws TaskNotFoundException
     *             if no such task could be found in the list.
     */
    public boolean remove(RsvTask toRemove) throws RsvTaskNotFoundException {
        assert toRemove != null;
        final boolean taskFoundAndDeleted = internalList.remove(toRemove);
        if (!taskFoundAndDeleted) {
            throw new RsvTaskNotFoundException();
        }
        return taskFoundAndDeleted;
    }

    public ObservableList<RsvTask> getInternalList() {
        return internalList;
    }

    @Override
    public Iterator<RsvTask> iterator() {
        return internalList.iterator();
    }
    
    @Override
    public boolean equals(Object other) {
        return other == this // short circuit if same object
                || (other instanceof UniqueRsvTaskList // instanceof handles nulls
                && this.internalList.equals(
                ((UniqueRsvTaskList) other).internalList));
    }

    @Override
    public int hashCode() {
        return internalList.hashCode();
    }

}
```
###### \java\tars\model\task\TaskQuery.java
``` java
 */
public class TaskQuery extends Task {

    private static final String EMPTY_STRING = "";
    private String tagQuery = "";
    private String statusString = "";
    public final static String MESSAGE_BOTH_STATUS_SEARCHED_ERROR = "Both '-do (Done)' and '-ud (Undone)' flags "
            + "have been detected.\n"
            + "Please search for either '-do (Done)' or '-ud (Undone)' status";

    public TaskQuery() {
    }

    public TaskQuery(Name name, DateTime dateTime, Priority priority, Status status, UniqueTagList tags) {
        super(name, dateTime, priority, status, tags);
    }

    /* --------------- SETTER METHODS -------------------- */

    public void createNameQuery(String nameQueryString) throws IllegalValueException {
        name = new Name(nameQueryString);
    }

    public void createDateTimeQuery(String[] dateTimeQueryString) throws DateTimeException, IllegalDateException {
        dateTime = new DateTime(dateTimeQueryString[0], dateTimeQueryString[1]);
    }

    public void createPriorityQuery(String priorityString) throws IllegalValueException {

        /*
         * To convert long versions of priority strings (i.e. high, medium, low)
         * into characters (i.e. h, m, l)
         */
        switch (priorityString) {
        case PRIORITY_HIGH:
            priorityString = PRIORITY_H;
            break;

        case PRIORITY_MEDIUM:
            priorityString = PRIORITY_M;
            break;

        case PRIORITY_LOW:
            priorityString = PRIORITY_L;
            break;
        }

        priority = new Priority(priorityString);
    }

    public void createStatusQuery(Boolean statusQuery) {
        status = new Status();
        status.status = statusQuery;
    }

    public void createTagsQuery(String tagQueryString) {
        tagQuery = tagQueryString;
    }

    /* --------------- GETTER METHODS -------------------- */

    public ArrayList<String> getNameKeywordsAsList() {
        return new ArrayList<String>(Arrays.asList(getName().taskName.split(StringUtil.STRING_WHITESPACE)));
    }

    public DateTime getDateTimeQueryRange() {
        if (getDateTime().getEndDate() != null) {
            return getDateTime();
        } else {
            return null;
        }
    }

    public ArrayList<String> getPriorityKeywordsAsList() {
        return new ArrayList<String>(Arrays.asList(priorityString()));
    }

    public String getStatusQuery() {
        if (status != null) {
            statusString = status.toString();
        }
        return statusString;
    }

    public ArrayList<String> getTagKeywordsAsList() {
        return new ArrayList<String>(Arrays.asList(tagQuery.split(StringUtil.STRING_WHITESPACE)));
    }

    @Override
    public String toString() {
        final StringBuilder builder = new StringBuilder();
        builder.append("Filter Search Keywords: ");

        if (!EMPTY_STRING.equals(getName().toString())) {
            builder.append("[Task Name: ").append(getName()).append("] ");
        }
        if (getDateTime().getEndDate() != null) {
            builder.append("[DateTime: ").append(getDateTime()).append("] ");
        }
        if (!EMPTY_STRING.equals(priorityString())) {
            builder.append("[Priority: ").append(priorityString()).append("] ");
        }
        if (!EMPTY_STRING.equals(statusString)) {
            builder.append("[Status: ").append(statusString).append("] ");
        }
        if (!EMPTY_STRING.equals(tagQuery)) {
            builder.append("[Tags: ").append(tagQuery).append("]");
        }

        return builder.toString();
    }

}
```
###### \java\tars\storage\Storage.java
``` java
     * @param newFilePath
     * @param newConfig
     */
    void updateTarsStorageDirectory(String newFilePath, Config newConfig);
}
```
###### \java\tars\storage\StorageManager.java
``` java
    public void updateTarsStorageDirectory(String newFilePath, Config newConfig) {
        tarsStorage = new XmlTarsStorage(newFilePath);
        indicateTarsStorageDirectoryChanged(newFilePath, newConfig);
    }
    
    //Raise an event that the tars storage directory has changed
    private void indicateTarsStorageDirectoryChanged(String newFilePath, Config newConfig) {
        raise(new TarsStorageDirectoryChangedEvent(newFilePath, newConfig));
    }

    @Override
    @Subscribe
    public void handleTarsChangedEvent(TarsChangedEvent event) {
        logger.info(LogsCenter.getEventHandlingLogMessage(event, "Local data changed, saving to file"));
        try {
            saveTars(event.data);
        } catch (IOException e) {
            raise(new DataSavingExceptionEvent(e));
        }
    }

}
```
###### \java\tars\ui\CommandBox.java
``` java
    private void setTextFieldKeyPressedHandler() {
        commandTextField.setOnKeyPressed(new EventHandler<KeyEvent>() {
            public void handle(KeyEvent ke) {
                if (ke.getCode().equals(KeyCode.UP)) {
                    setTextToShowPrevCmdText(ke);
                } else if (ke.getCode().equals(KeyCode.DOWN)) {
                    setTextToShowNextCmdText(ke);
                } else if (KeyCombinations.KEY_COMB_CTRL_RIGHT_ARROW
                        .match(ke)) {
                    raise(new KeyCombinationPressedEvent(
                            KeyCombinations.KEY_COMB_CTRL_RIGHT_ARROW));
                    ke.consume();
                } else if (KeyCombinations.KEY_COMB_CTRL_LEFT_ARROW.match(ke)) {
                    raise(new KeyCombinationPressedEvent(
                            KeyCombinations.KEY_COMB_CTRL_LEFT_ARROW));
                    ke.consume();
                } else if (KeyCombinations.KEY_COMB_CTRL_Z.match(ke)) {
                    handleUndoAndRedoKeyRequest(UndoCommand.COMMAND_WORD);
                } else if (KeyCombinations.KEY_COMB_CTRL_Y.match(ke)) {
                    handleUndoAndRedoKeyRequest(RedoCommand.COMMAND_WORD);
                }
            }
        });
    }

    private void setTextFieldValueHandler() {
        commandTextField.textProperty()
                .addListener((observable, oldValue, newValue) -> {
                    if (newValue.equals(RsvCommand.COMMAND_WORD)
                            || newValue.equals(ConfirmCommand.COMMAND_WORD)) {
                        raise(new CommandBoxTextFieldValueChangedEvent(
                                newValue));
                    }
                });

    }

```
###### \java\tars\ui\MainWindow.java
``` java
     */
    public void reloadStatusBarFooter(String newTarsFilePath) {
        statusBarFooter = StatusBarFooter.load(primaryStage,
                getStatusbarPlaceholder(), newTarsFilePath);
    }

```
###### \java\tars\ui\StatusBarFooter.java
``` java
    @Subscribe
    private void handleTarsStorageChangeDirectoryEvent(
            TarsStorageDirectoryChangedEvent event) {
        logger.info(LogsCenter.getEventHandlingLogMessage(event));
        setSaveLocation(
                "Storage Location Changed: ./" + event.getNewFilePath());
    }
}
```
